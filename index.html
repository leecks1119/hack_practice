<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>러너 3D 슈팅 게임</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: Arial, sans-serif; 
            touch-action: none;
        }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            padding: 5px;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 1px 1px 1px black;
            z-index: 10;
        }
        #equationInfo {
            position: absolute;
            top: 40px;
            width: 100%;
            text-align: center;
            color: #ffcc00;
            padding: 5px;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 1px 1px 1px black;
            z-index: 10;
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none;
            z-index: 20;
        }
        #restartBtn {
            padding: 15px 30px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 18px;
            margin-top: 20px;
        }
        #restartBtn:hover {
            background-color: #45a049;
        }
        #controls {
            position: absolute;
            bottom: 30px;
            width: 100%;
            display: flex;
            justify-content: center;
            z-index: 10;
        }
        .controlBtn {
            width: 80px;
            height: 80px;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 40px;
            margin: 0 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
            user-select: none;
        }
    </style>
</head>
<body>
    <div id="info">아군: <span id="allyCount">1</span> | 시간: <span id="timer">60</span>초 | 점수: <span id="score">0</span></div>
    <div id="equationInfo">현재 패널: <span id="currentEquation">없음</span></div>
    <div id="gameOver">
        <h2>게임 종료!</h2>
        <p>최종 점수: <span id="finalScore">0</span></p>
        <button id="restartBtn">다시 시작</button>
    </div>
    <div id="controls">
        <div id="leftBtn" class="controlBtn">←</div>
        <div id="rightBtn" class="controlBtn">→</div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // 게임 변수
        let scene, camera, renderer, allies = [], enemies = [], bullets = [], panels = [];
        let gameTime = 60; // 1분
        let score = 0;
        let difficulty = 1;
        let gameActive = true;
        let lastPanelTime = 0;
        let lastEnemyWaveTime = 0;
        let lastFireTime = 0;
        let playerLane = 1; // 0: 왼쪽, 1: 중앙, 2: 오른쪽
        let isMoving = false;
        let roadSpeed = 0.5;
        let roadSegments = [];
        let gameDistance = 0;
        let activeEquation = "";
        
        // 레인 위치 정의
        const lanes = [-5, 0, 5];
        
        // 수학 연산자
        const operators = [
            { symbol: "+", fn: (a, b) => a + b, color: 0x00ffff },
            { symbol: "-", fn: (a, b) => Math.max(1, a - b), color: 0xff9999 }, // 최소 1명의 아군 보장
            { symbol: "×", fn: (a, b) => a * b, color: 0x99ccff },
            { symbol: "÷", fn: (a, b) => Math.round(a / b) || 1, color: 0xffcc99 } // 0이 되지 않도록 보장
        ];
        
        // 게임 초기화
        function init() {
            // 씬 설정
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e); // 어두운 남색 배경
            
            // 안개 추가 (원근감) - 더 짙게 설정
            scene.fog = new THREE.Fog(0x1a1a2e, 30, 80);
            
            // 카메라 설정
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 8, 12); // 카메라 높이와 거리 조정
            camera.lookAt(0, 0, -20);
            
            // 렌더러 설정
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; // 그림자 활성화
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);
            
            // 조명 설정
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(0, 20, 10);
            directionalLight.castShadow = true; // 그림자 생성
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -20;
            directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20;
            directionalLight.shadow.camera.bottom = -20;
            scene.add(directionalLight);
            
            // 도로 생성
            createRoad();
            
            // 첫 아군 생성
            createAllies(1);
            
            // 이벤트 리스너
            window.addEventListener('resize', onWindowResize);
            document.getElementById('restartBtn').addEventListener('click', restartGame);
            
            // 모바일 컨트롤 초기화
            initControls();
            
            // 게임 타이머 시작
            startGameTimer();
            
            // 게임 루프 시작
            animate();
        }
        
        // 도로 생성 함수
        function createRoad() {
            // 도로 텍스처 (하늘색 그라데이션 패턴으로 변경)
            const roadWidth = 15;
            const roadLength = 1000;
            const segmentLength = 20;
            const segments = roadLength / segmentLength;
            
            // 도로 기본 재질 (밝은 색상으로 변경)
            const roadMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xE6F7FF,
                roughness: 0.7,
                metalness: 0.2
            });
            
            // 도로 경계선 재질 (진한 색상으로 변경)
            const lineMaterial = new THREE.MeshStandardMaterial({ color: 0x4B0082 });
            
            // 도로 가장자리 재질 (푸른 색상으로 변경)
            const sideMaterial = new THREE.MeshStandardMaterial({ color: 0x1E90FF });
            
            // 도로 그라데이션을 위한 재질 배열
            const patternMaterials = [
                new THREE.MeshStandardMaterial({ color: 0xE6F7FF }), // 밝은 하늘색
                new THREE.MeshStandardMaterial({ color: 0xD4F1F9 })  // 약간 더 진한 하늘색
            ];
            
            // 여러 세그먼트로 도로 생성
            for (let i = 0; i < segments; i++) {
                // 도로 세그먼트 (패턴 적용)
                const roadGeometry = new THREE.PlaneGeometry(roadWidth, segmentLength);
                const road = new THREE.Mesh(roadGeometry, patternMaterials[i % 2]); // 번갈아가며 패턴 적용
                road.rotation.x = -Math.PI / 2;
                road.position.z = -i * segmentLength - segmentLength / 2;
                road.position.y = -0.1;
                road.receiveShadow = true; // 그림자 받기
                scene.add(road);
                roadSegments.push(road);
                
                // 도로 레인 구분선
                for (let j = -1; j <= 1; j += 2) {
                    const lineGeometry = new THREE.PlaneGeometry(0.3, segmentLength);
                    const line = new THREE.Mesh(lineGeometry, lineMaterial);
                    line.rotation.x = -Math.PI / 2;
                    line.position.set(j * roadWidth/6, -0.05, -i * segmentLength - segmentLength / 2);
                    line.receiveShadow = true;
                    scene.add(line);
                    roadSegments.push(line);
                }
                
                // 도로 가장자리
                for (let j = -1; j <= 1; j += 2) {
                    const sideGeometry = new THREE.BoxGeometry(2, 1, segmentLength);
                    const side = new THREE.Mesh(sideGeometry, sideMaterial);
                    side.position.set(j * (roadWidth/2 + 1), 0.4, -i * segmentLength - segmentLength / 2);
                    side.castShadow = true;
                    side.receiveShadow = true;
                    scene.add(side);
                    roadSegments.push(side);
                    
                    // 가드레일 기둥 추가
                    if (i % 2 === 0) {
                        const postGeometry = new THREE.BoxGeometry(0.5, 2, 0.5);
                        const postMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
                        const post = new THREE.Mesh(postGeometry, postMaterial);
                        post.position.set(j * (roadWidth/2 + 1), 1.5, -i * segmentLength - segmentLength / 2);
                        post.castShadow = true;
                        post.receiveShadow = true;
                        scene.add(post);
                        roadSegments.push(post);
                    }
                }
            }
        }
        
        // 도로 스크롤 함수
        function scrollRoad() {
            const resetPos = -1000; // 도로 총 길이
            
            roadSegments.forEach(segment => {
                segment.position.z += roadSpeed;
                
                // 도로 세그먼트가 카메라 뒤로 지나가면 다시 앞으로 재배치
                if (segment.position.z > 20) {
                    segment.position.z = resetPos + (segment.position.z - 20);
                }
            });
            
            // 거리 증가
            gameDistance += roadSpeed;
        }
        
        // 컨트롤 초기화
        function initControls() {
            const leftBtn = document.getElementById('leftBtn');
            const rightBtn = document.getElementById('rightBtn');
            
            // 터치 이벤트
            leftBtn.addEventListener('touchstart', moveLeft);
            rightBtn.addEventListener('touchstart', moveRight);
            
            // 마우스 이벤트 (데스크톱용)
            leftBtn.addEventListener('mousedown', moveLeft);
            rightBtn.addEventListener('mousedown', moveRight);
            
            // 키보드 이벤트
            window.addEventListener('keydown', function(e) {
                if (!gameActive || isMoving) return;
                
                if (e.key === 'ArrowLeft') {
                    moveLeft();
                } else if (e.key === 'ArrowRight') {
                    moveRight();
                }
            });
            
            function moveLeft() {
                if (!gameActive || isMoving || playerLane === 0) return;
                
                isMoving = true;
                playerLane--;
                moveAlliesTo(lanes[playerLane]);
            }
            
            function moveRight() {
                if (!gameActive || isMoving || playerLane === 2) return;
                
                isMoving = true;
                playerLane++;
                moveAlliesTo(lanes[playerLane]);
            }
        }
        
        // 아군 이동 함수
        function moveAlliesTo(targetX) {
            // 0.3초에 걸쳐 부드럽게 이동
            const frames = 15; // 60fps 기준 0.25초
            let currentFrame = 0;
            
            // 메인 아군 현재 위치
            const startX = allies[0].position.x;
            const moveAmount = (targetX - startX) / frames;
            
            const moveInterval = setInterval(() => {
                if (currentFrame >= frames) {
                    clearInterval(moveInterval);
                    isMoving = false;
                    return;
                }
                
                // 모든 아군 이동
                allies.forEach((ally, index) => {
                    if (index === 0) {
                        // 메인 아군
                        ally.position.x += moveAmount;
                    } else {
                        // 나머지 아군들은 메인 아군을 따라감
                        updateAllyFormation();
                    }
                });
                
                currentFrame++;
            }, 1000/60); // 60fps
        }
        
        // 아군 진형 업데이트
        function updateAllyFormation() {
            if (allies.length <= 1) return;
            
            const mainAlly = allies[0];
            const allyCount = allies.length;
            
            // 진영 크기 계산 - 아군이 많을수록 더 넓게 퍼짐
            const formationWidth = Math.min(3, 0.5 + (allyCount * 0.1));
            const formationDepth = Math.min(4, 1 + (allyCount * 0.15));
            
            for (let i = 1; i < allyCount; i++) {
                // 균등하게 분포된 위치 계산
                let row = Math.floor((i-1) / 3);
                let col = (i-1) % 3;
                
                // 중앙 정렬을 위한 오프셋
                let colOffset = col - 1; // -1, 0, 1
                let rowOffset = -row; // 항상 플레이어 뒤에 배치
                
                allies[i].position.x = mainAlly.position.x + (colOffset * formationWidth);
                allies[i].position.z = mainAlly.position.z + (rowOffset * formationDepth);
            }
        }
        
        // 아군 생성 함수 - 캐릭터 디자인 개선
        function createAllies(count) {
            // 기존 아군 제거
            allies.forEach(ally => scene.remove(ally));
            allies = [];
            
            // 최댓값 제한 (너무 많으면 게임이 쉬워짐)
            count = Math.min(count, 30);
            
            // 새 아군 생성 - 귀여운 오렌지색 캐릭터로 변경
            for (let i = 0; i < count; i++) {
                // 캐릭터 그룹
                const character = new THREE.Group();
                
                // 몸체 (구)
                const bodyGeometry = new THREE.SphereGeometry(0.5, 16, 16);
                const bodyMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFF9900, // 오렌지색
                    emissive: 0xAA5500,
                    emissiveIntensity: 0.2,
                    roughness: 0.7
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.castShadow = true;
                body.receiveShadow = true;
                character.add(body);
                
                // 캐릭터에 눈 추가
                const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
                
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(0.2, 0.2, 0.4);
                character.add(leftEye);
                
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(-0.2, 0.2, 0.4);
                character.add(rightEye);
                
                // 눈동자
                const pupilGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                const pupilMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
                
                const leftPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                leftPupil.position.set(0.2, 0.2, 0.45);
                character.add(leftPupil);
                
                const rightPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                rightPupil.position.set(-0.2, 0.2, 0.45);
                character.add(rightPupil);
                
                // 팔과 다리 추가 (메인 캐릭터만)
                if (i === 0) {
                    // 팔
                    const armGeometry = new THREE.SphereGeometry(0.15, 8, 8);
                    
                    const leftArm = new THREE.Mesh(armGeometry, bodyMaterial);
                    leftArm.position.set(0.6, 0, 0);
                    leftArm.castShadow = true;
                    character.add(leftArm);
                    
                    const rightArm = new THREE.Mesh(armGeometry, bodyMaterial);
                    rightArm.position.set(-0.6, 0, 0);
                    rightArm.castShadow = true;
                    character.add(rightArm);
                    
                    // 다리
                    const legGeometry = new THREE.CylinderGeometry(0.15, 0.1, 0.5, 8);
                    
                    const leftLeg = new THREE.Mesh(legGeometry, bodyMaterial);
                    leftLeg.position.set(0.2, -0.5, 0);
                    leftLeg.castShadow = true;
                    character.add(leftLeg);
                    
                    const rightLeg = new THREE.Mesh(legGeometry, bodyMaterial);
                    rightLeg.position.set(-0.2, -0.5, 0);
                    rightLeg.castShadow = true;
                    character.add(rightLeg);
                }
                
                if (i === 0) {
                    // 메인 아군 (플레이어)
                    character.position.set(lanes[playerLane], 0.5, 0);
                } else {
                    // 추가 아군들은 초기 위치만 설정 (updateAllyFormation에서 정확히 배치됨)
                    character.position.set(lanes[playerLane], 0.5, -i);
                    // 작게 만들기
                    character.scale.set(0.8, 0.8, 0.8);
                }
                
                scene.add(character);
                allies.push(character);
            }
            
            // 진형 업데이트
            updateAllyFormation();
            
            // UI 업데이트
            document.getElementById('allyCount').textContent = allies.length;
        }
        
        // 적 생성 함수 - 웨이브 형태로 생성
        function createEnemyWave() {
            const waveType = Math.floor(Math.random() * 4);
            
            switch (waveType) {
                case 0: // 일렬 웨이브
                    const randomLane = Math.floor(Math.random() * 3);
                    for (let i = 0; i < 5 + Math.floor(difficulty); i++) {
                        createEnemy(randomLane, -80 - (i * 4));
                    }
                    break;
                    
                case 1: // V 형태 웨이브
                    for (let i = 0; i < 7; i++) {
                        const laneOffset = (i <= 3) ? i : 6 - i; // 0,1,2,3,2,1,0
                        createEnemy(laneOffset, -80 - (i * 3));
                    }
                    break;
                    
                case 2: // 모든 레인 웨이브
                    for (let i = 0; i < 3; i++) {
                        for (let j = 0; j < 3; j++) {
                            createEnemy(j, -80 - (i * 5));
                        }
                    }
                    break;
                    
                case 3: // 랜덤 웨이브
                    const enemyCount = 5 + Math.floor(difficulty * 2);
                    for (let i = 0; i < enemyCount; i++) {
                        const randLane = Math.floor(Math.random() * 3);
                        const randDist = -80 - (Math.random() * 20);
                        createEnemy(randLane, randDist);
                    }
                    break;
            }
            
            function createEnemy(lane, zPos) {
                // 적 그룹
                const enemy = new THREE.Group();
                
                // 적 몸체 (기본 모양)
                const enemyGeometry = new THREE.SphereGeometry(0.5, 16, 16);
                const enemyMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xff0000,
                    emissive: 0xaa0000,
                    emissiveIntensity: 0.3,
                    roughness: 0.6
                });
                const body = new THREE.Mesh(enemyGeometry, enemyMaterial);
                body.castShadow = true;
                body.receiveShadow = true;
                enemy.add(body);
                
                // 적 눈 (흰색)
                const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
                
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(0.2, 0.2, 0.4);
                enemy.add(leftEye);
                
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(-0.2, 0.2, 0.4);
                enemy.add(rightEye);
                
                // 적 눈동자 (검은색)
                const pupilGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                const pupilMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
                
                const leftPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                leftPupil.position.set(0.2, 0.2, 0.45);
                enemy.add(leftPupil);
                
                const rightPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                rightPupil.position.set(-0.2, 0.2, 0.45);
                enemy.add(rightPupil);
                
                enemy.position.set(lanes[lane], 0.5, zPos);
                scene.add(enemy);
                enemies.push(enemy);
            }
        }
        
        // 총알 발사 함수
        function fireBullets() {
            const currentTime = Date.now();
            
            // 자동 발사 간격 (아군 수에 따라 감소)
            const fireInterval = Math.max(100, 500 - (allies.length * 10));
            
            if (currentTime - lastFireTime < fireInterval) return;
            
            lastFireTime = currentTime;
            
            // 아군 수에 비례해서 총알 발사 (아군당 0.5발의 총알)
            const bulletsToFire = Math.max(1, Math.ceil(allies.length * 0.5));
            
            for (let i = 0; i < bulletsToFire; i++) {
                const bulletGeometry = new THREE.SphereGeometry(0.2, 8, 8);
                const bulletMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xffff00, 
                    emissive: 0xffff00,
                    emissiveIntensity: 0.8
                });
                const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
                
                // 총알 발사 방향 다각화
                let angleOffset = 0;
                if (bulletsToFire > 1) {
                    // 부채꼴 형태로 퍼지게 발사
                    const spreadFactor = Math.min(0.3, bulletsToFire * 0.02);  // 최대 0.3 라디안 (약 17도)
                    angleOffset = spreadFactor * ((i / (bulletsToFire - 1)) * 2 - 1);
                }
                
                // 총알 위치는 무작위 아군 위치에서 시작
                const shooterIndex = Math.floor(Math.random() * allies.length);
                bullet.position.copy(allies[shooterIndex].position);
                bullet.position.z -= 1; // 약간 앞에서 발사
                
                // 총알 방향 설정
                bullet.userData.direction = new THREE.Vector3(angleOffset, 0, -1).normalize();
                bullet.userData.speed = 1.5;
                
                scene.add(bullet);
                bullets.push(bullet);
                
                // 총알 발사 이펙트 (빛)
                const bulletLight = new THREE.PointLight(0xffff00, 2, 5);
                bulletLight.position.copy(bullet.position);
                scene.add(bulletLight);
                
                // 0.1초 후 이펙트 제거
                setTimeout(() => {
                    scene.remove(bulletLight);
                }, 100);
            }
        }
        
        // 사칙연산 패널 생성 함수
        function createMathPanels() {
            // 기존 패널 제거
            panels.forEach(panel => scene.remove(panel));
            panels = [];
            
            // 랜덤 연산자 선택
            const operator = operators[Math.floor(Math.random() * operators.length)];
            
            // 피연산자 선택 (난이도에 따라 증가)
            const operand = Math.floor(Math.random() * Math.min(5, difficulty)) + 1;
            
            // 현재 아군 수와 연산 결과 계산
            const currentAllies = allies.length;
            const result = operator.fn(currentAllies, operand);
            
            // 연산 표시 업데이트
            activeEquation = `${currentAllies} ${operator.symbol} ${operand} = ${result}`;
            document.getElementById('currentEquation').textContent = activeEquation;
            
            // 도로 세 레인에 패널 생성
            for (let i = 0; i < 3; i++) {
                createMathPanel(lanes[i], -60 - Math.random() * 10, operand, operator);
            }
            
            function createMathPanel(x, z, operand, operator) {
                // 패널 그룹
                const panel = new THREE.Group();
                
                // 패널 플랫폼
                const panelGeometry = new THREE.BoxGeometry(3, 0.3, 3);
                
                // 연산자에 맞는 색상 적용
                const panelMaterial = new THREE.MeshStandardMaterial({ 
                    color: operator.color,
                    emissive: operator.color,
                    emissiveIntensity: 0.3,
                    transparent: true,
                    opacity: 0.85
                });
                
                const panelMesh = new THREE.Mesh(panelGeometry, panelMaterial);
                panelMesh.castShadow = true;
                panelMesh.receiveShadow = true;
                panel.add(panelMesh);
                
                // 패널에 숫자 표시를 위한 텍스트 (Three.js에서는 실제 텍스트 렌더링이 어려워 대체 표현)
                const operatorSymbol = operator.symbol;
                const operatorTextGeometry = new THREE.BoxGeometry(1, 0.1, 1);
                const operatorTextMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFFFFFF,
                    emissive: 0xFFFFFF,
                    emissiveIntensity: 0.5
                });
                
                const operatorText = new THREE.Mesh(operatorTextGeometry, operatorTextMaterial);
                operatorText.position.y = 0.2;
                panel.add(operatorText);
                
                // 숫자 표시 (간소화된 형태)
                const numberGeometry = new THREE.BoxGeometry(0.5, 0.1, 0.5);
                const numberMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
                const numberMesh = new THREE.Mesh(numberGeometry, numberMaterial);
                numberMesh.position.set(0, 0.2, 0.5);
                panel.add(numberMesh);
                
                // 패널 위치 설정
                panel.position.set(x, 0, z);
                
                // 패널에 연산 데이터 추가
                panel.userData = {
                    operator: operatorSymbol,
                    operand: operand,
                    result: result
                };
                
                // 패널 발광 효과
                const panelLight = new THREE.PointLight(operator.color, 1, 5);
                panelLight.position.set(0, 0.5, 0);
                panel.add(panelLight);
                
                scene.add(panel);
                panels.push(panel);
            }
        }
        
        // 게임 업데이트 함수
        function updateGame() {
            const currentTime = Date.now();
            
            // 도로 스크롤
            scrollRoad();
            
            // 3초마다 패널 생성
            if (currentTime - lastPanelTime > 3000) {
                createMathPanels();
                lastPanelTime = currentTime;
            }
            
            // 난이도에 따라 적 웨이브 생성 주기 조절
            const enemyWaveInterval = Math.max(2000, 5000 - (difficulty * 300));
            if (currentTime - lastEnemyWaveTime > enemyWaveInterval) {
                createEnemyWave();
                lastEnemyWaveTime = currentTime;
            }
            
            // 자동 총알 발사
            fireBullets();
            
            // 패널 이동 (도로와 함께 이동)
            panels.forEach(panel => {
                panel.position.z += roadSpeed;
                
                // 화면 끝에 도달한 패널은 제거
                if (panel.position.z > 10) {
                    scene.remove(panel);
                    panels.splice(panels.indexOf(panel), 1);
                    
                    // 모든 패널이 사라졌을 때 현재 연산 초기화
                    if (panels.length === 0) {
                        document.getElementById('currentEquation').textContent = "없음";
                    }
                }
            });
            
            // 적 이동 (도로와 함께 이동, 약간 더 빠르게)
            enemies.forEach(enemy => {
                enemy.position.z += roadSpeed * 1.2;
                
                // 화면 끝에 도달한 적은 제거
                if (enemy.position.z > 10) {
                    scene.remove(enemy);
                    enemies.splice(enemies.indexOf(enemy), 1);
                }
                
                // 적 애니메이션 (약간 상하로 움직임)
                enemy.position.y = 0.5 + Math.sin(currentTime / 300 + enemy.position.z) * 0.1;
                
                // 추가: 적 회전 애니메이션
                enemy.rotation.y += 0.02;
            });
            
            // 아군 애니메이션 (약간 위아래로 움직임)
            allies.forEach((ally, index) => {
                // 메인 캐릭터 (0번 인덱스)만 특별한 애니메이션 적용
                if (index === 0) {
                    ally.position.y = 0.5 + Math.sin(currentTime / 500) * 0.05;
                    
                    // 달리기 애니메이션 효과 (앞뒤로 약간 기울임)
                    ally.rotation.x = Math.sin(currentTime / 200) * 0.1;
                } else {
                    // 다른 아군들은 약간 다른 주기로 움직여 자연스러움 증가
                    ally.position.y = 0.5 + Math.sin((currentTime / 500) + index * 0.5) * 0.05;
                }
            });
            
            // 총알 이동
            bullets.forEach(bullet => {
                const direction = bullet.userData.direction;
                bullet.position.x += direction.x * bullet.userData.speed;
                bullet.position.z += direction.z * bullet.userData.speed;
                
                // 총알 회전 효과 추가
                bullet.rotation.x += 0.2;
                bullet.rotation.y += 0.2;
                
                // 화면 밖으로 나간 총알 제거
                if (bullet.position.z < -100) {
                    scene.remove(bullet);
                    bullets.splice(bullets.indexOf(bullet), 1);
                }
            });
            
            // 충돌 체크
            checkCollisions();
            
            // 난이도 증가
            difficulty = 1 + ((60 - gameTime) / 5);
            
            // 도로 속도 증가 (난이도에 따라)
            roadSpeed = 0.5 + (difficulty * 0.05);
        }
        
        // 충돌 체크 함수 - 시각적 효과 추가
        function checkCollisions() {
            // 총알과 적의 충돌
            bullets.forEach(bullet => {
                enemies.forEach(enemy => {
                    const distance = bullet.position.distanceTo(enemy.position);
                    if (distance < 1) {
                        // 충돌 시 폭발 효과
                        createExplosion(enemy.position.clone());
                        
                        // 충돌 발생
                        scene.remove(bullet);
                        scene.remove(enemy);
                        bullets.splice(bullets.indexOf(bullet), 1);
                        enemies.splice(enemies.indexOf(enemy), 1);
                        
                        // 점수 추가
                        score += 10;
                        document.getElementById('score').textContent = score;
                    }
                });
            });
            
            // 플레이어(메인 아군)와 패널의 충돌
            if (allies.length > 0) {
                const player = allies[0];
                
                panels.forEach(panel => {
                    const distance = Math.sqrt(
                        Math.pow(player.position.x - panel.position.x, 2) +
                        Math.pow(player.position.z - panel.position.z, 2)
                    );
                    
                    if (distance < 2) {
                        // 패널과 충돌 - 사칙연산 수행
                        if (panel.userData.result !== undefined) {
                            // 패널 획득 효과
                            createPanelEffect(player.position.clone());
                            
                            createAllies(panel.userData.result);
                            
                            // 보너스 점수
                            score += 50;
                            document.getElementById('score').textContent = score;
                            
                            // 모든 패널 제거
                            panels.forEach(p => scene.remove(p));
                            panels = [];
                            
                            // 연산 초기화
                            document.getElementById('currentEquation').textContent = "없음";
                        }
                    }
                });
                
                // 플레이어와 적의 충돌
                enemies.forEach(enemy => {
                    const distance = player.position.distanceTo(enemy.position);
                    if (distance < 1.2) {
                        // 충돌 시 데미지 효과
                        createDamageEffect(player.position.clone());
                        
                        // 충돌 발생 - 아군 감소
                        if (allies.length > 1) {
                            createAllies(allies.length - 1);
                            
                            // 해당 적 제거
                            scene.remove(enemy);
                            enemies.splice(enemies.indexOf(enemy), 1);
                        } else {
                            // 마지막 아군이 적과 충돌하면 게임 오버
                            endGame();
                        }
                    }
                });
            }
        }
        
        // 폭발 효과 생성 함수
        function createExplosion(position) {
            // 폭발 파티클 그룹
            const explosionGroup = new THREE.Group();
            explosionGroup.position.copy(position);
            
            // 폭발 빛
            const explosionLight = new THREE.PointLight(0xff5500, 3, 8);
            explosionLight.position.set(0, 0, 0);
            explosionGroup.add(explosionLight);
            
            // 파티클 생성
            const particleCount = 10;
            const particles = [];
            
            for (let i = 0; i < particleCount; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const particleMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xff5500, 
                    transparent: true, 
                    opacity: 1
                });
                
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                
                // 랜덤 방향으로 튀어나감
                const angle1 = Math.random() * Math.PI * 2;
                const angle2 = Math.random() * Math.PI * 2;
                
                const speed = 0.1 + Math.random() * 0.2;
                particle.userData.velocity = new THREE.Vector3(
                    Math.sin(angle1) * Math.cos(angle2) * speed,
                    Math.sin(angle1) * Math.sin(angle2) * speed,
                    Math.cos(angle1) * speed
                );
                
                explosionGroup.add(particle);
                particles.push(particle);
            }
            
            scene.add(explosionGroup);
            
            // 0.5초 동안 폭발 애니메이션
            let elapsed = 0;
            const duration = 500; // 밀리초
            const interval = setInterval(() => {
                elapsed += 16;
                
                // 파티클 이동 및 페이드 아웃
                particles.forEach(particle => {
                    particle.position.add(particle.userData.velocity);
                    particle.material.opacity = 1 - (elapsed / duration);
                    particle.scale.multiplyScalar(0.98);
                });
                
                // 빛 감소
                explosionLight.intensity = 3 * (1 - elapsed / duration);
                
                if (elapsed >= duration) {
                    clearInterval(interval);
                    scene.remove(explosionGroup);
                }
            }, 16);
        }
        
        // 패널 획득 효과
        function createPanelEffect(position) {
            // 빛 생성
            const light = new THREE.PointLight(0x00ffff, 3, 10);
            light.position.copy(position);
            scene.add(light);
            
            // 0.5초 동안 빛 효과
            let elapsed = 0;
            const duration = 500; // 밀리초
            const interval = setInterval(() => {
                elapsed += 16;
                
                // 빛 강도 조절
                light.intensity = 3 * (1 - elapsed / duration);
                
                if (elapsed >= duration) {
                    clearInterval(interval);
                    scene.remove(light);
                }
            }, 16);
        }
        
        // 데미지 효과
        function createDamageEffect(position) {
            // 빨간 빛 생성
            const light = new THREE.PointLight(0xff0000, 3, 10);
            light.position.copy(position);
            scene.add(light);
            
            // 화면 빨갛게 깜빡임 (CSS 효과)
            const overlay = document.createElement('div');
            overlay.style.position = 'absolute';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.width = '100%';
            overlay.style.height = '100%';
            overlay.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
            overlay.style.pointerEvents = 'none';
            overlay.style.transition = 'opacity 0.5s';
            document.body.appendChild(overlay);
            
            // 0.5초 동안 효과
            setTimeout(() => {
                overlay.style.opacity = '0';
                setTimeout(() => {
                    document.body.removeChild(overlay);
                }, 500);
            }, 100);
            
            // 빛 효과 제거
            setTimeout(() => {
                scene.remove(light);
            }, 500);
        }
        
        // 게임 타이머 함수
        function startGameTimer() {
            const timerInterval = setInterval(() => {
                if (!gameActive) {
                    clearInterval(timerInterval);
                    return;
                }
                
                gameTime--;
                document.getElementById('timer').textContent = gameTime;
                
                if (gameTime <= 0) {
                    clearInterval(timerInterval);
                    endGame();
                }
            }, 1000);
        }
        
        // 게임 종료 함수
        function endGame() {
            gameActive = false;
            document.getElementById('gameOver').style.display = 'block';
            document.getElementById('finalScore').textContent = score;
            
            // 게임 오버 효과
            const gameOverLight = new THREE.AmbientLight(0xff0000, 0.3);
            scene.add(gameOverLight);
            
            // 모든 아군 회전 애니메이션
            const rotateAllies = () => {
                allies.forEach(ally => {
                    ally.rotation.y += 0.05;
                });
                
                if (gameActive) {
                    return;
                }
                
                requestAnimationFrame(rotateAllies);
            };
            
            rotateAllies();
        }
        
        // 게임 재시작 함수
        function restartGame() {
            // 기존 오브젝트 정리
            allies.forEach(ally => scene.remove(ally));
            enemies.forEach(enemy => scene.remove(enemy));
            bullets.forEach(bullet => scene.remove(bullet));
            panels.forEach(panel => scene.remove(panel));
            
            // 씬의 모든 빛 제거 (게임 오버 효과 제거)
            scene.children.forEach(child => {
                if (child instanceof THREE.Light && !(child instanceof THREE.DirectionalLight) && !(child instanceof THREE.AmbientLight && child.intensity === 0.6)) {
                    scene.remove(child);
                }
            });
            
            allies = [];
            enemies = [];
            bullets = [];
            panels = [];
            
            // 변수 초기화
            gameTime = 60;
            score = 0;
            difficulty = 1;
            gameActive = true;
            lastPanelTime = 0;
            lastEnemyWaveTime = 0;
            playerLane = 1; // 중앙 레인으로 초기화
            isMoving = false;
            roadSpeed = 0.5;
            gameDistance = 0;
            
            // UI 초기화
            document.getElementById('timer').textContent = gameTime;
            document.getElementById('score').textContent = score;
            document.getElementById('currentEquation').textContent = "없음";
            document.getElementById('gameOver').style.display = 'none';
            
            // 기본 조명 재설정
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(0, 20, 10);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // 첫 아군 생성
            createAllies(1);
            
            // 타이머 재시작
            startGameTimer();
        }
        
        // 애니메이션 루프
        function animate() {
            requestAnimationFrame(animate);
            
            if (gameActive) {
                updateGame();
            }
            
            renderer.render(scene, camera);
        }
        
        // 화면 크기 조정 이벤트
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // 게임 시작
        init();
    </script>
</body>
</html>
</antArtifact><antArtifact identifier="enhanced-game" type="application/vnd.ant.code" language="html" title="Enhanced Math Runner 3D Game">
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>러너 3D 슈팅 게임</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: Arial, sans-serif; 
            touch-action: none;
        }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            padding: 5px;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 1px 1px 1px black;
            z-index: 10;
        }
        #equationInfo {
            position: absolute;
            top: 40px;
            width: 100%;
            text-align: center;
            color: #ffcc00;
            padding: 5px;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 1px 1px 1px black;
            z-index: 10;
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none;
            z-index: 20;
        }
        #restartBtn {
            padding: 15px 30px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 18px;
            margin-top: 20px;
        }
        #restartBtn:hover {
            background-color: #45a049;
        }
        #controls {
            position: absolute;
            bottom: 30px;
            width: 100%;
            display: flex;
            justify-content: center;
            z-index: 10;
        }
        .controlBtn {
            width: 80px;
            height: 80px;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 40px;
            margin: 0 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
            user-select: none;
        }
    </style>
</head>
<body>
    <div id="info">아군: <span id="allyCount">1</span> | 시간: <span id="timer">60</span>초 | 점수: <span id="score">0</span></div>
    <div id="equationInfo">현재 패널: <span id="currentEquation">없음</span></div>
    <div id="gameOver">
        <h2>게임 종료!</h2>
        <p>최종 점수: <span id="finalScore">0</span></p>
        <button id="restartBtn">다시 시작</button>
    </div>
    <div id="controls">
        <div id="leftBtn" class="controlBtn">←</div>
        <div id="rightBtn" class="controlBtn">→</div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // 게임 변수
        let scene, camera, renderer, allies = [], enemies = [], bullets = [], panels = [];
        let gameTime = 60; // 1분
        let score = 0;
        let difficulty = 1;
        let gameActive = true;
        let lastPanelTime = 0;
        let lastEnemyWaveTime = 0;
        let lastFireTime = 0;
        let playerLane = 1; // 0: 왼쪽, 1: 중앙, 2: 오른쪽
        let isMoving = false;
        let roadSpeed = 0.5;
        let roadSegments = [];
        let gameDistance = 0;
        let activeEquation = "";
        
        // 레인 위치 정의
        const lanes = [-5, 0, 5];
        
        // 수학 연산자
        const operators = [
            { symbol: "+", fn: (a, b) => a + b, color: 0x00ffff },
            { symbol: "-", fn: (a, b) => Math.max(1, a - b), color: 0xff9999 }, // 최소 1명의 아군 보장
            { symbol: "×", fn: (a, b) => a * b, color: 0x99ccff },
            { symbol: "÷", fn: (a, b) => Math.round(a / b) || 1, color: 0xffcc99 } // 0이 되지 않도록 보장
        ];
        
        // 게임 초기화
        function init() {
            // 씬 설정
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e); // 어두운 남색 배경
            
            // 안개 추가 (원근감) - 더 짙게 설정
            scene.fog = new THREE.Fog(0x1a1a2e, 30, 80);
            
            // 카메라 설정
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 8, 12); // 카메라 높이와 거리 조정
            camera.lookAt(0, 0, -20);
            
            // 렌더러 설정
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; // 그림자 활성화
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);
            
            // 조명 설정
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(0, 20, 10);
            directionalLight.castShadow = true; // 그림자 생성
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -20;
            directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20;
            directionalLight.shadow.camera.bottom = -20;
            scene.add(directionalLight);
            
            // 도로 생성
            createRoad();
            
            // 첫 아군 생성
            createAllies(1);
            
            // 이벤트 리스너
            window.addEventListener('resize', onWindowResize);
            document.getElementById('restartBtn').addEventListener('click', restartGame);
            
            // 모바일 컨트롤 초기화
            initControls();
            
            // 게임 타이머 시작
            startGameTimer();
            
            // 게임 루프 시작
            animate();
        }
        
        // 도로 생성 함수
        function createRoad() {
            // 도로 텍스처 (하늘색 그라데이션 패턴으로 변경)
            const roadWidth = 15;
            const roadLength = 1000;
            const segmentLength = 20;
            const segments = roadLength / segmentLength;
            
            // 도로 기본 재질 (네온 효과가 있는 어두운 색상)
            const roadMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x0f3460,
                roughness: 0.5,
                metalness: 0.7,
                emissive: 0x0f3460,
                emissiveIntensity: 0.2
            });
            
            // 도로 경계선 재질 (밝은 네온 색상)
            const lineMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xE94560, 
                emissive: 0xE94560,
                emissiveIntensity: 0.7
            });
            
            // 도로 가장자리 재질 (네온 푸른색)
            const sideMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x16213E,
                emissive: 0x0F52BA,
                emissiveIntensity: 0.3
            });
            
            // 도로 그라데이션을 위한 재질 배열 (네온 효과가 있는 패턴)
            const patternMaterials = [
                new THREE.MeshStandardMaterial({ 
                    color: 0x0f3460, 
                    emissive: 0x0f3460,
                    emissiveIntensity: 0.2
                }),
                new THREE.MeshStandardMaterial({ 
                    color: 0x16213E, 
                    emissive: 0x16213E,
                    emissiveIntensity: 0.2
                })
            ];
            
            // 여러 세그먼트로 도로 생성
            for (let i = 0; i < segments; i++) {
                // 도로 세그먼트 (패턴 적용)
                const roadGeometry = new THREE.PlaneGeometry(roadWidth, segmentLength);
                const road = new THREE.Mesh(roadGeometry, patternMaterials[i % 2]); // 번갈아가며 패턴 적용
                road.rotation.x = -Math.PI / 2;
                road.position.z = -i * segmentLength - segmentLength / 2;
                road.position.y = -0.1;
                road.receiveShadow = true; // 그림자 받기
                scene.add(road);
                roadSegments.push(road);
                
                // 도로 레인 구분선
                for (let j = -1; j <= 1; j += 2) {
                    const lineGeometry = new THREE.PlaneGeometry(0.3, segmentLength);
                    const line = new THREE.Mesh(lineGeometry, lineMaterial);
                    line.rotation.x = -Math.PI / 2;
                    line.position.set(j * roadWidth/6, -0.05, -i * segmentLength - segmentLength / 2);
                    line.receiveShadow = true;
                    scene.add(line);
                    roadSegments.push(line);
                }
                
                // 도로 가장자리
                for (let j = -1; j <= 1; j += 2) {
                    const sideGeometry = new THREE.BoxGeometry(2, 1, segmentLength);
                    const side = new THREE.Mesh(sideGeometry, sideMaterial);
                    side.position.set(j * (roadWidth/2 + 1), 0.4, -i * segmentLength - segmentLength / 2);
                    side.castShadow = true;
                    side.receiveShadow = true;
                    scene.add(side);
                    roadSegments.push(side);
                    
                    // 가드레일 기둥 추가
                    if (i % 2 === 0) {
                        const postGeometry = new THREE.BoxGeometry(0.5, 2, 0.5);
                        const postMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
                        const post = new THREE.Mesh(postGeometry, postMaterial);
                        post.position.set(j * (roadWidth/2 + 1), 1.5, -i * segmentLength - segmentLength / 2);
                        post.castShadow = true;
                        post.receiveShadow = true;
                        scene.add(post);
                        roadSegments.push(post);
                    }
                }
            }
        }
        
        // 도로 스크롤 함수
        function scrollRoad() {
            const resetPos = -1000; // 도로 총 길이
            
            roadSegments.forEach(segment => {
                segment.position.z += roadSpeed;
                
                // 도로 세그먼트가 카메라 뒤로 지나가면 다시 앞으로 재배치
                if (segment.position.z > 20) {
                    segment.position.z = resetPos + (segment.position.z - 20);
                }
            });
            
            // 거리 증가
            gameDistance += roadSpeed;
        }
        
        // 컨트롤 초기화
        function initControls() {
            const leftBtn = document.getElementById('leftBtn');
            const rightBtn = document.getElementById('rightBtn');
            
            // 터치 이벤트
            leftBtn.addEventListener('touchstart', moveLeft);
            rightBtn.addEventListener('touchstart', moveRight);
            
            // 마우스 이벤트 (데스크톱용)
            leftBtn.addEventListener('mousedown', moveLeft);
            rightBtn.addEventListener('mousedown', moveRight);
            
            // 키보드 이벤트
            window.addEventListener('keydown', function(e) {
                if (!gameActive || isMoving) return;
                
                if (e.key === 'ArrowLeft') {
                    moveLeft();
                } else if (e.key === 'ArrowRight') {
                    moveRight();
                }
            });
            
            function moveLeft() {
                if (!gameActive || isMoving || playerLane === 0) return;
                
                isMoving = true;
                playerLane--;
                moveAlliesTo(lanes[playerLane]);
            }
            
            function moveRight() {
                if (!gameActive || isMoving || playerLane === 2) return;
                
                isMoving = true;
                playerLane++;
                moveAlliesTo(lanes[playerLane]);
            }
        }
        
        // 아군 이동 함수
        function moveAlliesTo(targetX) {
            // 0.3초에 걸쳐 부드럽게 이동
            const frames = 15; // 60fps 기준 0.25초
            let currentFrame = 0;
            
            // 메인 아군 현재 위치
            const startX = allies[0].position.x;
            const moveAmount = (targetX - startX) / frames;
            
            const moveInterval = setInterval(() => {
                if (currentFrame >= frames) {
                    clearInterval(moveInterval);
                    isMoving = false;
                    return;
                }
                
                // 모든 아군 이동
                allies.forEach((ally, index) => {
                    if (index === 0) {
                        // 메인 아군
                        ally.position.x += moveAmount;
                    } else {
                        // 나머지 아군들은 메인 아군을 따라감
                        updateAllyFormation();
                    }
                });
                
                currentFrame++;
            }, 1000/60); // 60fps
        }
        
        // 아군 진형 업데이트
        function updateAllyFormation() {
            if (allies.length <= 1) return;
            
            const mainAlly = allies[0];
            const allyCount = allies.length;
            
            // 진영 크기 계산 - 아군이 많을수록 더 넓게 퍼짐
            const formationWidth = Math.min(3, 0.5 + (allyCount * 0.1));
            const formationDepth = Math.min(4, 1 + (allyCount * 0.15));
            
            for (let i = 1; i < allyCount; i++) {
                // 균등하게 분포된 위치 계산
                let row = Math.floor((i-1) / 3);
                let col = (i-1) % 3;
                
                // 중앙 정렬을 위한 오프셋
                let colOffset = col - 1; // -1, 0, 1
                let rowOffset = -row; // 항상 플레이어 뒤에 배치
                
                allies[i].position.x = mainAlly.position.x + (colOffset * formationWidth);
                allies[i].position.z = mainAlly.position.z + (rowOffset * formationDepth);
            }
        }
        
        // 아군 생성 함수 - 캐릭터 디자인 개선
        function createAllies(count) {
            // 기존 아군 제거
            allies.forEach(ally => scene.remove(ally));
            allies = [];
            
            // 최댓값 제한 (너무 많으면 게임이 쉬워짐)
            count = Math.min(count, 30);
            
            // 새 아군 생성 - 귀여운 오렌지색 캐릭터로 변경
            for (let i = 0; i < count; i++) {
                // 캐릭터 그룹
                const character = new THREE.Group();
                
                // 몸체 (구)
                const bodyGeometry = new THREE.SphereGeometry(0.5, 16, 16);
                const bodyMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFF9900, // 오렌지색
                    emissive: 0xAA5500,
                    emissiveIntensity: 0.2,
                    roughness: 0.7
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.castShadow = true;
                body.receiveShadow = true;
                character.add(body);
                
                // 캐릭터에 눈 추가
                const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
                
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(0.2, 0.2, 0.4);
                character.add(leftEye);
                
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(-0.2, 0.2, 0.4);
                character.add(rightEye);
                
                // 눈동자
                const pupilGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                const pupilMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
                
                const leftPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                leftPupil.position.set(0.2, 0.2, 0.45);
                character.add(leftPupil);
                
                const rightPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                rightPupil.position.set(-0.2, 0.2, 0.45);
                character.add(rightPupil);
                
                // 팔과 다리 추가 (메인 캐릭터만)
                if (i === 0) {
                    // 팔
                    const armGeometry = new THREE.SphereGeometry(0.15, 8, 8);
                    
                    const leftArm = new THREE.Mesh(armGeometry, bodyMaterial);
                    leftArm.position.set(0.6, 0, 0);
                    leftArm.castShadow = true;
                    character.add(leftArm);
                    
                    const rightArm = new THREE.Mesh(armGeometry, bodyMaterial);
                    rightArm.position.set(-0.6, 0, 0);
                    rightArm.castShadow = true;
                    character.add(rightArm);
                    
                    // 다리
                    const legGeometry = new THREE.CylinderGeometry(0.15, 0.1, 0.5, 8);
                    
                    const leftLeg = new THREE.Mesh(legGeometry, bodyMaterial);
                    leftLeg.position.set(0.2, -0.5, 0);
                    leftLeg.castShadow = true;
                    character.add(leftLeg);
                    
                    const rightLeg = new THREE.Mesh(legGeometry, bodyMaterial);
                    rightLeg.position.set(-0.2, -0.5, 0);
                    rightLeg.castShadow = true;
                    character.add(rightLeg);
                }
                
                if (i === 0) {
                    // 메인 아군 (플레이어)
                    character.position.set(lanes[playerLane], 0.5, 0);
                } else {
                    // 추가 아군들은 초기 위치만 설정 (updateAllyFormation에서 정확히 배치됨)
                    character.position.set(lanes[playerLane], 0.5, -i);
                    // 작게 만들기
                    character.scale.set(0.8, 0.8, 0.8);
                }
                
                scene.add(character);
                allies.push(character);
            }
            
            // 진형 업데이트
            updateAllyFormation();
            
            // UI 업데이트
            document.getElementById('allyCount').textContent = allies.length;
        }
        
        // 적 생성 함수 - 웨이브 형태로 생성
        function createEnemyWave() {
            const waveType = Math.floor(Math.random() * 4);
            
            switch (waveType) {
                case 0: // 일렬 웨이브
                    const randomLane = Math.floor(Math.random() * 3);
                    for (let i = 0; i < 5 + Math.floor(difficulty); i++) {
                        createEnemy(randomLane, -80 - (i * 4));
                    }
                    break;
                    
                case 1: // V 형태 웨이브
                    for (let i = 0; i < 7; i++) {
                        const laneOffset = (i <= 3) ? i : 6 - i; // 0,1,2,3,2,1,0
                        createEnemy(laneOffset, -80 - (i * 3));
                    }
                    break;
                    
                case 2: // 모든 레인 웨이브
                    for (let i = 0; i < 3; i++) {
                        for (let j = 0; j < 3; j++) {
                            createEnemy(j, -80 - (i * 5));
                        }
                    }
                    break;
                    
                case 3: // 랜덤 웨이브
                    const enemyCount = 5 + Math.floor(difficulty * 2);
                    for (let i = 0; i < enemyCount; i++) {
                        const randLane = Math.floor(Math.random() * 3);
                        const randDist = -80 - (Math.random() * 20);
                        createEnemy(randLane, randDist);
                    }
                    break;
            }
            
            function createEnemy(lane, zPos) {
                // 적 그룹
                const enemy = new THREE.Group();
                
                // 적 몸체 (기본 모양)
                const enemyGeometry = new THREE.SphereGeometry(0.5, 16, 16);
                const enemyMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xff0000,
                    emissive: 0xaa0000,
                    emissiveIntensity: 0.3,
                    roughness: 0.6
                });
                const body = new THREE.Mesh(enemyGeometry, enemyMaterial);
                body.castShadow = true;
                body.receiveShadow = true;
                enemy.add(body);
                
                // 적 눈 (흰색)
                const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
                
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(0.2, 0.2, 0.4);
                enemy.add(leftEye);
                
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(-0.2, 0.2, 0.4);
                enemy.add(rightEye);
                
                // 적 눈동자 (검은색)
                const pupilGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                const pupilMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
                
                const leftPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                leftPupil.position.set(0.2, 0.2, 0.45);
                enemy.add(leftPupil);
                
                const rightPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                rightPupil.position.set(-0.2, 0.2, 0.45);
                enemy.add(rightPupil);
                
                enemy.position.set(lanes[lane], 0.5, zPos);
                scene.add(enemy);
                enemies.push(enemy);
            }
        }
        
        // 총알 발사 함수
        function fireBullets() {
            const currentTime = Date.now();
            
            // 자동 발사 간격 (아군 수에 따라 감소)
            const fireInterval = Math.max(100, 500 - (allies.length * 10));
            
            if (currentTime - lastFireTime < fireInterval) return;
            
            lastFireTime = currentTime;
            
            // 아군 수에 비례해서 총알 발사 (아군당 0.5발의 총알)
            const bulletsToFire = Math.max(1, Math.ceil(allies.length * 0.5));
            
            for (let i = 0; i < bulletsToFire; i++) {
                const bulletGeometry = new THREE.SphereGeometry(0.2, 8, 8);
                const bulletMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xffff00, 
                    emissive: 0xffff00,
                    emissiveIntensity: 0.8
                });
                const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
                
                // 총알 발사 방향 다각화
                let angleOffset = 0;
                if (bulletsToFire > 1) {
                    // 부채꼴 형태로 퍼지게 발사
                    const spreadFactor = Math.min(0.3, bulletsToFire * 0.02);  // 최대 0.3 라디안 (약 17도)
                    angleOffset = spreadFactor * ((i / (bulletsToFire - 1)) * 2 - 1);
                }
                
                // 총알 위치는 무작위 아군 위치에서 시작
                const shooterIndex = Math.floor(Math.random() * allies.length);
                bullet.position.copy(allies[shooterIndex].position);
                bullet.position.z -= 1; // 약간 앞에서 발사
                
                // 총알 방향 설정
                bullet.userData.direction = new THREE.Vector3(angleOffset, 0, -1).normalize();
                bullet.userData.speed = 1.5;
                
                scene.add(bullet);
                bullets.push(bullet);
                
                // 총알 발사 이펙트 (빛)
                const bulletLight = new THREE.PointLight(0xffff00, 2, 5);
                bulletLight.position.copy(bullet.position);
                scene.add(bulletLight);
                
                // 0.1초 후 이펙트 제거
                setTimeout(() => {
                    scene.remove(bulletLight);
                }, 100);
            }
        }
        
        // 사칙연산 패널 생성 함수
        function createMathPanels() {
            // 기존 패널 제거
            panels.forEach(panel => scene.remove(panel));
            panels = [];
            
            // 랜덤 연산자 선택
            const operator = operators[Math.floor(Math.random() * operators.length)];
            
            // 피연산자 선택 (난이도에 따라 증가)
            const operand = Math.floor(Math.random() * Math.min(5, difficulty)) + 1;
            
            // 현재 아군 수와 연산 결과 계산
            const currentAllies = allies.length;
            const result = operator.fn(currentAllies, operand);
            
            // 연산 표시 업데이트
            activeEquation = `${currentAllies} ${operator.symbol} ${operand} = ${result}`;
            document.getElementById('currentEquation').textContent = activeEquation;
            
            // 도로 세 레인에 패널 생성
            for (let i = 0; i < 3; i++) {
                createMathPanel(lanes[i], -60 - Math.random() * 10, operand, operator);
            }
            
            function createMathPanel(x, z, operand, operator) {
                // 패널 그룹
                const panel = new THREE.Group();
                
                // 패널 플랫폼
                const panelGeometry = new THREE.BoxGeometry(3, 0.3, 3);
                
                // 연산자에 맞는 색상 적용
                const panelMaterial = new THREE.MeshStandardMaterial({ 
                    color: operator.color,
                    emissive: operator.color,
                    emissiveIntensity: 0.3,
                    transparent: true,
                    opacity: 0.85
                });
                
                const panelMesh = new THREE.Mesh(panelGeometry, panelMaterial);
                panelMesh.castShadow = true;
                panelMesh.receiveShadow = true;
                panel.add(panelMesh);
                
                // 패널에 숫자 표시를 위한 텍스트 (Three.js에서는 실제 텍스트 렌더링이 어려워 대체 표현)
                const operatorSymbol = operator.symbol;
                const operatorTextGeometry = new THREE.BoxGeometry(1, 0.1, 1);
                const operatorTextMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFFFFFF,
                    emissive: 0xFFFFFF,
                    emissiveIntensity: 0.5
                });
                
                const operatorText = new THREE.Mesh(operatorTextGeometry, operatorTextMaterial);
                operatorText.position.y = 0.2;
                panel.add(operatorText);
                
                // 숫자 표시 (간소화된 형태)
                const numberGeometry = new THREE.BoxGeometry(0.5, 0.1, 0.5);
                const numberMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
                const numberMesh = new THREE.Mesh(numberGeometry, numberMaterial);
                numberMesh.position.set(0, 0.2, 0.5);
                panel.add(numberMesh);
                
                // 패널 위치 설정
                panel.position.set(x, 0, z);
                
                // 패널에 연산 데이터 추가
                panel.userData = {
                    operator: operatorSymbol,
                    operand: operand,
                    result: result
                };
                
                // 패널 발광 효과
                const panelLight = new THREE.PointLight(operator.color, 1, 5);
                panelLight.position.set(0, 0.5, 0);
                panel.add(panelLight);
                
                scene.add(panel);
                panels.push(panel);
            }
        }
        
        // 게임 업데이트 함수
        function updateGame() {
            const currentTime = Date.now();
            
            // 도로 스크롤
            scrollRoad();
            
            // 3초마다 패널 생성
            if (currentTime - lastPanelTime > 3000) {
                createMathPanels();
                lastPanelTime = currentTime;
            }
            
            // 난이도에 따라 적 웨이브 생성 주기 조절
            const enemyWaveInterval = Math.max(2000, 5000 - (difficulty * 300));
            if (currentTime - lastEnemyWaveTime > enemyWaveInterval) {
                createEnemyWave();
                lastEnemyWaveTime = currentTime;
            }
            
            // 자동 총알 발사
            fireBullets();
            
            // 패널 이동 (도로와 함께 이동)
            panels.forEach(panel => {
                panel.position.z += roadSpeed;
                
                // 화면 끝에 도달한 패널은 제거
                if (panel.position.z > 10) {
                    scene.remove(panel);
                    panels.splice(panels.indexOf(panel), 1);
                    
                    // 모든 패널이 사라졌을 때 현재 연산 초기화
                    if (panels.length === 0) {
                        document.getElementById('currentEquation').textContent = "없음";
                    }
                }
            });
            
            // 적 이동 (도로와 함께 이동, 약간 더 빠르게)
            enemies.forEach(enemy => {
                enemy.position.z += roadSpeed * 1.2;
                
                // 화면 끝에 도달한 적은 제거
                if (enemy.position.z > 10) {
                    scene.remove(enemy);
                    enemies.splice(enemies.indexOf(enemy), 1);
                }
                
                // 적 애니메이션 (약간 상하로 움직임)
                enemy.position.y = 0.5 + Math.sin(currentTime / 300 + enemy.position.z) * 0.1;
                
                // 추가: 적 회전 애니메이션
                enemy.rotation.y += 0.02;
            });
            
            // 아군 애니메이션 (약간 위아래로 움직임)
            allies.forEach((ally, index) => {
                // 메인 캐릭터 (0번 인덱스)만 특별한 애니메이션 적용
                if (index === 0) {
                    ally.position.y = 0.5 + Math.sin(currentTime / 500) * 0.05;
                    
                    // 달리기 애니메이션 효과 (앞뒤로 약간 기울임)
                    ally.rotation.x = Math.sin(currentTime / 200) * 0.1;
                } else {
                    // 다른 아군들은 약간 다른 주기로 움직여 자연스러움 증가
                    ally.position.y = 0.5 + Math.sin((currentTime / 500) + index * 0.5) * 0.05;
                }
            });
            
            // 총알 이동
            bullets.forEach(bullet => {
                const direction = bullet.userData.direction;
                bullet.position.x += direction.x * bullet.userData.speed;
                bullet.position.z += direction.z * bullet.userData.speed;
                
                // 총알 회전 효과 추가
                bullet.rotation.x += 0.2;
                bullet.rotation.y += 0.2;
                
                // 화면 밖으로 나간 총알 제거
                if (bullet.position.z < -100) {
                    scene.remove(bullet);
                    bullets.splice(bullets.indexOf(bullet), 1);
                }
            });
            
            // 충돌 체크
            checkCollisions();
            
            // 난이도 증가
            difficulty = 1 + ((60 - gameTime) / 5);
            
            // 도로 속도 증가 (난이도에 따라)
            roadSpeed = 0.5 + (difficulty * 0.05);
        }
        
        // 충돌 체크 함수 - 시각적 효과 추가
        function checkCollisions() {
            // 총알과 적의 충돌
            bullets.forEach(bullet => {
                enemies.forEach(enemy => {
                    const distance = bullet.position.distanceTo(enemy.position);
                    if (distance < 1) {
                        // 충돌 시 폭발 효과
                        createExplosion(enemy.position.clone());
                        
                        // 충돌 발생
                        scene.remove(bullet);
                        scene.remove(enemy);
                        bullets.splice(bullets.indexOf(bullet), 1);
                        enemies.splice(enemies.indexOf(enemy), 1);
                        
                        // 점수 추가
                        score += 10;
                        document.getElementById('score').textContent = score;
                    }
                });
            });
            
            // 플레이어(메인 아군)와 패널의 충돌
            if (allies.length > 0) {
                const player = allies[0];
                
                panels.forEach(panel => {
                    const distance = Math.sqrt(
                        Math.pow(player.position.x - panel.position.x, 2) +
                        Math.pow(player.position.z - panel.position.z, 2)
                    );
                    
                    if (distance < 2) {
                        // 패널과 충돌 - 사칙연산 수행
                        if (panel.userData.result !== undefined) {
                            // 패널 획득 효과
                            createPanelEffect(player.position.clone());
                            
                            createAllies(panel.userData.result);
                            
                            // 보너스 점수
                            score += 50;
                            document.getElementById('score').textContent = score;
                            
                            // 모든 패널 제거
                            panels.forEach(p => scene.remove(p));
                            panels = [];
                            
                            // 연산 초기화
                            document.getElementById('currentEquation').textContent = "없음";
                        }
                    }
                });
                
                // 플레이어와 적의 충돌
                enemies.forEach(enemy => {
                    const distance = player.position.distanceTo(enemy.position);
                    if (distance < 1.2) {
                        // 충돌 시 데미지 효과
                        createDamageEffect(player.position.clone());
                        
                        // 충돌 발생 - 아군 감소
                        if (allies.length > 1) {
                            createAllies(allies.length - 1);
                            
                            // 해당 적 제거
                            scene.remove(enemy);
                            enemies.splice(enemies.indexOf(enemy), 1);
                        } else {
                            // 마지막 아군이 적과 충돌하면 게임 오버
                            endGame();
                        }
                    }
                });
            }
        }
        
        // 폭발 효과 생성 함수
        function createExplosion(position) {
            // 폭발 파티클 그룹
            const explosionGroup = new THREE.Group();
            explosionGroup.position.copy(position);
            
            // 폭발 빛
            const explosionLight = new THREE.PointLight(0xff5500, 3, 8);
            explosionLight.position.set(0, 0, 0);
            explosionGroup.add(explosionLight);
            
            // 파티클 생성
            const particleCount = 10;
            const particles = [];
            
            for (let i = 0; i < particleCount; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const particleMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xff5500, 
                    transparent: true, 
                    opacity: 1
                });
                
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                
                // 랜덤 방향으로 튀어나감
                const angle1 = Math.random() * Math.PI * 2;
                const angle2 = Math.random() * Math.PI * 2;
                
                const speed = 0.1 + Math.random() * 0.2;
                particle.userData.velocity = new THREE.Vector3(
                    Math.sin(angle1) * Math.cos(angle2) * speed,
                    Math.sin(angle1) * Math.sin(angle2) * speed,
                    Math.cos(angle1) * speed
                );
                
                explosionGroup.add(particle);
                particles.push(particle);
            }
            
            scene.add(explosionGroup);
            
            // 0.5초 동안 폭발 애니메이션
            let elapsed = 0;
            const duration = 500; // 밀리초
            const interval = setInterval(() => {
                elapsed += 16;
                
                // 파티클 이동 및 페이드 아웃
                particles.forEach(particle => {
                    particle.position.add(particle.userData.velocity);
                    particle.material.opacity = 1 - (elapsed / duration);
                    particle.scale.multiplyScalar(0.98);
                });
                
                // 빛 감소
                explosionLight.intensity = 3 * (1 - elapsed / duration);
                
                if (elapsed >= duration) {
                    clearInterval(interval);
                    scene.remove(explosionGroup);
                }
            }, 16);
        }
        
        // 패널 획득 효과
        function createPanelEffect(position) {
            // 빛 생성
            const light = new THREE.PointLight(0x00ffff, 3, 10);
            light.position.copy(position);
            scene.add(light);
            
            // 0.5초 동안 빛 효과
            let elapsed = 0;
            const duration = 500; // 밀리초
            const interval = setInterval(() => {
                elapsed += 16;
                
                // 빛 강도 조절
                light.intensity = 3 * (1 - elapsed / duration);
                
                if (elapsed >= duration) {
                    clearInterval(interval);
                    scene.remove(light);
                }
            }, 16);
        }
        
        // 데미지 효과
        function createDamageEffect(position) {
            // 빨간 빛 생성
            const light = new THREE.PointLight(0xff0000, 3, 10);
            light.position.copy(position);
            scene.add(light);
            
            // 화면 빨갛게 깜빡임 (CSS 효과)
            const overlay = document.createElement('div');
            overlay.style.position = 'absolute';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.width = '100%';
            overlay.style.height = '100%';
            overlay.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
            overlay.style.pointerEvents = 'none';
            overlay.style.transition = 'opacity 0.5s';
            document.body.appendChild(overlay);
            
            // 0.5초 동안 효과
            setTimeout(() => {
                overlay.style.opacity = '0';
                setTimeout(() => {
                    document.body.removeChild(overlay);
                }, 500);
            }, 100);
            
            // 빛 효과 제거
            setTimeout(() => {
                scene.remove(light);
            }, 500);
        }
        
        // 게임 타이머 함수
        function startGameTimer() {
            const timerInterval = setInterval(() => {
                if (!gameActive) {
                    clearInterval(timerInterval);
                    return;
                }
                
                gameTime--;
                document.getElementById('timer').textContent = gameTime;
                
                if (gameTime <= 0) {
                    clearInterval(timerInterval);
                    endGame();
                }
            }, 1000);
        }
        
        // 게임 종료 함수
        function endGame() {
            gameActive = false;
            document.getElementById('gameOver').style.display = 'block';
            document.getElementById('finalScore').textContent = score;
            
            // 게임 오버 효과
            const gameOverLight = new THREE.AmbientLight(0xff0000, 0.3);
            scene.add(gameOverLight);
            
            // 모든 아군 회전 애니메이션
            const rotateAllies = () => {
                allies.forEach(ally => {
                    ally.rotation.y += 0.05;
                });
                
                if (gameActive) {
                    return;
                }
                
                requestAnimationFrame(rotateAllies);
            };
            
            rotateAllies();
        }
        
        // 게임 재시작 함수
        function restartGame() {
            // 기존 오브젝트 정리
            allies.forEach(ally => scene.remove(ally));
            enemies.forEach(enemy => scene.remove(enemy));
            bullets.forEach(bullet => scene.remove(bullet));
            panels.forEach(panel => scene.remove(panel));
            
            // 씬의 모든 빛 제거 (게임 오버 효과 제거)
            scene.children.forEach(child => {
                if (child instanceof THREE.Light && !(child instanceof THREE.DirectionalLight) && !(child instanceof THREE.AmbientLight && child.intensity === 0.6)) {
                    scene.remove(child);
                }
            });
            
            allies = [];
            enemies = [];
            bullets = [];
            panels = [];
            
            // 변수 초기화
            gameTime = 60;
            score = 0;
            difficulty = 1;
            gameActive = true;
            lastPanelTime = 0;
            lastEnemyWaveTime = 0;
            playerLane = 1; // 중앙 레인으로 초기화
            isMoving = false;
            roadSpeed = 0.5;
            gameDistance = 0;
            
            // UI 초기화
            document.getElementById('timer').textContent = gameTime;
            document.getElementById('score').textContent = score;
            document.getElementById('currentEquation').textContent = "없음";
            document.getElementById('gameOver').style.display = 'none';
            
            // 기본 조명 재설정
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(0, 20, 10);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // 첫 아군 생성
            createAllies(1);
            
            // 타이머 재시작
            startGameTimer();
        }
        
        // 애니메이션 루프
        function animate() {
            requestAnimationFrame(animate);
            
            if (gameActive) {
                updateGame();
            }
            
            renderer.render(scene, camera);
        }
        
        // 화면 크기 조정 이벤트
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // 게임 시작
        init();
    </script>
</body>
</html>
</antArtifact><antArtifact identifier="enhanced-game" type="application/vnd.ant.code" language="html" title="Enhanced Math Runner 3D Game">
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>러너 3D 슈팅 게임</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: Arial, sans-serif; 
            touch-action: none;
        }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            padding: 5px;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 1px 1px 1px black;
            z-index: 10;
        }
        #equationInfo {
            position: absolute;
            top: 40px;
            width: 100%;
            text-align: center;
            color: #ffcc00;
            padding: 5px;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 1px 1px 1px black;
            z-index: 10;
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none;
            z-index: 20;
        }
        #restartBtn {
            padding: 15px 30px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 18px;
            margin-top: 20px;
        }
        #restartBtn:hover {
            background-color: #45a049;
        }
        #controls {
            position: absolute;
            bottom: 30px;
            width: 100%;
            display: flex;
            justify-content: center;
            z-index: 10;
        }
        .controlBtn {
            width: 80px;
            height: 80px;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 40px;
            margin: 0 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
            user-select: none;
        }
    </style>
</head>
<body>
    <div id="info">아군: <span id="allyCount">1</span> | 시간: <span id="timer">60</span>초 | 점수: <span id="score">0</span></div>
    <div id="equationInfo">현재 패널: <span id="currentEquation">없음</span></div>
    <div id="gameOver">
        <h2>게임 종료!</h2>
        <p>최종 점수: <span id="finalScore">0</span></p>
        <button id="restartBtn">다시 시작</button>
    </div>
    <div id="controls">
        <div id="leftBtn" class="controlBtn">←</div>
        <div id="rightBtn" class="controlBtn">→</div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // 게임 변수
        let scene, camera, renderer, allies = [], enemies = [], bullets = [], panels = [];
        let gameTime = 60; // 1분
        let score = 0;
        let difficulty = 1;
        let gameActive = true;
        let lastPanelTime = 0;
        let lastEnemyWaveTime = 0;
        let lastFireTime = 0;
        let playerLane = 1; // 0: 왼쪽, 1: 중앙, 2: 오른쪽
        let isMoving = false;
        let roadSpeed = 0.5;
        let roadSegments = [];
        let gameDistance = 0;
        let activeEquation = "";
        
        // 레인 위치 정의
        const lanes = [-5, 0, 5];
        
        // 수학 연산자 (각각 강한 네온 색상으로 변경)
        const operators = [
            { symbol: "+", fn: (a, b) => a + b, color: 0x00FFFF, glow: 0x00FFFF }, // 네온 청록색
            { symbol: "-", fn: (a, b) => Math.max(1, a - b), color: 0xFF1493, glow: 0xFF1493 }, // 네온 핑크
            { symbol: "×", fn: (a, b) => a * b, color: 0x39FF14, glow: 0x39FF14 }, // 네온 그린
            { symbol: "÷", fn: (a, b) => Math.round(a / b) || 1, color: 0xFFD700, glow: 0xFFD700 } // 네온 골드
        ];
        
        // 게임 초기화
        function init() {
            // 씬 설정
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e); // 어두운 남색 배경
            
            // 안개 추가 (원근감) - 더 짙게 설정
            scene.fog = new THREE.Fog(0x1a1a2e, 30, 80);
            
            // 카메라 설정
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 8, 12); // 카메라 높이와 거리 조정
            camera.lookAt(0, 0, -20);
            
            // 렌더러 설정
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; // 그림자 활성화
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);
            
            // 조명 설정
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(0, 20, 10);
            directionalLight.castShadow = true; // 그림자 생성
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -20;
            directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20;
            directionalLight.shadow.camera.bottom = -20;
            scene.add(directionalLight);
            
            // 도로 생성
            createRoad();
            
            // 첫 아군 생성
            createAllies(1);
            
            // 이벤트 리스너
            window.addEventListener('resize', onWindowResize);
            document.getElementById('restartBtn').addEventListener('click', restartGame);
            
            // 모바일 컨트롤 초기화
            initControls();
            
            // 게임 타이머 시작
            startGameTimer();
            
            // 게임 루프 시작
            animate();
        }
        
        // 도로 생성 함수
        function createRoad() {
            // 도로 텍스처 (하늘색 그라데이션 패턴으로 변경)
            const roadWidth = 15;
            const roadLength = 1000;
            const segmentLength = 20;
            const segments = roadLength / segmentLength;
            
            // 도로 기본 재질 (네온 효과가 있는 어두운 색상)
            const roadMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x0f3460,
                roughness: 0.5,
                metalness: 0.7,
                emissive: 0x0f3460,
                emissiveIntensity: 0.2
            });
            
            // 도로 경계선 재질 (밝은 네온 색상)
            const lineMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xE94560, 
                emissive: 0xE94560,
                emissiveIntensity: 0.7
            });
            
            // 도로 가장자리 재질 (네온 푸른색)
            const sideMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x16213E,
                emissive: 0x0F52BA,
                emissiveIntensity: 0.3
            });
            
            // 도로 그라데이션을 위한 재질 배열 (네온 효과가 있는 패턴)
            const patternMaterials = [
                new THREE.MeshStandardMaterial({ 
                    color: 0x0f3460, 
                    emissive: 0x0f3460,
                    emissiveIntensity: 0.2
                }),
                new THREE.MeshStandardMaterial({ 
                    color: 0x16213E, 
                    emissive: 0x16213E,
                    emissiveIntensity: 0.2
                })
            ];
            
            // 여러 세그먼트로 도로 생성
            for (let i = 0; i < segments; i++) {
                // 도로 세그먼트 (패턴 적용)
                const roadGeometry = new THREE.PlaneGeometry(roadWidth, segmentLength);
                const road = new THREE.Mesh(roadGeometry, patternMaterials[i % 2]); // 번갈아가며 패턴 적용
                road.rotation.x = -Math.PI / 2;
                road.position.z = -i * segmentLength - segmentLength / 2;
                road.position.y = -0.1;
                road.receiveShadow = true; // 그림자 받기
                scene.add(road);
                roadSegments.push(road);
                
                // 도로 레인 구분선
                for (let j = -1; j <= 1; j += 2) {
                    const lineGeometry = new THREE.PlaneGeometry(0.3, segmentLength);
                    const line = new THREE.Mesh(lineGeometry, lineMaterial);
                    line.rotation.x = -Math.PI / 2;
                    line.position.set(j * roadWidth/6, -0.05, -i * segmentLength - segmentLength / 2);
                    line.receiveShadow = true;
                    scene.add(line);
                    roadSegments.push(line);
                }
                
                // 도로 가장자리
                for (let j = -1; j <= 1; j += 2) {
                    const sideGeometry = new THREE.BoxGeometry(2, 1, segmentLength);
                    const side = new THREE.Mesh(sideGeometry, sideMaterial);
                    side.position.set(j * (roadWidth/2 + 1), 0.4, -i * segmentLength - segmentLength / 2);
                    side.castShadow = true;
                    side.receiveShadow = true;
                    scene.add(side);
                    roadSegments.push(side);
                    
                    // 가드레일 기둥 추가
                    if (i % 2 === 0) {
                        const postGeometry = new THREE.BoxGeometry(0.5, 2, 0.5);
                        const postMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
                        const post = new THREE.Mesh(postGeometry, postMaterial);
                        post.position.set(j * (roadWidth/2 + 1), 1.5, -i * segmentLength - segmentLength / 2);
                        post.castShadow = true;
                        post.receiveShadow = true;
                        scene.add(post);
                        roadSegments.push(post);
                    }
                }
            }
        }
        
        // 도로 스크롤 함수
        function scrollRoad() {
            const resetPos = -1000; // 도로 총 길이
            
            roadSegments.forEach(segment => {
                segment.position.z += roadSpeed;
                
                // 도로 세그먼트가 카메라 뒤로 지나가면 다시 앞으로 재배치
                if (segment.position.z > 20) {
                    segment.position.z = resetPos + (segment.position.z - 20);
                }
            });
            
            // 거리 증가
            gameDistance += roadSpeed;
        }
        
        // 컨트롤 초기화
        function initControls() {
            const leftBtn = document.getElementById('leftBtn');
            const rightBtn = document.getElementById('rightBtn');
            
            // 터치 이벤트
            leftBtn.addEventListener('touchstart', moveLeft);
            rightBtn.addEventListener('touchstart', moveRight);
            
            // 마우스 이벤트 (데스크톱용)
            leftBtn.addEventListener('mousedown', moveLeft);
            rightBtn.addEventListener('mousedown', moveRight);
            
            // 키보드 이벤트
            window.addEventListener('keydown', function(e) {
                if (!gameActive || isMoving) return;
                
                if (e.key === 'ArrowLeft') {
                    moveLeft();
                } else if (e.key === 'ArrowRight') {
                    moveRight();
                }
            });
            
            function moveLeft() {
                if (!gameActive || isMoving || playerLane === 0) return;
                
                isMoving = true;
                playerLane--;
                moveAlliesTo(lanes[playerLane]);
            }
            
            function moveRight() {
                if (!gameActive || isMoving || playerLane === 2) return;
                
                isMoving = true;
                playerLane++;
                moveAlliesTo(lanes[playerLane]);
            }
        }
        
        // 아군 이동 함수
        function moveAlliesTo(targetX) {
            // 0.3초에 걸쳐 부드럽게 이동
            const frames = 15; // 60fps 기준 0.25초
            let currentFrame = 0;
            
            // 메인 아군 현재 위치
            const startX = allies[0].position.x;
            const moveAmount = (targetX - startX) / frames;
            
            const moveInterval = setInterval(() => {
                if (currentFrame >= frames) {
                    clearInterval(moveInterval);
                    isMoving = false;
                    return;
                }
                
                // 모든 아군 이동
                allies.forEach((ally, index) => {
                    if (index === 0) {
                        // 메인 아군
                        ally.position.x += moveAmount;
                    } else {
                        // 나머지 아군들은 메인 아군을 따라감
                        updateAllyFormation();
                    }
                });
                
                currentFrame++;
            }, 1000/60); // 60fps
        }
        
        // 아군 진형 업데이트
        function updateAllyFormation() {
            if (allies.length <= 1) return;
            
            const mainAlly = allies[0];
            const allyCount = allies.length;
            
            // 진영 크기 계산 - 아군이 많을수록 더 넓게 퍼짐
            const formationWidth = Math.min(3, 0.5 + (allyCount * 0.1));
            const formationDepth = Math.min(4, 1 + (allyCount * 0.15));
            
            for (let i = 1; i < allyCount; i++) {
                // 균등하게 분포된 위치 계산
                let row = Math.floor((i-1) / 3);
                let col = (i-1) % 3;
                
                // 중앙 정렬을 위한 오프셋
                let colOffset = col - 1; // -1, 0, 1
                let rowOffset = -row; // 항상 플레이어 뒤에 배치
                
                allies[i].position.x = mainAlly.position.x + (colOffset * formationWidth);
                allies[i].position.z = mainAlly.position.z + (rowOffset * formationDepth);
            }
        }
        
        // 아군 생성 함수 - 캐릭터 디자인 개선
        function createAllies(count) {
            // 기존 아군 제거
            allies.forEach(ally => scene.remove(ally));
            allies = [];
            
            // 최댓값 제한 (너무 많으면 게임이 쉬워짐)
            count = Math.min(count, 30);
            
            // 새 아군 생성 - 귀여운 오렌지색 캐릭터로 변경
            for (let i = 0; i < count; i++) {
                // 캐릭터 그룹
                const character = new THREE.Group();
                
                // 몸체 (구)
                const bodyGeometry = new THREE.SphereGeometry(0.5, 16, 16);
                const bodyMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFF9900, // 오렌지색
                    emissive: 0xAA5500,
                    emissiveIntensity: 0.2,
                    roughness: 0.7
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.castShadow = true;
                body.receiveShadow = true;
                character.add(body);
                
                // 캐릭터에 눈 추가
                const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
                
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(0.2, 0.2, 0.4);
                character.add(leftEye);
                
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(-0.2, 0.2, 0.4);
                character.add(rightEye);
                
                // 눈동자
                const pupilGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                const pupilMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
                
                const leftPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                leftPupil.position.set(0.2, 0.2, 0.45);
                character.add(leftPupil);
                
                const rightPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                rightPupil.position.set(-0.2, 0.2, 0.45);
                character.add(rightPupil);
                
                // 팔과 다리 추가 (메인 캐릭터만)
                if (i === 0) {
                    // 팔
                    const armGeometry = new THREE.SphereGeometry(0.15, 8, 8);
                    
                    const leftArm = new THREE.Mesh(armGeometry, bodyMaterial);
                    leftArm.position.set(0.6, 0, 0);
                    leftArm.castShadow = true;
                    character.add(leftArm);
                    
                    const rightArm = new THREE.Mesh(armGeometry, bodyMaterial);
                    rightArm.position.set(-0.6, 0, 0);
                    rightArm.castShadow = true;
                    character.add(rightArm);
                    
                    // 다리
                    const legGeometry = new THREE.CylinderGeometry(0.15, 0.1, 0.5, 8);
                    
                    const leftLeg = new THREE.Mesh(legGeometry, bodyMaterial);
                    leftLeg.position.set(0.2, -0.5, 0);
                    leftLeg.castShadow = true;
                    character.add(leftLeg);
                    
                    const rightLeg = new THREE.Mesh(legGeometry, bodyMaterial);
                    rightLeg.position.set(-0.2, -0.5, 0);
                    rightLeg.castShadow = true;
                    character.add(rightLeg);
                }
                
                if (i === 0) {
                    // 메인 아군 (플레이어)
                    character.position.set(lanes[playerLane], 0.5, 0);
                } else {
                    // 추가 아군들은 초기 위치만 설정 (updateAllyFormation에서 정확히 배치됨)
                    character.position.set(lanes[playerLane], 0.5, -i);
                    // 작게 만들기
                    character.scale.set(0.8, 0.8, 0.8);
                }
                
                scene.add(character);
                allies.push(character);
            }
            
            // 진형 업데이트
            updateAllyFormation();
            
            // UI 업데이트
            document.getElementById('allyCount').textContent = allies.length;
        }
        
        // 적 생성 함수 - 웨이브 형태로 생성
        function createEnemyWave() {
            const waveType = Math.floor(Math.random() * 4);
            
            switch (waveType) {
                case 0: // 일렬 웨이브
                    const randomLane = Math.floor(Math.random() * 3);
                    for (let i = 0; i < 5 + Math.floor(difficulty); i++) {
                        createEnemy(randomLane, -80 - (i * 4));
                    }
                    break;
                    
                case 1: // V 형태 웨이브
                    for (let i = 0; i < 7; i++) {
                        const laneOffset = (i <= 3) ? i : 6 - i; // 0,1,2,3,2,1,0
                        createEnemy(laneOffset, -80 - (i * 3));
                    }
                    break;
                    
                case 2: // 모든 레인 웨이브
                    for (let i = 0; i < 3; i++) {
                        for (let j = 0; j < 3; j++) {
                            createEnemy(j, -80 - (i * 5));
                        }
                    }
                    break;
                    
                case 3: // 랜덤 웨이브
                    const enemyCount = 5 + Math.floor(difficulty * 2);
                    for (let i = 0; i < enemyCount; i++) {
                        const randLane = Math.floor(Math.random() * 3);
                        const randDist = -80 - (Math.random() * 20);
                        createEnemy(randLane, randDist);
                    }
                    break;
            }
            
            function createEnemy(lane, zPos) {
                // 적 그룹
                const enemy = new THREE.Group();
                
                // 적 몸체 (기본 모양)
                const enemyGeometry = new THREE.SphereGeometry(0.5, 16, 16);
                const enemyMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xff0000,
                    emissive: 0xaa0000,
                    emissiveIntensity: 0.3,
                    roughness: 0.6
                });
                const body = new THREE.Mesh(enemyGeometry, enemyMaterial);
                body.castShadow = true;
                body.receiveShadow = true;
                enemy.add(body);
                
                // 적 눈 (흰색)
                const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
                
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(0.2, 0.2, 0.4);
                enemy.add(leftEye);
                
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(-0.2, 0.2, 0.4);
                enemy.add(rightEye);
                
                // 적 눈동자 (검은색)
                const pupilGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                const pupilMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
                
                const leftPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                leftPupil.position.set(0.2, 0.2, 0.45);
                enemy.add(leftPupil);
                
                const rightPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                rightPupil.position.set(-0.2, 0.2, 0.45);
                enemy.add(rightPupil);
                
                enemy.position.set(lanes[lane], 0.5, zPos);
                scene.add(enemy);
                enemies.push(enemy);
            }
        }
        
        // 총알 발사 함수
        function fireBullets() {
            const currentTime = Date.now();
            
            // 자동 발사 간격 (아군 수에 따라 감소)
            const fireInterval = Math.max(100, 500 - (allies.length * 10));
            
            if (currentTime - lastFireTime < fireInterval) return;
            
            lastFireTime = currentTime;
            
            // 아군 수에 비례해서 총알 발사 (아군당 0.5발의 총알)
            const bulletsToFire = Math.max(1, Math.ceil(allies.length * 0.5));
            
            for (let i = 0; i < bulletsToFire; i++) {
                const bulletGeometry = new THREE.SphereGeometry(0.2, 8, 8);
                const bulletMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xffff00, 
                    emissive: 0xffff00,
                    emissiveIntensity: 0.8
                });
                const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
                
                // 총알 발사 방향 다각화
                let angleOffset = 0;
                if (bulletsToFire > 1) {
                    // 부채꼴 형태로 퍼지게 발사
                    const spreadFactor = Math.min(0.3, bulletsToFire * 0.02);  // 최대 0.3 라디안 (약 17도)
                    angleOffset = spreadFactor * ((i / (bulletsToFire - 1)) * 2 - 1);
                }
                
                // 총알 위치는 무작위 아군 위치에서 시작
                const shooterIndex = Math.floor(Math.random() * allies.length);
                bullet.position.copy(allies[shooterIndex].position);
                bullet.position.z -= 1; // 약간 앞에서 발사
                
                // 총알 방향 설정
                bullet.userData.direction = new THREE.Vector3(angleOffset, 0, -1).normalize();
                bullet.userData.speed = 1.5;
                
                scene.add(bullet);
                bullets.push(bullet);
                
                // 총알 발사 이펙트 (빛)
                const bulletLight = new THREE.PointLight(0xffff00, 2, 5);
                bulletLight.position.copy(bullet.position);
                scene.add(bulletLight);
                
                // 0.1초 후 이펙트 제거
                setTimeout(() => {
                    scene.remove(bulletLight);
                }, 100);
            }
        }
        
        // 사칙연산 패널 생성 함수
        function createMathPanels() {
            // 기존 패널 제거
            panels.forEach(panel => scene.remove(panel));
            panels = [];
            
            // 랜덤 연산자 선택
            const operator = operators[Math.floor(Math.random() * operators.length)];
            
            // 피연산자 선택 (난이도에 따라 증가)
            const operand = Math.floor(Math.random() * Math.min(5, difficulty)) + 1;
            
            // 현재 아군 수와 연산 결과 계산
            const currentAllies = allies.length;
            const result = operator.fn(currentAllies, operand);
            
            // 연산 표시 업데이트
            activeEquation = `${currentAllies} ${operator.symbol} ${operand} = ${result}`;
            document.getElementById('currentEquation').textContent = activeEquation;
            
            // 도로 세 레인에 패널 생성
            for (let i = 0; i < 3; i++) {
                createMathPanel(lanes[i], -60 - Math.random() * 10, operand, operator);
            }
            
            function createMathPanel(x, z, operand, operator) {
                // 패널 그룹
                const panel = new THREE.Group();
                
                // 패널 플랫폼
                const panelGeometry = new THREE.BoxGeometry(3, 0.3, 3);
                
                // 연산자에 맞는 색상 적용
                const panelMaterial = new THREE.MeshStandardMaterial({ 
                    color: operator.color,
                    emissive: operator.color,
                    emissiveIntensity: 0.3,
                    transparent: true,
                    opacity: 0.85
                });
                
                const panelMesh = new THREE.Mesh(panelGeometry, panelMaterial);
                panelMesh.castShadow = true;
                panelMesh.receiveShadow = true;
                panel.add(panelMesh);
                
                // 패널에 숫자 표시를 위한 텍스트 (Three.js에서는 실제 텍스트 렌더링이 어려워 대체 표현)
                const operatorSymbol = operator.symbol;
                const operatorTextGeometry = new THREE.BoxGeometry(1, 0.1, 1);
                const operatorTextMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFFFFFF,
                    emissive: 0xFFFFFF,
                    emissiveIntensity: 0.5
                });
                
                const operatorText = new THREE.Mesh(operatorTextGeometry, operatorTextMaterial);
                operatorText.position.y = 0.2;
                panel.add(operatorText);
                
                // 숫자 표시 (간소화된 형태)
                const numberGeometry = new THREE.BoxGeometry(0.5, 0.1, 0.5);
                const numberMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
                const numberMesh = new THREE.Mesh(numberGeometry, numberMaterial);
                numberMesh.position.set(0, 0.2, 0.5);
                panel.add(numberMesh);
                
                // 패널 위치 설정
                panel.position.set(x, 0, z);
                
                // 패널에 연산 데이터 추가
                panel.userData = {
                    operator: operatorSymbol,
                    operand: operand,
                    result: result
                };
                
                // 패널 발광 효과
                const panelLight = new THREE.PointLight(operator.color, 1, 5);
                panelLight.position.set(0, 0.5, 0);
                panel.add(panelLight);
                
                scene.add(panel);
                panels.push(panel);
            }
        }
        
        // 게임 업데이트 함수
        function updateGame() {
            const currentTime = Date.now();
            
            // 도로 스크롤
            scrollRoad();
            
            // 3초마다 패널 생성
            if (currentTime - lastPanelTime > 3000) {
                createMathPanels();
                lastPanelTime = currentTime;
            }
            
            // 난이도에 따라 적 웨이브 생성 주기 조절
            const enemyWaveInterval = Math.max(2000, 5000 - (difficulty * 300));
            if (currentTime - lastEnemyWaveTime > enemyWaveInterval) {
                createEnemyWave();
                lastEnemyWaveTime = currentTime;
            }
            
            // 자동 총알 발사
            fireBullets();
            
            // 패널 이동 (도로와 함께 이동)
            panels.forEach(panel => {
                panel.position.z += roadSpeed;
                
                // 화면 끝에 도달한 패널은 제거
                if (panel.position.z > 10) {
                    scene.remove(panel);
                    panels.splice(panels.indexOf(panel), 1);
                    
                    // 모든 패널이 사라졌을 때 현재 연산 초기화
                    if (panels.length === 0) {
                        document.getElementById('currentEquation').textContent = "없음";
                    }
                }
            });
            
            // 적 이동 (도로와 함께 이동, 약간 더 빠르게)
            enemies.forEach(enemy => {
                enemy.position.z += roadSpeed * 1.2;
                
                // 화면 끝에 도달한 적은 제거
                if (enemy.position.z > 10) {
                    scene.remove(enemy);
                    enemies.splice(enemies.indexOf(enemy), 1);
                }
                
                // 적 애니메이션 (약간 상하로 움직임)
                enemy.position.y = 0.5 + Math.sin(currentTime / 300 + enemy.position.z) * 0.1;
                
                // 추가: 적 회전 애니메이션
                enemy.rotation.y += 0.02;
            });
            
            // 아군 애니메이션 (약간 위아래로 움직임)
            allies.forEach((ally, index) => {
                // 메인 캐릭터 (0번 인덱스)만 특별한 애니메이션 적용
                if (index === 0) {
                    ally.position.y = 0.5 + Math.sin(currentTime / 500) * 0.05;
                    
                    // 달리기 애니메이션 효과 (앞뒤로 약간 기울임)
                    ally.rotation.x = Math.sin(currentTime / 200) * 0.1;
                } else {
                    // 다른 아군들은 약간 다른 주기로 움직여 자연스러움 증가
                    ally.position.y = 0.5 + Math.sin((currentTime / 500) + index * 0.5) * 0.05;
                }
            });
            
            // 총알 이동
            bullets.forEach(bullet => {
                const direction = bullet.userData.direction;
                bullet.position.x += direction.x * bullet.userData.speed;
                bullet.position.z += direction.z * bullet.userData.speed;
                
                // 총알 회전 효과 추가
                bullet.rotation.x += 0.2;
                bullet.rotation.y += 0.2;
                
                // 화면 밖으로 나간 총알 제거
                if (bullet.position.z < -100) {
                    scene.remove(bullet);
                    bullets.splice(bullets.indexOf(bullet), 1);
                }
            });
            
            // 충돌 체크
            checkCollisions();
            
            // 난이도 증가
            difficulty = 1 + ((60 - gameTime) / 5);
            
            // 도로 속도 증가 (난이도에 따라)
            roadSpeed = 0.5 + (difficulty * 0.05);
        }
        
        // 충돌 체크 함수 - 시각적 효과 추가
        function checkCollisions() {
            // 총알과 적의 충돌
            bullets.forEach(bullet => {
                enemies.forEach(enemy => {
                    const distance = bullet.position.distanceTo(enemy.position);
                    if (distance < 1) {
                        // 충돌 시 폭발 효과
                        createExplosion(enemy.position.clone());
                        
                        // 충돌 발생
                        scene.remove(bullet);
                        scene.remove(enemy);
                        bullets.splice(bullets.indexOf(bullet), 1);
                        enemies.splice(enemies.indexOf(enemy), 1);
                        
                        // 점수 추가
                        score += 10;
                        document.getElementById('score').textContent = score;
                    }
                });
            });
            
            // 플레이어(메인 아군)와 패널의 충돌
            if (allies.length > 0) {
                const player = allies[0];
                
                panels.forEach(panel => {
                    const distance = Math.sqrt(
                        Math.pow(player.position.x - panel.position.x, 2) +
                        Math.pow(player.position.z - panel.position.z, 2)
                    );
                    
                    if (distance < 2) {
                        // 패널과 충돌 - 사칙연산 수행
                        if (panel.userData.result !== undefined) {
                            // 패널 획득 효과
                            createPanelEffect(player.position.clone());
                            
                            createAllies(panel.userData.result);
                            
                            // 보너스 점수
                            score += 50;
                            document.getElementById('score').textContent = score;
                            
                            // 모든 패널 제거
                            panels.forEach(p => scene.remove(p));
                            panels = [];
                            
                            // 연산 초기화
                            document.getElementById('currentEquation').textContent = "없음";
                        }
                    }
                });
                
                // 플레이어와 적의 충돌
                enemies.forEach(enemy => {
                    const distance = player.position.distanceTo(enemy.position);
                    if (distance < 1.2) {
                        // 충돌 시 데미지 효과
                        createDamageEffect(player.position.clone());
                        
                        // 충돌 발생 - 아군 감소
                        if (allies.length > 1) {
                            createAllies(allies.length - 1);
                            
                            // 해당 적 제거
                            scene.remove(enemy);
                            enemies.splice(enemies.indexOf(enemy), 1);
                        } else {
                            // 마지막 아군이 적과 충돌하면 게임 오버
                            endGame();
                        }
                    }
                });
            }
        }
        
        // 폭발 효과 생성 함수
        function createExplosion(position) {
            // 폭발 파티클 그룹
            const explosionGroup = new THREE.Group();
            explosionGroup.position.copy(position);
            
            // 폭발 빛
            const explosionLight = new THREE.PointLight(0xff5500, 3, 8);
            explosionLight.position.set(0, 0, 0);
            explosionGroup.add(explosionLight);
            
            // 파티클 생성
            const particleCount = 10;
            const particles = [];
            
            for (let i = 0; i < particleCount; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const particleMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xff5500, 
                    transparent: true, 
                    opacity: 1
                });
                
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                
                // 랜덤 방향으로 튀어나감
                const angle1 = Math.random() * Math.PI * 2;
                const angle2 = Math.random() * Math.PI * 2;
                
                const speed = 0.1 + Math.random() * 0.2;
                particle.userData.velocity = new THREE.Vector3(
                    Math.sin(angle1) * Math.cos(angle2) * speed,
                    Math.sin(angle1) * Math.sin(angle2) * speed,
                    Math.cos(angle1) * speed
                );
                
                explosionGroup.add(particle);
                particles.push(particle);
            }
            
            scene.add(explosionGroup);
            
            // 0.5초 동안 폭발 애니메이션
            let elapsed = 0;
            const duration = 500; // 밀리초
            const interval = setInterval(() => {
                elapsed += 16;
                
                // 파티클 이동 및 페이드 아웃
                particles.forEach(particle => {
                    particle.position.add(particle.userData.velocity);
                    particle.material.opacity = 1 - (elapsed / duration);
                    particle.scale.multiplyScalar(0.98);
                });
                
                // 빛 감소
                explosionLight.intensity = 3 * (1 - elapsed / duration);
                
                if (elapsed >= duration) {
                    clearInterval(interval);
                    scene.remove(explosionGroup);
                }
            }, 16);
        }
        
        // 패널 획득 효과
        function createPanelEffect(position) {
            // 빛 생성
            const light = new THREE.PointLight(0x00ffff, 3, 10);
            light.position.copy(position);
            scene.add(light);
            
            // 0.5초 동안 빛 효과
            let elapsed = 0;
            const duration = 500; // 밀리초
            const interval = setInterval(() => {
                elapsed += 16;
                
                // 빛 강도 조절
                light.intensity = 3 * (1 - elapsed / duration);
                
                if (elapsed >= duration) {
                    clearInterval(interval);
                    scene.remove(light);
                }
            }, 16);
        }
        
        // 데미지 효과
        function createDamageEffect(position) {
            // 빨간 빛 생성
            const light = new THREE.PointLight(0xff0000, 3, 10);
            light.position.copy(position);
            scene.add(light);
            
            // 화면 빨갛게 깜빡임 (CSS 효과)
            const overlay = document.createElement('div');
            overlay.style.position = 'absolute';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.width = '100%';
            overlay.style.height = '100%';
            overlay.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
            overlay.style.pointerEvents = 'none';
            overlay.style.transition = 'opacity 0.5s';
            document.body.appendChild(overlay);
            
            // 0.5초 동안 효과
            setTimeout(() => {
                overlay.style.opacity = '0';
                setTimeout(() => {
                    document.body.removeChild(overlay);
                }, 500);
            }, 100);
            
            // 빛 효과 제거
            setTimeout(() => {
                scene.remove(light);
            }, 500);
        }
        
        // 게임 타이머 함수
        function startGameTimer() {
            const timerInterval = setInterval(() => {
                if (!gameActive) {
                    clearInterval(timerInterval);
                    return;
                }
                
                gameTime--;
                document.getElementById('timer').textContent = gameTime;
                
                if (gameTime <= 0) {
                    clearInterval(timerInterval);
                    endGame();
                }
            }, 1000);
        }
        
        // 게임 종료 함수
        function endGame() {
            gameActive = false;
            document.getElementById('gameOver').style.display = 'block';
            document.getElementById('finalScore').textContent = score;
            
            // 게임 오버 효과
            const gameOverLight = new THREE.AmbientLight(0xff0000, 0.3);
            scene.add(gameOverLight);
            
            // 모든 아군 회전 애니메이션
            const rotateAllies = () => {
                allies.forEach(ally => {
                    ally.rotation.y += 0.05;
                });
                
                if (gameActive) {
                    return;
                }
                
                requestAnimationFrame(rotateAllies);
            };
            
            rotateAllies();
        }
        
        // 게임 재시작 함수
        function restartGame() {
            // 기존 오브젝트 정리
            allies.forEach(ally => scene.remove(ally));
            enemies.forEach(enemy => scene.remove(enemy));
            bullets.forEach(bullet => scene.remove(bullet));
            panels.forEach(panel => scene.remove(panel));
            
            // 씬의 모든 빛 제거 (게임 오버 효과 제거)
            scene.children.forEach(child => {
                if (child instanceof THREE.Light && !(child instanceof THREE.DirectionalLight) && !(child instanceof THREE.AmbientLight && child.intensity === 0.6)) {
                    scene.remove(child);
                }
            });
            
            allies = [];
            enemies = [];
            bullets = [];
            panels = [];
            
            // 변수 초기화
            gameTime = 60;
            score = 0;
            difficulty = 1;
            gameActive = true;
            lastPanelTime = 0;
            lastEnemyWaveTime = 0;
            playerLane = 1; // 중앙 레인으로 초기화
            isMoving = false;
            roadSpeed = 0.5;
            gameDistance = 0;
            
            // UI 초기화
            document.getElementById('timer').textContent = gameTime;
            document.getElementById('score').textContent = score;
            document.getElementById('currentEquation').textContent = "없음";
            document.getElementById('gameOver').style.display = 'none';
            
            // 기본 조명 재설정
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(0, 20, 10);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // 첫 아군 생성
            createAllies(1);
            
            // 타이머 재시작
            startGameTimer();
        }
        
        // 애니메이션 루프
        function animate() {
            requestAnimationFrame(animate);
            
            if (gameActive) {
                updateGame();
            }
            
            renderer.render(scene, camera);
        }
        
        // 화면 크기 조정 이벤트
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // 게임 시작
        init();
    </script>
</body>
</html>
</antArtifact><antArtifact identifier="enhanced-game" type="application/vnd.ant.code" language="html" title="Enhanced Math Runner 3D Game">
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>러너 3D 슈팅 게임</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: Arial, sans-serif; 
            touch-action: none;
        }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            padding: 5px;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 1px 1px 1px black;
            z-index: 10;
        }
        #equationInfo {
            position: absolute;
            top: 40px;
            width: 100%;
            text-align: center;
            color: #ffcc00;
            padding: 5px;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 1px 1px 1px black;
            z-index: 10;
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none;
            z-index: 20;
        }
        #restartBtn {
            padding: 15px 30px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 18px;
            margin-top: 20px;
        }
        #restartBtn:hover {
            background-color: #45a049;
        }
        #controls {
            position: absolute;
            bottom: 30px;
            width: 100%;
            display: flex;
            justify-content: center;
            z-index: 10;
        }
        .controlBtn {
            width: 80px;
            height: 80px;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 40px;
            margin: 0 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
            user-select: none;
        }
    </style>
</head>
<body>
    <div id="info">아군: <span id="allyCount">1</span> | 시간: <span id="timer">60</span>초 | 점수: <span id="score">0</span></div>
    <div id="equationInfo">현재 패널: <span id="currentEquation">없음</span></div>
    <div id="gameOver">
        <h2>게임 종료!</h2>
        <p>최종 점수: <span id="finalScore">0</span></p>
        <button id="restartBtn">다시 시작</button>
    </div>
    <div id="controls">
        <div id="leftBtn" class="controlBtn">←</div>
        <div id="rightBtn" class="controlBtn">→</div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // 게임 변수
        let scene, camera, renderer, allies = [], enemies = [], bullets = [], panels = [];
        let gameTime = 60; // 1분
        let score = 0;
        let difficulty = 1;
        let gameActive = true;
        let lastPanelTime = 0;
        let lastEnemyWaveTime = 0;
        let lastFireTime = 0;
        let playerLane = 1; // 0: 왼쪽, 1: 중앙, 2: 오른쪽
        let isMoving = false;
        let roadSpeed = 0.5;
        let roadSegments = [];
        let gameDistance = 0;
        let activeEquation = "";
        
        // 레인 위치 정의
        const lanes = [-5, 0, 5];
        
        // 수학 연산자 (각각 강한 네온 색상으로 변경)
        const operators = [
            { symbol: "+", fn: (a, b) => a + b, color: 0x00FFFF, glow: 0x00FFFF }, // 네온 청록색
            { symbol: "-", fn: (a, b) => Math.max(1, a - b), color: 0xFF1493, glow: 0xFF1493 }, // 네온 핑크
            { symbol: "×", fn: (a, b) => a * b, color: 0x39FF14, glow: 0x39FF14 }, // 네온 그린
            { symbol: "÷", fn: (a, b) => Math.round(a / b) || 1, color: 0xFFD700, glow: 0xFFD700 } // 네온 골드
        ];
        
        // 게임 초기화
        function init() {
            // 씬 설정
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e); // 어두운 남색 배경
            
            // 안개 추가 (원근감) - 더 짙게 설정
            scene.fog = new THREE.Fog(0x1a1a2e, 30, 80);
            
            // 카메라 설정
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 8, 12); // 카메라 높이와 거리 조정
            camera.lookAt(0, 0, -20);
            
            // 렌더러 설정
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; // 그림자 활성화
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);
            
            // 조명 설정
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(0, 20, 10);
            directionalLight.castShadow = true; // 그림자 생성
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -20;
            directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20;
            directionalLight.shadow.camera.bottom = -20;
            scene.add(directionalLight);
            
            // 도로 생성
            createRoad();
            
            // 첫 아군 생성
            createAllies(1);
            
            // 이벤트 리스너
            window.addEventListener('resize', onWindowResize);
            document.getElementById('restartBtn').addEventListener('click', restartGame);
            
            // 모바일 컨트롤 초기화
            initControls();
            
            // 게임 타이머 시작
            startGameTimer();
            
            // 게임 루프 시작
            animate();
        }
        
        // 도로 생성 함수
        function createRoad() {
            // 도로 텍스처 (하늘색 그라데이션 패턴으로 변경)
            const roadWidth = 15;
            const roadLength = 1000;
            const segmentLength = 20;
            const segments = roadLength / segmentLength;
            
            // 도로 기본 재질 (네온 효과가 있는 어두운 색상)
            const roadMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x0f3460,
                roughness: 0.5,
                metalness: 0.7,
                emissive: 0x0f3460,
                emissiveIntensity: 0.2
            });
            
            // 도로 경계선 재질 (밝은 네온 색상)
            const lineMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xE94560, 
                emissive: 0xE94560,
                emissiveIntensity: 0.7
            });
            
            // 도로 가장자리 재질 (네온 푸른색)
            const sideMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x16213E,
                emissive: 0x0F52BA,
                emissiveIntensity: 0.3
            });
            
            // 도로 그라데이션을 위한 재질 배열 (네온 효과가 있는 패턴)
            const patternMaterials = [
                new THREE.MeshStandardMaterial({ 
                    color: 0x0f3460, 
                    emissive: 0x0f3460,
                    emissiveIntensity: 0.2
                }),
                new THREE.MeshStandardMaterial({ 
                    color: 0x16213E, 
                    emissive: 0x16213E,
                    emissiveIntensity: 0.2
                })
            ];
            
            // 여러 세그먼트로 도로 생성
            for (let i = 0; i < segments; i++) {
                // 도로 세그먼트 (패턴 적용)
                const roadGeometry = new THREE.PlaneGeometry(roadWidth, segmentLength);
                const road = new THREE.Mesh(roadGeometry, patternMaterials[i % 2]); // 번갈아가며 패턴 적용
                road.rotation.x = -Math.PI / 2;
                road.position.z = -i * segmentLength - segmentLength / 2;
                road.position.y = -0.1;
                road.receiveShadow = true; // 그림자 받기
                scene.add(road);
                roadSegments.push(road);
                
                // 도로 레인 구분선
                for (let j = -1; j <= 1; j += 2) {
                    const lineGeometry = new THREE.PlaneGeometry(0.3, segmentLength);
                    const line = new THREE.Mesh(lineGeometry, lineMaterial);
                    line.rotation.x = -Math.PI / 2;
                    line.position.set(j * roadWidth/6, -0.05, -i * segmentLength - segmentLength / 2);
                    line.receiveShadow = true;
                    scene.add(line);
                    roadSegments.push(line);
                }
                
                // 도로 가장자리
                for (let j = -1; j <= 1; j += 2) {
                    const sideGeometry = new THREE.BoxGeometry(2, 1, segmentLength);
                    const side = new THREE.Mesh(sideGeometry, sideMaterial);
                    side.position.set(j * (roadWidth/2 + 1), 0.4, -i * segmentLength - segmentLength / 2);
                    side.castShadow = true;
                    side.receiveShadow = true;
                    scene.add(side);
                    roadSegments.push(side);
                    
                    // 가드레일 기둥 추가
                    if (i % 2 === 0) {
                        const postGeometry = new THREE.BoxGeometry(0.5, 2, 0.5);
                        const postMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
                        const post = new THREE.Mesh(postGeometry, postMaterial);
                        post.position.set(j * (roadWidth/2 + 1), 1.5, -i * segmentLength - segmentLength / 2);
                        post.castShadow = true;
                        post.receiveShadow = true;
                        scene.add(post);
                        roadSegments.push(post);
                    }
                }
            }
        }
        
        // 도로 스크롤 함수
        function scrollRoad() {
            const resetPos = -1000; // 도로 총 길이
            
            roadSegments.forEach(segment => {
                segment.position.z += roadSpeed;
                
                // 도로 세그먼트가 카메라 뒤로 지나가면 다시 앞으로 재배치
                if (segment.position.z > 20) {
                    segment.position.z = resetPos + (segment.position.z - 20);
                }
            });
            
            // 거리 증가
            gameDistance += roadSpeed;
        }
        
        // 컨트롤 초기화
        function initControls() {
            const leftBtn = document.getElementById('leftBtn');
            const rightBtn = document.getElementById('rightBtn');
            
            // 터치 이벤트
            leftBtn.addEventListener('touchstart', moveLeft);
            rightBtn.addEventListener('touchstart', moveRight);
            
            // 마우스 이벤트 (데스크톱용)
            leftBtn.addEventListener('mousedown', moveLeft);
            rightBtn.addEventListener('mousedown', moveRight);
            
            // 키보드 이벤트
            window.addEventListener('keydown', function(e) {
                if (!gameActive || isMoving) return;
                
                if (e.key === 'ArrowLeft') {
                    moveLeft();
                } else if (e.key === 'ArrowRight') {
                    moveRight();
                }
            });
            
            function moveLeft() {
                if (!gameActive || isMoving || playerLane === 0) return;
                
                isMoving = true;
                playerLane--;
                moveAlliesTo(lanes[playerLane]);
            }
            
            function moveRight() {
                if (!gameActive || isMoving || playerLane === 2) return;
                
                isMoving = true;
                playerLane++;
                moveAlliesTo(lanes[playerLane]);
            }
        }
        
        // 아군 이동 함수
        function moveAlliesTo(targetX) {
            // 0.3초에 걸쳐 부드럽게 이동
            const frames = 15; // 60fps 기준 0.25초
            let currentFrame = 0;
            
            // 메인 아군 현재 위치
            const startX = allies[0].position.x;
            const moveAmount = (targetX - startX) / frames;
            
            const moveInterval = setInterval(() => {
                if (currentFrame >= frames) {
                    clearInterval(moveInterval);
                    isMoving = false;
                    return;
                }
                
                // 모든 아군 이동
                allies.forEach((ally, index) => {
                    if (index === 0) {
                        // 메인 아군
                        ally.position.x += moveAmount;
                    } else {
                        // 나머지 아군들은 메인 아군을 따라감
                        updateAllyFormation();
                    }
                });
                
                currentFrame++;
            }, 1000/60); // 60fps
        }
        
        // 아군 진형 업데이트
        function updateAllyFormation() {
            if (allies.length <= 1) return;
            
            const mainAlly = allies[0];
            const allyCount = allies.length;
            
            // 진영 크기 계산 - 아군이 많을수록 더 넓게 퍼짐
            const formationWidth = Math.min(3, 0.5 + (allyCount * 0.1));
            const formationDepth = Math.min(4, 1 + (allyCount * 0.15));
            
            for (let i = 1; i < allyCount; i++) {
                // 균등하게 분포된 위치 계산
                let row = Math.floor((i-1) / 3);
                let col = (i-1) % 3;
                
                // 중앙 정렬을 위한 오프셋
                let colOffset = col - 1; // -1, 0, 1
                let rowOffset = -row; // 항상 플레이어 뒤에 배치
                
                allies[i].position.x = mainAlly.position.x + (colOffset * formationWidth);
                allies[i].position.z = mainAlly.position.z + (rowOffset * formationDepth);
            }
        }
        
        // 아군 생성 함수 - 캐릭터 디자인 개선
        function createAllies(count) {
            // 기존 아군 제거
            allies.forEach(ally => scene.remove(ally));
            allies = [];
            
            // 최댓값 제한 (너무 많으면 게임이 쉬워짐)
            count = Math.min(count, 30);
            
            // 새 아군 생성 - 귀여운 오렌지색 캐릭터로 변경
            for (let i = 0; i < count; i++) {
                // 캐릭터 그룹
                const character = new THREE.Group();
                
                // 몸체 (구)
                const bodyGeometry = new THREE.SphereGeometry(0.5, 16, 16);
                const bodyMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFF9900, // 오렌지색
                    emissive: 0xAA5500,
                    emissiveIntensity: 0.2,
                    roughness: 0.7
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.castShadow = true;
                body.receiveShadow = true;
                character.add(body);
                
                // 캐릭터에 눈 추가
                const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
                
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(0.2, 0.2, 0.4);
                character.add(leftEye);
                
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(-0.2, 0.2, 0.4);
                character.add(rightEye);
                
                // 눈동자
                const pupilGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                const pupilMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
                
                const leftPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                leftPupil.position.set(0.2, 0.2, 0.45);
                character.add(leftPupil);
                
                const rightPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                rightPupil.position.set(-0.2, 0.2, 0.45);
                character.add(rightPupil);
                
                // 팔과 다리 추가 (메인 캐릭터만)
                if (i === 0) {
                    // 팔
                    const armGeometry = new THREE.SphereGeometry(0.15, 8, 8);
                    
                    const leftArm = new THREE.Mesh(armGeometry, bodyMaterial);
                    leftArm.position.set(0.6, 0, 0);
                    leftArm.castShadow = true;
                    character.add(leftArm);
                    
                    const rightArm = new THREE.Mesh(armGeometry, bodyMaterial);
                    rightArm.position.set(-0.6, 0, 0);
                    rightArm.castShadow = true;
                    character.add(rightArm);
                    
                    // 다리
                    const legGeometry = new THREE.CylinderGeometry(0.15, 0.1, 0.5, 8);
                    
                    const leftLeg = new THREE.Mesh(legGeometry, bodyMaterial);
                    leftLeg.position.set(0.2, -0.5, 0);
                    leftLeg.castShadow = true;
                    character.add(leftLeg);
                    
                    const rightLeg = new THREE.Mesh(legGeometry, bodyMaterial);
                    rightLeg.position.set(-0.2, -0.5, 0);
                    rightLeg.castShadow = true;
                    character.add(rightLeg);
                }
                
                if (i === 0) {
                    // 메인 아군 (플레이어)
                    character.position.set(lanes[playerLane], 0.5, 0);
                } else {
                    // 추가 아군들은 초기 위치만 설정 (updateAllyFormation에서 정확히 배치됨)
                    character.position.set(lanes[playerLane], 0.5, -i);
                    // 작게 만들기
                    character.scale.set(0.8, 0.8, 0.8);
                }
                
                scene.add(character);
                allies.push(character);
            }
            
            // 진형 업데이트
            updateAllyFormation();
            
            // UI 업데이트
            document.getElementById('allyCount').textContent = allies.length;
        }
        
        // 적 생성 함수 - 웨이브 형태로 생성
        function createEnemyWave() {
            const waveType = Math.floor(Math.random() * 4);
            
            switch (waveType) {
                case 0: // 일렬 웨이브
                    const randomLane = Math.floor(Math.random() * 3);
                    for (let i = 0; i < 5 + Math.floor(difficulty); i++) {
                        createEnemy(randomLane, -80 - (i * 4));
                    }
                    break;
                    
                case 1: // V 형태 웨이브
                    for (let i = 0; i < 7; i++) {
                        const laneOffset = (i <= 3) ? i : 6 - i; // 0,1,2,3,2,1,0
                        createEnemy(laneOffset, -80 - (i * 3));
                    }
                    break;
                    
                case 2: // 모든 레인 웨이브
                    for (let i = 0; i < 3; i++) {
                        for (let j = 0; j < 3; j++) {
                            createEnemy(j, -80 - (i * 5));
                        }
                    }
                    break;
                    
                case 3: // 랜덤 웨이브
                    const enemyCount = 5 + Math.floor(difficulty * 2);
                    for (let i = 0; i < enemyCount; i++) {
                        const randLane = Math.floor(Math.random() * 3);
                        const randDist = -80 - (Math.random() * 20);
                        createEnemy(randLane, randDist);
                    }
                    break;
            }
            
            function createEnemy(lane, zPos) {
                // 적 그룹
                const enemy = new THREE.Group();
                
                // 적 몸체 (기본 모양)
                const enemyGeometry = new THREE.SphereGeometry(0.5, 16, 16);
                const enemyMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xff0000,
                    emissive: 0xaa0000,
                    emissiveIntensity: 0.3,
                    roughness: 0.6
                });
                const body = new THREE.Mesh(enemyGeometry, enemyMaterial);
                body.castShadow = true;
                body.receiveShadow = true;
                enemy.add(body);
                
                // 적 눈 (흰색)
                const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
                
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(0.2, 0.2, 0.4);
                enemy.add(leftEye);
                
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(-0.2, 0.2, 0.4);
                enemy.add(rightEye);
                
                // 적 눈동자 (검은색)
                const pupilGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                const pupilMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
                
                const leftPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                leftPupil.position.set(0.2, 0.2, 0.45);
                enemy.add(leftPupil);
                
                const rightPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                rightPupil.position.set(-0.2, 0.2, 0.45);
                enemy.add(rightPupil);
                
                enemy.position.set(lanes[lane], 0.5, zPos);
                scene.add(enemy);
                enemies.push(enemy);
            }
        }
        
        // 총알 발사 함수
        function fireBullets() {
            const currentTime = Date.now();
            
            // 자동 발사 간격 (아군 수에 따라 감소)
            const fireInterval = Math.max(100, 500 - (allies.length * 10));
            
            if (currentTime - lastFireTime < fireInterval) return;
            
            lastFireTime = currentTime;
            
            // 아군 수에 비례해서 총알 발사 (아군당 0.5발의 총알)
            const bulletsToFire = Math.max(1, Math.ceil(allies.length * 0.5));
            
            for (let i = 0; i < bulletsToFire; i++) {
                const bulletGeometry = new THREE.SphereGeometry(0.2, 8, 8);
                const bulletMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xffff00, 
                    emissive: 0xffff00,
                    emissiveIntensity: 0.8
                });
                const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
                
                // 총알 발사 방향 다각화
                let angleOffset = 0;
                if (bulletsToFire > 1) {
                    // 부채꼴 형태로 퍼지게 발사
                    const spreadFactor = Math.min(0.3, bulletsToFire * 0.02);  // 최대 0.3 라디안 (약 17도)
                    angleOffset = spreadFactor * ((i / (bulletsToFire - 1)) * 2 - 1);
                }
                
                // 총알 위치는 무작위 아군 위치에서 시작
                const shooterIndex = Math.floor(Math.random() * allies.length);
                bullet.position.copy(allies[shooterIndex].position);
                bullet.position.z -= 1; // 약간 앞에서 발사
                
                // 총알 방향 설정
                bullet.userData.direction = new THREE.Vector3(angleOffset, 0, -1).normalize();
                bullet.userData.speed = 1.5;
                
                scene.add(bullet);
                bullets.push(bullet);
                
                // 총알 발사 이펙트 (빛)
                const bulletLight = new THREE.PointLight(0xffff00, 2, 5);
                bulletLight.position.copy(bullet.position);
                scene.add(bulletLight);
                
                // 0.1초 후 이펙트 제거
                setTimeout(() => {
                    scene.remove(bulletLight);
                }, 100);
            }
        }
        
        // 사칙연산 패널 생성 함수
        function createMathPanels() {
            // 기존 패널 제거
            panels.forEach(panel => scene.remove(panel));
            panels = [];
            
            // 랜덤 연산자 선택
            const operator = operators[Math.floor(Math.random() * operators.length)];
            
            // 피연산자 선택 (난이도에 따라 증가)
            const operand = Math.floor(Math.random() * Math.min(5, difficulty)) + 1;
            
            // 현재 아군 수와 연산 결과 계산
            const currentAllies = allies.length;
            const result = operator.fn(currentAllies, operand);
            
            // 연산 표시 업데이트
            activeEquation = `${currentAllies} ${operator.symbol} ${operand} = ${result}`;
            document.getElementById('currentEquation').textContent = activeEquation;
            
            // 도로 세 레인에 패널 생성
            for (let i = 0; i < 3; i++) {
                createMathPanel(lanes[i], -60 - Math.random() * 10, operand, operator);
            }
            
            function createMathPanel(x, z, operand, operator) {
                // 패널 그룹
                const panel = new THREE.Group();
                
                // 패널 플랫폼
                const panelGeometry = new THREE.BoxGeometry(3, 0.3, 3);
                
                // 연산자에 맞는 색상 적용 (강한 네온 효과)
                const panelMaterial = new THREE.MeshStandardMaterial({ 
                    color: operator.color,
                    emissive: operator.glow,
                    emissiveIntensity: 0.8,
                    transparent: true,
                    opacity: 0.9
                });
                
                const panelMesh = new THREE.Mesh(panelGeometry, panelMaterial);
                panelMesh.castShadow = true;
                panelMesh.receiveShadow = true;
                panel.add(panelMesh);
                
                // 패널에 숫자 표시를 위한 텍스트 (Three.js에서는 실제 텍스트 렌더링이 어려워 대체 표현)
                const operatorSymbol = operator.symbol;
                const operatorTextGeometry = new THREE.BoxGeometry(1, 0.1, 1);
                const operatorTextMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFFFFFF,
                    emissive: 0xFFFFFF,
                    emissiveIntensity: 0.5
                });
                
                const operatorText = new THREE.Mesh(operatorTextGeometry, operatorTextMaterial);
                operatorText.position.y = 0.2;
                panel.add(operatorText);
                
                // 숫자 표시 (간소화된 형태)
                const numberGeometry = new THREE.BoxGeometry(0.5, 0.1, 0.5);
                const numberMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
                const numberMesh = new THREE.Mesh(numberGeometry, numberMaterial);
                numberMesh.position.set(0, 0.2, 0.5);
                panel.add(numberMesh);
                
                // 패널 위치 설정
                panel.position.set(x, 0, z);
                
                // 패널에 연산 데이터 추가
                panel.userData = {
                    operator: operatorSymbol,
                    operand: operand,
                    result: result
                };
                
                // 패널 발광 효과
                const panelLight = new THREE.PointLight(operator.color, 1, 5);
                panelLight.position.set(0, 0.5, 0);
                panel.add(panelLight);
                
                scene.add(panel);
                panels.push(panel);
            }
        }
        
        // 게임 업데이트 함수
        function updateGame() {
            const currentTime = Date.now();
            
            // 도로 스크롤
            scrollRoad();
            
            // 3초마다 패널 생성
            if (currentTime - lastPanelTime > 3000) {
                createMathPanels();
                lastPanelTime = currentTime;
            }
            
            // 난이도에 따라 적 웨이브 생성 주기 조절
            const enemyWaveInterval = Math.max(2000, 5000 - (difficulty * 300));
            if (currentTime - lastEnemyWaveTime > enemyWaveInterval) {
                createEnemyWave();
                lastEnemyWaveTime = currentTime;
            }
            
            // 자동 총알 발사
            fireBullets();
            
            // 패널 이동 (도로와 함께 이동)
            panels.forEach(panel => {
                panel.position.z += roadSpeed;
                
                // 화면 끝에 도달한 패널은 제거
                if (panel.position.z > 10) {
                    scene.remove(panel);
                    panels.splice(panels.indexOf(panel), 1);
                    
                    // 모든 패널이 사라졌을 때 현재 연산 초기화
                    if (panels.length === 0) {
                        document.getElementById('currentEquation').textContent = "없음";
                    }
                }
            });
            
            // 적 이동 (도로와 함께 이동, 약간 더 빠르게)
            enemies.forEach(enemy => {
                enemy.position.z += roadSpeed * 1.2;
                
                // 화면 끝에 도달한 적은 제거
                if (enemy.position.z > 10) {
                    scene.remove(enemy);
                    enemies.splice(enemies.indexOf(enemy), 1);
                }
                
                // 적 애니메이션 (약간 상하로 움직임)
                enemy.position.y = 0.5 + Math.sin(currentTime / 300 + enemy.position.z) * 0.1;
                
                // 추가: 적 회전 애니메이션
                enemy.rotation.y += 0.02;
            });
            
            // 아군 애니메이션 (약간 위아래로 움직임)
            allies.forEach((ally, index) => {
                // 메인 캐릭터 (0번 인덱스)만 특별한 애니메이션 적용
                if (index === 0) {
                    ally.position.y = 0.5 + Math.sin(currentTime / 500) * 0.05;
                    
                    // 달리기 애니메이션 효과 (앞뒤로 약간 기울임)
                    ally.rotation.x = Math.sin(currentTime / 200) * 0.1;
                } else {
                    // 다른 아군들은 약간 다른 주기로 움직여 자연스러움 증가
                    ally.position.y = 0.5 + Math.sin((currentTime / 500) + index * 0.5) * 0.05;
                }
            });
            
            // 총알 이동
            bullets.forEach(bullet => {
                const direction = bullet.userData.direction;
                bullet.position.x += direction.x * bullet.userData.speed;
                bullet.position.z += direction.z * bullet.userData.speed;
                
                // 총알 회전 효과 추가
                bullet.rotation.x += 0.2;
                bullet.rotation.y += 0.2;
                
                // 화면 밖으로 나간 총알 제거
                if (bullet.position.z < -100) {
                    scene.remove(bullet);
                    bullets.splice(bullets.indexOf(bullet), 1);
                }
            });
            
            // 충돌 체크
            checkCollisions();
            
            // 난이도 증가
            difficulty = 1 + ((60 - gameTime) / 5);
            
            // 도로 속도 증가 (난이도에 따라)
            roadSpeed = 0.5 + (difficulty * 0.05);
        }
        
        // 충돌 체크 함수 - 시각적 효과 추가
        function checkCollisions() {
            // 총알과 적의 충돌
            bullets.forEach(bullet => {
                enemies.forEach(enemy => {
                    const distance = bullet.position.distanceTo(enemy.position);
                    if (distance < 1) {
                        // 충돌 시 폭발 효과
                        createExplosion(enemy.position.clone());
                        
                        // 충돌 발생
                        scene.remove(bullet);
                        scene.remove(enemy);
                        bullets.splice(bullets.indexOf(bullet), 1);
                        enemies.splice(enemies.indexOf(enemy), 1);
                        
                        // 점수 추가
                        score += 10;
                        document.getElementById('score').textContent = score;
                    }
                });
            });
            
            // 플레이어(메인 아군)와 패널의 충돌
            if (allies.length > 0) {
                const player = allies[0];
                
                panels.forEach(panel => {
                    const distance = Math.sqrt(
                        Math.pow(player.position.x - panel.position.x, 2) +
                        Math.pow(player.position.z - panel.position.z, 2)
                    );
                    
                    if (distance < 2) {
                        // 패널과 충돌 - 사칙연산 수행
                        if (panel.userData.result !== undefined) {
                            // 패널 획득 효과
                            createPanelEffect(player.position.clone());
                            
                            createAllies(panel.userData.result);
                            
                            // 보너스 점수
                            score += 50;
                            document.getElementById('score').textContent = score;
                            
                            // 모든 패널 제거
                            panels.forEach(p => scene.remove(p));
                            panels = [];
                            
                            // 연산 초기화
                            document.getElementById('currentEquation').textContent = "없음";
                        }
                    }
                });
                
                // 플레이어와 적의 충돌
                enemies.forEach(enemy => {
                    const distance = player.position.distanceTo(enemy.position);
                    if (distance < 1.2) {
                        // 충돌 시 데미지 효과
                        createDamageEffect(player.position.clone());
                        
                        // 충돌 발생 - 아군 감소
                        if (allies.length > 1) {
                            createAllies(allies.length - 1);
                            
                            // 해당 적 제거
                            scene.remove(enemy);
                            enemies.splice(enemies.indexOf(enemy), 1);
                        } else {
                            // 마지막 아군이 적과 충돌하면 게임 오버
                            endGame();
                        }
                    }
                });
            }
        }
        
        // 폭발 효과 생성 함수
        function createExplosion(position) {
            // 폭발 파티클 그룹
            const explosionGroup = new THREE.Group();
            explosionGroup.position.copy(position);
            
            // 폭발 빛
            const explosionLight = new THREE.PointLight(0xff5500, 3, 8);
            explosionLight.position.set(0, 0, 0);
            explosionGroup.add(explosionLight);
            
            // 파티클 생성
            const particleCount = 10;
            const particles = [];
            
            for (let i = 0; i < particleCount; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const particleMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xff5500, 
                    transparent: true, 
                    opacity: 1
                });
                
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                
                // 랜덤 방향으로 튀어나감
                const angle1 = Math.random() * Math.PI * 2;
                const angle2 = Math.random() * Math.PI * 2;
                
                const speed = 0.1 + Math.random() * 0.2;
                particle.userData.velocity = new THREE.Vector3(
                    Math.sin(angle1) * Math.cos(angle2) * speed,
                    Math.sin(angle1) * Math.sin(angle2) * speed,
                    Math.cos(angle1) * speed
                );
                
                explosionGroup.add(particle);
                particles.push(particle);
            }
            
            scene.add(explosionGroup);
            
            // 0.5초 동안 폭발 애니메이션
            let elapsed = 0;
            const duration = 500; // 밀리초
            const interval = setInterval(() => {
                elapsed += 16;
                
                // 파티클 이동 및 페이드 아웃
                particles.forEach(particle => {
                    particle.position.add(particle.userData.velocity);
                    particle.material.opacity = 1 - (elapsed / duration);
                    particle.scale.multiplyScalar(0.98);
                });
                
                // 빛 감소
                explosionLight.intensity = 3 * (1 - elapsed / duration);
                
                if (elapsed >= duration) {
                    clearInterval(interval);
                    scene.remove(explosionGroup);
                }
            }, 16);
        }
        
        // 패널 획득 효과
        function createPanelEffect(position) {
            // 빛 생성
            const light = new THREE.PointLight(0x00ffff, 3, 10);
            light.position.copy(position);
            scene.add(light);
            
            // 0.5초 동안 빛 효과
            let elapsed = 0;
            const duration = 500; // 밀리초
            const interval = setInterval(() => {
                elapsed += 16;
                
                // 빛 강도 조절
                light.intensity = 3 * (1 - elapsed / duration);
                
                if (elapsed >= duration) {
                    clearInterval(interval);
                    scene.remove(light);
                }
            }, 16);
        }
        
        // 데미지 효과
        function createDamageEffect(position) {
            // 빨간 빛 생성
            const light = new THREE.PointLight(0xff0000, 3, 10);
            light.position.copy(position);
            scene.add(light);
            
            // 화면 빨갛게 깜빡임 (CSS 효과)
            const overlay = document.createElement('div');
            overlay.style.position = 'absolute';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.width = '100%';
            overlay.style.height = '100%';
            overlay.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
            overlay.style.pointerEvents = 'none';
            overlay.style.transition = 'opacity 0.5s';
            document.body.appendChild(overlay);
            
            // 0.5초 동안 효과
            setTimeout(() => {
                overlay.style.opacity = '0';
                setTimeout(() => {
                    document.body.removeChild(overlay);
                }, 500);
            }, 100);
            
            // 빛 효과 제거
            setTimeout(() => {
                scene.remove(light);
            }, 500);
        }
        
        // 게임 타이머 함수
        function startGameTimer() {
            const timerInterval = setInterval(() => {
                if (!gameActive) {
                    clearInterval(timerInterval);
                    return;
                }
                
                gameTime--;
                document.getElementById('timer').textContent = gameTime;
                
                if (gameTime <= 0) {
                    clearInterval(timerInterval);
                    endGame();
                }
            }, 1000);
        }
        
        // 게임 종료 함수
        function endGame() {
            gameActive = false;
            document.getElementById('gameOver').style.display = 'block';
            document.getElementById('finalScore').textContent = score;
            
            // 게임 오버 효과
            const gameOverLight = new THREE.AmbientLight(0xff0000, 0.3);
            scene.add(gameOverLight);
            
            // 모든 아군 회전 애니메이션
            const rotateAllies = () => {
                allies.forEach(ally => {
                    ally.rotation.y += 0.05;
                });
                
                if (gameActive) {
                    return;
                }
                
                requestAnimationFrame(rotateAllies);
            };
            
            rotateAllies();
        }
        
        // 게임 재시작 함수
        function restartGame() {
            // 기존 오브젝트 정리
            allies.forEach(ally => scene.remove(ally));
            enemies.forEach(enemy => scene.remove(enemy));
            bullets.forEach(bullet => scene.remove(bullet));
            panels.forEach(panel => scene.remove(panel));
            
            // 씬의 모든 빛 제거 (게임 오버 효과 제거)
            scene.children.forEach(child => {
                if (child instanceof THREE.Light && !(child instanceof THREE.DirectionalLight) && !(child instanceof THREE.AmbientLight && child.intensity === 0.6)) {
                    scene.remove(child);
                }
            });
            
            allies = [];
            enemies = [];
            bullets = [];
            panels = [];
            
            // 변수 초기화
            gameTime = 60;
            score = 0;
            difficulty = 1;
            gameActive = true;
            lastPanelTime = 0;
            lastEnemyWaveTime = 0;
            playerLane = 1; // 중앙 레인으로 초기화
            isMoving = false;
            roadSpeed = 0.5;
            gameDistance = 0;
            
            // UI 초기화
            document.getElementById('timer').textContent = gameTime;
            document.getElementById('score').textContent = score;
            document.getElementById('currentEquation').textContent = "없음";
            document.getElementById('gameOver').style.display = 'none';
            
            // 기본 조명 재설정
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(0, 20, 10);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // 첫 아군 생성
            createAllies(1);
            
            // 타이머 재시작
            startGameTimer();
        }
        
        // 애니메이션 루프
        function animate() {
            requestAnimationFrame(animate);
            
            if (gameActive) {
                updateGame();
            }
            
            renderer.render(scene, camera);
        }
        
        // 화면 크기 조정 이벤트
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // 게임 시작
        init();
    </script>
</body>
</html>
</antArtifact><antArtifact identifier="enhanced-game" type="application/vnd.ant.code" language="html" title="Enhanced Math Runner 3D Game">
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>러너 3D 슈팅 게임</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: Arial, sans-serif; 
            touch-action: none;
        }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            padding: 5px;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 1px 1px 1px black;
            z-index: 10;
        }
        #equationInfo {
            position: absolute;
            top: 40px;
            width: 100%;
            text-align: center;
            color: #ffcc00;
            padding: 5px;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 1px 1px 1px black;
            z-index: 10;
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none;
            z-index: 20;
        }
        #restartBtn {
            padding: 15px 30px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 18px;
            margin-top: 20px;
        }
        #restartBtn:hover {
            background-color: #45a049;
        }
        #controls {
            position: absolute;
            bottom: 30px;
            width: 100%;
            display: flex;
            justify-content: center;
            z-index: 10;
        }
        .controlBtn {
            width: 80px;
            height: 80px;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 40px;
            margin: 0 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
            user-select: none;
        }
    </style>
</head>
<body>
    <div id="info">아군: <span id="allyCount">1</span> | 시간: <span id="timer">60</span>초 | 점수: <span id="score">0</span></div>
    <div id="equationInfo">현재 패널: <span id="currentEquation">없음</span></div>
    <div id="gameOver">
        <h2>게임 종료!</h2>
        <p>최종 점수: <span id="finalScore">0</span></p>
        <button id="restartBtn">다시 시작</button>
    </div>
    <div id="controls">
        <div id="leftBtn" class="controlBtn">←</div>
        <div id="rightBtn" class="controlBtn">→</div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // 게임 변수
        let scene, camera, renderer, allies = [], enemies = [], bullets = [], panels = [];
        let gameTime = 60; // 1분
        let score = 0;
        let difficulty = 1;
        let gameActive = true;
        let lastPanelTime = 0;
        let lastEnemyWaveTime = 0;
        let lastFireTime = 0;
        let playerLane = 1; // 0: 왼쪽, 1: 중앙, 2: 오른쪽
        let isMoving = false;
        let roadSpeed = 0.5;
        let roadSegments = [];
        let gameDistance = 0;
        let activeEquation = "";
        
        // 레인 위치 정의
        const lanes = [-5, 0, 5];
        
        // 수학 연산자 (각각 강한 네온 색상으로 변경)
        const operators = [
            { symbol: "+", fn: (a, b) => a + b, color: 0x00FFFF, glow: 0x00FFFF }, // 네온 청록색
            { symbol: "-", fn: (a, b) => Math.max(1, a - b), color: 0xFF1493, glow: 0xFF1493 }, // 네온 핑크
            { symbol: "×", fn: (a, b) => a * b, color: 0x39FF14, glow: 0x39FF14 }, // 네온 그린
            { symbol: "÷", fn: (a, b) => Math.round(a / b) || 1, color: 0xFFD700, glow: 0xFFD700 } // 네온 골드
        ];
        
        // 게임 초기화
        function init() {
            // 씬 설정
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e); // 어두운 남색 배경
            
            // 안개 추가 (원근감) - 더 짙게 설정
            scene.fog = new THREE.Fog(0x1a1a2e, 30, 80);
            
            // 카메라 설정
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 8, 12); // 카메라 높이와 거리 조정
            camera.lookAt(0, 0, -20);
            
            // 렌더러 설정
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; // 그림자 활성화
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);
            
            // 조명 설정
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(0, 20, 10);
            directionalLight.castShadow = true; // 그림자 생성
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -20;
            directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20;
            directionalLight.shadow.camera.bottom = -20;
            scene.add(directionalLight);
            
            // 도로 생성
            createRoad();
            
            // 첫 아군 생성
            createAllies(1);
            
            // 이벤트 리스너
            window.addEventListener('resize', onWindowResize);
            document.getElementById('restartBtn').addEventListener('click', restartGame);
            
            // 모바일 컨트롤 초기화
            initControls();
            
            // 게임 타이머 시작
            startGameTimer();
            
            // 게임 루프 시작
            animate();
        }
        
        // 도로 생성 함수
        function createRoad() {
            // 도로 텍스처 (하늘색 그라데이션 패턴으로 변경)
            const roadWidth = 15;
            const roadLength = 1000;
            const segmentLength = 20;
            const segments = roadLength / segmentLength;
            
            // 도로 기본 재질 (네온 효과가 있는 어두운 색상)
            const roadMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x0f3460,
                roughness: 0.5,
                metalness: 0.7,
                emissive: 0x0f3460,
                emissiveIntensity: 0.2
            });
            
            // 도로 경계선 재질 (밝은 네온 색상)
            const lineMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xE94560, 
                emissive: 0xE94560,
                emissiveIntensity: 0.7
            });
            
            // 도로 가장자리 재질 (네온 푸른색)
            const sideMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x16213E,
                emissive: 0x0F52BA,
                emissiveIntensity: 0.3
            });
            
            // 도로 그라데이션을 위한 재질 배열 (네온 효과가 있는 패턴)
            const patternMaterials = [
                new THREE.MeshStandardMaterial({ 
                    color: 0x0f3460, 
                    emissive: 0x0f3460,
                    emissiveIntensity: 0.2
                }),
                new THREE.MeshStandardMaterial({ 
                    color: 0x16213E, 
                    emissive: 0x16213E,
                    emissiveIntensity: 0.2
                })
            ];
            
            // 여러 세그먼트로 도로 생성
            for (let i = 0; i < segments; i++) {
                // 도로 세그먼트 (패턴 적용)
                const roadGeometry = new THREE.PlaneGeometry(roadWidth, segmentLength);
                const road = new THREE.Mesh(roadGeometry, patternMaterials[i % 2]); // 번갈아가며 패턴 적용
                road.rotation.x = -Math.PI / 2;
                road.position.z = -i * segmentLength - segmentLength / 2;
                road.position.y = -0.1;
                road.receiveShadow = true; // 그림자 받기
                scene.add(road);
                roadSegments.push(road);
                
                // 도로 레인 구분선
                for (let j = -1; j <= 1; j += 2) {
                    const lineGeometry = new THREE.PlaneGeometry(0.3, segmentLength);
                    const line = new THREE.Mesh(lineGeometry, lineMaterial);
                    line.rotation.x = -Math.PI / 2;
                    line.position.set(j * roadWidth/6, -0.05, -i * segmentLength - segmentLength / 2);
                    line.receiveShadow = true;
                    scene.add(line);
                    roadSegments.push(line);
                }
                
                // 도로 가장자리
                for (let j = -1; j <= 1; j += 2) {
                    const sideGeometry = new THREE.BoxGeometry(2, 1, segmentLength);
                    const side = new THREE.Mesh(sideGeometry, sideMaterial);
                    side.position.set(j * (roadWidth/2 + 1), 0.4, -i * segmentLength - segmentLength / 2);
                    side.castShadow = true;
                    side.receiveShadow = true;
                    scene.add(side);
                    roadSegments.push(side);
                    
                    // 가드레일 기둥 추가
                    if (i % 2 === 0) {
                        const postGeometry = new THREE.BoxGeometry(0.5, 2, 0.5);
                        const postMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
                        const post = new THREE.Mesh(postGeometry, postMaterial);
                        post.position.set(j * (roadWidth/2 + 1), 1.5, -i * segmentLength - segmentLength / 2);
                        post.castShadow = true;
                        post.receiveShadow = true;
                        scene.add(post);
                        roadSegments.push(post);
                    }
                }
            }
        }
        
        // 도로 스크롤 함수
        function scrollRoad() {
            const resetPos = -1000; // 도로 총 길이
            
            roadSegments.forEach(segment => {
                segment.position.z += roadSpeed;
                
                // 도로 세그먼트가 카메라 뒤로 지나가면 다시 앞으로 재배치
                if (segment.position.z > 20) {
                    segment.position.z = resetPos + (segment.position.z - 20);
                }
            });
            
            // 거리 증가
            gameDistance += roadSpeed;
        }
        
        // 컨트롤 초기화
        function initControls() {
            const leftBtn = document.getElementById('leftBtn');
            const rightBtn = document.getElementById('rightBtn');
            
            // 터치 이벤트
            leftBtn.addEventListener('touchstart', moveLeft);
            rightBtn.addEventListener('touchstart', moveRight);
            
            // 마우스 이벤트 (데스크톱용)
            leftBtn.addEventListener('mousedown', moveLeft);
            rightBtn.addEventListener('mousedown', moveRight);
            
            // 키보드 이벤트
            window.addEventListener('keydown', function(e) {
                if (!gameActive || isMoving) return;
                
                if (e.key === 'ArrowLeft') {
                    moveLeft();
                } else if (e.key === 'ArrowRight') {
                    moveRight();
                }
            });
            
            function moveLeft() {
                if (!gameActive || isMoving || playerLane === 0) return;
                
                isMoving = true;
                playerLane--;
                moveAlliesTo(lanes[playerLane]);
            }
            
            function moveRight() {
                if (!gameActive || isMoving || playerLane === 2) return;
                
                isMoving = true;
                playerLane++;
                moveAlliesTo(lanes[playerLane]);
            }
        }
        
        // 아군 이동 함수
        function moveAlliesTo(targetX) {
            // 0.3초에 걸쳐 부드럽게 이동
            const frames = 15; // 60fps 기준 0.25초
            let currentFrame = 0;
            
            // 메인 아군 현재 위치
            const startX = allies[0].position.x;
            const moveAmount = (targetX - startX) / frames;
            
            const moveInterval = setInterval(() => {
                if (currentFrame >= frames) {
                    clearInterval(moveInterval);
                    isMoving = false;
                    return;
                }
                
                // 모든 아군 이동
                allies.forEach((ally, index) => {
                    if (index === 0) {
                        // 메인 아군
                        ally.position.x += moveAmount;
                    } else {
                        // 나머지 아군들은 메인 아군을 따라감
                        updateAllyFormation();
                    }
                });
                
                currentFrame++;
            }, 1000/60); // 60fps
        }
        
        // 아군 진형 업데이트
        function updateAllyFormation() {
            if (allies.length <= 1) return;
            
            const mainAlly = allies[0];
            const allyCount = allies.length;
            
            // 진영 크기 계산 - 아군이 많을수록 더 넓게 퍼짐
            const formationWidth = Math.min(3, 0.5 + (allyCount * 0.1));
            const formationDepth = Math.min(4, 1 + (allyCount * 0.15));
            
            for (let i = 1; i < allyCount; i++) {
                // 균등하게 분포된 위치 계산
                let row = Math.floor((i-1) / 3);
                let col = (i-1) % 3;
                
                // 중앙 정렬을 위한 오프셋
                let colOffset = col - 1; // -1, 0, 1
                let rowOffset = -row; // 항상 플레이어 뒤에 배치
                
                allies[i].position.x = mainAlly.position.x + (colOffset * formationWidth);
                allies[i].position.z = mainAlly.position.z + (rowOffset * formationDepth);
            }
        }
        
        // 아군 생성 함수 - 캐릭터 디자인 개선
        function createAllies(count) {
            // 기존 아군 제거
            allies.forEach(ally => scene.remove(ally));
            allies = [];
            
            // 최댓값 제한 (너무 많으면 게임이 쉬워짐)
            count = Math.min(count, 30);
            
            // 새 아군 생성 - 귀여운 오렌지색 캐릭터로 변경
            for (let i = 0; i < count; i++) {
                // 캐릭터 그룹
                const character = new THREE.Group();
                
                // 몸체 (구)
                const bodyGeometry = new THREE.SphereGeometry(0.5, 16, 16);
                const bodyMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFF9900, // 오렌지색
                    emissive: 0xAA5500,
                    emissiveIntensity: 0.2,
                    roughness: 0.7
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.castShadow = true;
                body.receiveShadow = true;
                character.add(body);
                
                // 캐릭터에 눈 추가
                const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
                
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(0.2, 0.2, 0.4);
                character.add(leftEye);
                
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(-0.2, 0.2, 0.4);
                character.add(rightEye);
                
                // 눈동자
                const pupilGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                const pupilMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
                
                const leftPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                leftPupil.position.set(0.2, 0.2, 0.45);
                character.add(leftPupil);
                
                const rightPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                rightPupil.position.set(-0.2, 0.2, 0.45);
                character.add(rightPupil);
                
                // 팔과 다리 추가 (메인 캐릭터만)
                if (i === 0) {
                    // 팔
                    const armGeometry = new THREE.SphereGeometry(0.15, 8, 8);
                    
                    const leftArm = new THREE.Mesh(armGeometry, bodyMaterial);
                    leftArm.position.set(0.6, 0, 0);
                    leftArm.castShadow = true;
                    character.add(leftArm);
                    
                    const rightArm = new THREE.Mesh(armGeometry, bodyMaterial);
                    rightArm.position.set(-0.6, 0, 0);
                    rightArm.castShadow = true;
                    character.add(rightArm);
                    
                    // 다리
                    const legGeometry = new THREE.CylinderGeometry(0.15, 0.1, 0.5, 8);
                    
                    const leftLeg = new THREE.Mesh(legGeometry, bodyMaterial);
                    leftLeg.position.set(0.2, -0.5, 0);
                    leftLeg.castShadow = true;
                    character.add(leftLeg);
                    
                    const rightLeg = new THREE.Mesh(legGeometry, bodyMaterial);
                    rightLeg.position.set(-0.2, -0.5, 0);
                    rightLeg.castShadow = true;
                    character.add(rightLeg);
                }
                
                if (i === 0) {
                    // 메인 아군 (플레이어)
                    character.position.set(lanes[playerLane], 0.5, 0);
                } else {
                    // 추가 아군들은 초기 위치만 설정 (updateAllyFormation에서 정확히 배치됨)
                    character.position.set(lanes[playerLane], 0.5, -i);
                    // 작게 만들기
                    character.scale.set(0.8, 0.8, 0.8);
                }
                
                scene.add(character);
                allies.push(character);
            }
            
            // 진형 업데이트
            updateAllyFormation();
            
            // UI 업데이트
            document.getElementById('allyCount').textContent = allies.length;
        }
        
        // 적 생성 함수 - 웨이브 형태로 생성
        function createEnemyWave() {
            const waveType = Math.floor(Math.random() * 4);
            
            switch (waveType) {
                case 0: // 일렬 웨이브
                    const randomLane = Math.floor(Math.random() * 3);
                    for (let i = 0; i < 5 + Math.floor(difficulty); i++) {
                        createEnemy(randomLane, -80 - (i * 4));
                    }
                    break;
                    
                case 1: // V 형태 웨이브
                    for (let i = 0; i < 7; i++) {
                        const laneOffset = (i <= 3) ? i : 6 - i; // 0,1,2,3,2,1,0
                        createEnemy(laneOffset, -80 - (i * 3));
                    }
                    break;
                    
                case 2: // 모든 레인 웨이브
                    for (let i = 0; i < 3; i++) {
                        for (let j = 0; j < 3; j++) {
                            createEnemy(j, -80 - (i * 5));
                        }
                    }
                    break;
                    
                case 3: // 랜덤 웨이브
                    const enemyCount = 5 + Math.floor(difficulty * 2);
                    for (let i = 0; i < enemyCount; i++) {
                        const randLane = Math.floor(Math.random() * 3);
                        const randDist = -80 - (Math.random() * 20);
                        createEnemy(randLane, randDist);
                    }
                    break;
            }
            
            function createEnemy(lane, zPos) {
                // 적 그룹
                const enemy = new THREE.Group();
                
                // 적 몸체 (기본 모양)
                const enemyGeometry = new THREE.SphereGeometry(0.5, 16, 16);
                const enemyMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xff0000,
                    emissive: 0xaa0000,
                    emissiveIntensity: 0.3,
                    roughness: 0.6
                });
                const body = new THREE.Mesh(enemyGeometry, enemyMaterial);
                body.castShadow = true;
                body.receiveShadow = true;
                enemy.add(body);
                
                // 적 눈 (흰색)
                const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
                
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(0.2, 0.2, 0.4);
                enemy.add(leftEye);
                
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(-0.2, 0.2, 0.4);
                enemy.add(rightEye);
                
                // 적 눈동자 (검은색)
                const pupilGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                const pupilMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
                
                const leftPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                leftPupil.position.set(0.2, 0.2, 0.45);
                enemy.add(leftPupil);
                
                const rightPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                rightPupil.position.set(-0.2, 0.2, 0.45);
                enemy.add(rightPupil);
                
                enemy.position.set(lanes[lane], 0.5, zPos);
                scene.add(enemy);
                enemies.push(enemy);
            }
        }
        
        // 총알 발사 함수
        function fireBullets() {
            const currentTime = Date.now();
            
            // 자동 발사 간격 (아군 수에 따라 감소)
            const fireInterval = Math.max(100, 500 - (allies.length * 10));
            
            if (currentTime - lastFireTime < fireInterval) return;
            
            lastFireTime = currentTime;
            
            // 아군 수에 비례해서 총알 발사 (아군당 0.5발의 총알)
            const bulletsToFire = Math.max(1, Math.ceil(allies.length * 0.5));
            
            for (let i = 0; i < bulletsToFire; i++) {
                const bulletGeometry = new THREE.SphereGeometry(0.2, 8, 8);
                const bulletMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xffff00, 
                    emissive: 0xffff00,
                    emissiveIntensity: 0.8
                });
                const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
                
                // 총알 발사 방향 다각화
                let angleOffset = 0;
                if (bulletsToFire > 1) {
                    // 부채꼴 형태로 퍼지게 발사
                    const spreadFactor = Math.min(0.3, bulletsToFire * 0.02);  // 최대 0.3 라디안 (약 17도)
                    angleOffset = spreadFactor * ((i / (bulletsToFire - 1)) * 2 - 1);
                }
                
                // 총알 위치는 무작위 아군 위치에서 시작
                const shooterIndex = Math.floor(Math.random() * allies.length);
                bullet.position.copy(allies[shooterIndex].position);
                bullet.position.z -= 1; // 약간 앞에서 발사
                
                // 총알 방향 설정
                bullet.userData.direction = new THREE.Vector3(angleOffset, 0, -1).normalize();
                bullet.userData.speed = 1.5;
                
                scene.add(bullet);
                bullets.push(bullet);
                
                // 총알 발사 이펙트 (빛)
                const bulletLight = new THREE.PointLight(0xffff00, 2, 5);
                bulletLight.position.copy(bullet.position);
                scene.add(bulletLight);
                
                // 0.1초 후 이펙트 제거
                setTimeout(() => {
                    scene.remove(bulletLight);
                }, 100);
            }
        }
        
        // 사칙연산 패널 생성 함수
        function createMathPanels() {
            // 기존 패널 제거
            panels.forEach(panel => scene.remove(panel));
            panels = [];
            
            // 랜덤 연산자 선택
            const operator = operators[Math.floor(Math.random() * operators.length)];
            
            // 피연산자 선택 (난이도에 따라 증가)
            const operand = Math.floor(Math.random() * Math.min(5, difficulty)) + 1;
            
            // 현재 아군 수와 연산 결과 계산
            const currentAllies = allies.length;
            const result = operator.fn(currentAllies, operand);
            
            // 연산 표시 업데이트
            activeEquation = `${currentAllies} ${operator.symbol} ${operand} = ${result}`;
            document.getElementById('currentEquation').textContent = activeEquation;
            
            // 도로 세 레인에 패널 생성
            for (let i = 0; i < 3; i++) {
                createMathPanel(lanes[i], -60 - Math.random() * 10, operand, operator);
            }
            
            function createMathPanel(x, z, operand, operator) {
                // 패널 그룹
                const panel = new THREE.Group();
                
                // 패널 플랫폼
                const panelGeometry = new THREE.BoxGeometry(3, 0.3, 3);
                
                // 연산자에 맞는 색상 적용 (강한 네온 효과)
                const panelMaterial = new THREE.MeshStandardMaterial({ 
                    color: operator.color,
                    emissive: operator.glow,
                    emissiveIntensity: 0.8,
                    transparent: true,
                    opacity: 0.9
                });
                
                const panelMesh = new THREE.Mesh(panelGeometry, panelMaterial);
                panelMesh.castShadow = true;
                panelMesh.receiveShadow = true;
                panel.add(panelMesh);
                
                // 패널에 숫자 표시를 위한 텍스트 (Three.js에서는 실제 텍스트 렌더링이 어려워 대체 표현)
                const operatorSymbol = operator.symbol;
                const operatorTextGeometry = new THREE.BoxGeometry(1, 0.1, 1);
                const operatorTextMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFFFFFF,
                    emissive: 0xFFFFFF,
                    emissiveIntensity: 0.5
                });
                
                const operatorText = new THREE.Mesh(operatorTextGeometry, operatorTextMaterial);
                operatorText.position.y = 0.2;
                panel.add(operatorText);
                
                // 숫자 표시 (간소화된 형태)
                const numberGeometry = new THREE.BoxGeometry(0.5, 0.1, 0.5);
                const numberMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
                const numberMesh = new THREE.Mesh(numberGeometry, numberMaterial);
                numberMesh.position.set(0, 0.2, 0.5);
                panel.add(numberMesh);
                
                // 패널 위치 설정
                panel.position.set(x, 0, z);
                
                // 패널에 연산 데이터 추가
                panel.userData = {
                    operator: operatorSymbol,
                    operand: operand,
                    result: result
                };
                
                // 패널 발광 효과
                const panelLight = new THREE.PointLight(operator.color, 1, 5);
                panelLight.position.set(0, 0.5, 0);
                panel.add(panelLight);
                
                scene.add(panel);
                panels.push(panel);
            }
        }
        
        // 게임 업데이트 함수
        function updateGame() {
            const currentTime = Date.now();
            
            // 도로 스크롤
            scrollRoad();
            
            // 3초마다 패널 생성
            if (currentTime - lastPanelTime > 3000) {
                createMathPanels();
                lastPanelTime = currentTime;
            }
            
            // 난이도에 따라 적 웨이브 생성 주기 조절
            const enemyWaveInterval = Math.max(2000, 5000 - (difficulty * 300));
            if (currentTime - lastEnemyWaveTime > enemyWaveInterval) {
                createEnemyWave();
                lastEnemyWaveTime = currentTime;
            }
            
            // 자동 총알 발사
            fireBullets();
            
            // 패널 이동 (도로와 함께 이동)
            panels.forEach(panel => {
                panel.position.z += roadSpeed;
                
                // 화면 끝에 도달한 패널은 제거
                if (panel.position.z > 10) {
                    scene.remove(panel);
                    panels.splice(panels.indexOf(panel), 1);
                    
                    // 모든 패널이 사라졌을 때 현재 연산 초기화
                    if (panels.length === 0) {
                        document.getElementById('currentEquation').textContent = "없음";
                    }
                }
            });
            
            // 적 이동 (도로와 함께 이동, 약간 더 빠르게)
            enemies.forEach(enemy => {
                enemy.position.z += roadSpeed * 1.2;
                
                // 화면 끝에 도달한 적은 제거
                if (enemy.position.z > 10) {
                    scene.remove(enemy);
                    enemies.splice(enemies.indexOf(enemy), 1);
                }
                
                // 적 애니메이션 (약간 상하로 움직임)
                enemy.position.y = 0.5 + Math.sin(currentTime / 300 + enemy.position.z) * 0.1;
                
                // 추가: 적 회전 애니메이션
                enemy.rotation.y += 0.02;
            });
            
            // 아군 애니메이션 (약간 위아래로 움직임)
            allies.forEach((ally, index) => {
                // 메인 캐릭터 (0번 인덱스)만 특별한 애니메이션 적용
                if (index === 0) {
                    ally.position.y = 0.5 + Math.sin(currentTime / 500) * 0.05;
                    
                    // 달리기 애니메이션 효과 (앞뒤로 약간 기울임)
                    ally.rotation.x = Math.sin(currentTime / 200) * 0.1;
                } else {
                    // 다른 아군들은 약간 다른 주기로 움직여 자연스러움 증가
                    ally.position.y = 0.5 + Math.sin((currentTime / 500) + index * 0.5) * 0.05;
                }
            });
            
            // 총알 이동
            bullets.forEach(bullet => {
                const direction = bullet.userData.direction;
                bullet.position.x += direction.x * bullet.userData.speed;
                bullet.position.z += direction.z * bullet.userData.speed;
                
                // 총알 회전 효과 추가
                bullet.rotation.x += 0.2;
                bullet.rotation.y += 0.2;
                
                // 화면 밖으로 나간 총알 제거
                if (bullet.position.z < -100) {
                    scene.remove(bullet);
                    bullets.splice(bullets.indexOf(bullet), 1);
                }
            });
            
            // 충돌 체크
            checkCollisions();
            
            // 난이도 증가
            difficulty = 1 + ((60 - gameTime) / 5);
            
            // 도로 속도 증가 (난이도에 따라)
            roadSpeed = 0.5 + (difficulty * 0.05);
        }
        
        // 충돌 체크 함수 - 시각적 효과 추가
        function checkCollisions() {
            // 총알과 적의 충돌
            bullets.forEach(bullet => {
                enemies.forEach(enemy => {
                    const distance = bullet.position.distanceTo(enemy.position);
                    if (distance < 1) {
                        // 충돌 시 폭발 효과
                        createExplosion(enemy.position.clone());
                        
                        // 충돌 발생
                        scene.remove(bullet);
                        scene.remove(enemy);
                        bullets.splice(bullets.indexOf(bullet), 1);
                        enemies.splice(enemies.indexOf(enemy), 1);
                        
                        // 점수 추가
                        score += 10;
                        document.getElementById('score').textContent = score;
                    }
                });
            });
            
            // 플레이어(메인 아군)와 패널의 충돌
            if (allies.length > 0) {
                const player = allies[0];
                
                panels.forEach(panel => {
                    const distance = Math.sqrt(
                        Math.pow(player.position.x - panel.position.x, 2) +
                        Math.pow(player.position.z - panel.position.z, 2)
                    );
                    
                    if (distance < 2) {
                        // 패널과 충돌 - 사칙연산 수행
                        if (panel.userData.result !== undefined) {
                            // 패널 획득 효과
                            createPanelEffect(player.position.clone());
                            
                            createAllies(panel.userData.result);
                            
                            // 보너스 점수
                            score += 50;
                            document.getElementById('score').textContent = score;
                            
                            // 모든 패널 제거
                            panels.forEach(p => scene.remove(p));
                            panels = [];
                            
                            // 연산 초기화
                            document.getElementById('currentEquation').textContent = "없음";
                        }
                    }
                });
                
                // 플레이어와 적의 충돌
                enemies.forEach(enemy => {
                    const distance = player.position.distanceTo(enemy.position);
                    if (distance < 1.2) {
                        // 충돌 시 데미지 효과
                        createDamageEffect(player.position.clone());
                        
                        // 충돌 발생 - 아군 감소
                        if (allies.length > 1) {
                            createAllies(allies.length - 1);
                            
                            // 해당 적 제거
                            scene.remove(enemy);
                            enemies.splice(enemies.indexOf(enemy), 1);
                        } else {
                            // 마지막 아군이 적과 충돌하면 게임 오버
                            endGame();
                        }
                    }
                });
            }
        }
        
        // 폭발 효과 생성 함수
        function createExplosion(position) {
            // 폭발 파티클 그룹
            const explosionGroup = new THREE.Group();
            explosionGroup.position.copy(position);
            
            // 폭발 빛
            const explosionLight = new THREE.PointLight(0xff5500, 3, 8);
            explosionLight.position.set(0, 0, 0);
            explosionGroup.add(explosionLight);
            
            // 파티클 생성
            const particleCount = 10;
            const particles = [];
            
            for (let i = 0; i < particleCount; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const particleMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xff5500, 
                    transparent: true, 
                    opacity: 1
                });
                
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                
                // 랜덤 방향으로 튀어나감
                const angle1 = Math.random() * Math.PI * 2;
                const angle2 = Math.random() * Math.PI * 2;
                
                const speed = 0.1 + Math.random() * 0.2;
                particle.userData.velocity = new THREE.Vector3(
                    Math.sin(angle1) * Math.cos(angle2) * speed,
                    Math.sin(angle1) * Math.sin(angle2) * speed,
                    Math.cos(angle1) * speed
                );
                
                explosionGroup.add(particle);
                particles.push(particle);
            }
            
            scene.add(explosionGroup);
            
            // 0.5초 동안 폭발 애니메이션
            let elapsed = 0;
            const duration = 500; // 밀리초
            const interval = setInterval(() => {
                elapsed += 16;
                
                // 파티클 이동 및 페이드 아웃
                particles.forEach(particle => {
                    particle.position.add(particle.userData.velocity);
                    particle.material.opacity = 1 - (elapsed / duration);
                    particle.scale.multiplyScalar(0.98);
                });
                
                // 빛 감소
                explosionLight.intensity = 3 * (1 - elapsed / duration);
                
                if (elapsed >= duration) {
                    clearInterval(interval);
                    scene.remove(explosionGroup);
                }
            }, 16);
        }
        
        // 패널 획득 효과
        function createPanelEffect(position) {
            // 빛 생성
            const light = new THREE.PointLight(0x00ffff, 3, 10);
            light.position.copy(position);
            scene.add(light);
            
            // 0.5초 동안 빛 효과
            let elapsed = 0;
            const duration = 500; // 밀리초
            const interval = setInterval(() => {
                elapsed += 16;
                
                // 빛 강도 조절
                light.intensity = 3 * (1 - elapsed / duration);
                
                if (elapsed >= duration) {
                    clearInterval(interval);
                    scene.remove(light);
                }
            }, 16);
        }
        
        // 데미지 효과
        function createDamageEffect(position) {
            // 빨간 빛 생성
            const light = new THREE.PointLight(0xff0000, 3, 10);
            light.position.copy(position);
            scene.add(light);
            
            // 화면 빨갛게 깜빡임 (CSS 효과)
            const overlay = document.createElement('div');
            overlay.style.position = 'absolute';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.width = '100%';
            overlay.style.height = '100%';
            overlay.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
            overlay.style.pointerEvents = 'none';
            overlay.style.transition = 'opacity 0.5s';
            document.body.appendChild(overlay);
            
            // 0.5초 동안 효과
            setTimeout(() => {
                overlay.style.opacity = '0';
                setTimeout(() => {
                    document.body.removeChild(overlay);
                }, 500);
            }, 100);
            
            // 빛 효과 제거
            setTimeout(() => {
                scene.remove(light);
            }, 500);
        }
        
        // 게임 타이머 함수
        function startGameTimer() {
            const timerInterval = setInterval(() => {
                if (!gameActive) {
                    clearInterval(timerInterval);
                    return;
                }
                
                gameTime--;
                document.getElementById('timer').textContent = gameTime;
                
                if (gameTime <= 0) {
                    clearInterval(timerInterval);
                    endGame();
                }
            }, 1000);
        }
        
        // 게임 종료 함수
        function endGame() {
            gameActive = false;
            document.getElementById('gameOver').style.display = 'block';
            document.getElementById('finalScore').textContent = score;
            
            // 게임 오버 효과
            const gameOverLight = new THREE.AmbientLight(0xff0000, 0.3);
            scene.add(gameOverLight);
            
            // 모든 아군 회전 애니메이션
            const rotateAllies = () => {
                allies.forEach(ally => {
                    ally.rotation.y += 0.05;
                });
                
                if (gameActive) {
                    return;
                }
                
                requestAnimationFrame(rotateAllies);
            };
            
            rotateAllies();
        }
        
        // 게임 재시작 함수
        function restartGame() {
            // 기존 오브젝트 정리
            allies.forEach(ally => scene.remove(ally));
            enemies.forEach(enemy => scene.remove(enemy));
            bullets.forEach(bullet => scene.remove(bullet));
            panels.forEach(panel => scene.remove(panel));
            
            // 씬의 모든 빛 제거 (게임 오버 효과 제거)
            scene.children.forEach(child => {
                if (child instanceof THREE.Light && !(child instanceof THREE.DirectionalLight) && !(child instanceof THREE.AmbientLight && child.intensity === 0.6)) {
                    scene.remove(child);
                }
            });
            
            allies = [];
            enemies = [];
            bullets = [];
            panels = [];
            
            // 변수 초기화
            gameTime = 60;
            score = 0;
            difficulty = 1;
            gameActive = true;
            lastPanelTime = 0;
            lastEnemyWaveTime = 0;
            playerLane = 1; // 중앙 레인으로 초기화
            isMoving = false;
            roadSpeed = 0.5;
            gameDistance = 0;
            
            // UI 초기화
            document.getElementById('timer').textContent = gameTime;
            document.getElementById('score').textContent = score;
            document.getElementById('currentEquation').textContent = "없음";
            document.getElementById('gameOver').style.display = 'none';
            
            // 기본 조명 재설정
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(0, 20, 10);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // 첫 아군 생성
            createAllies(1);
            
            // 타이머 재시작
            startGameTimer();
        }
        
        // 애니메이션 루프
        function animate() {
            requestAnimationFrame(animate);
            
            if (gameActive) {
                updateGame();
            }
            
            renderer.render(scene, camera);
        }
        
        // 화면 크기 조정 이벤트
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // 게임 시작
        init();
    </script>
</body>
</html>
</antArtifact><antArtifact identifier="enhanced-game" type="application/vnd.ant.code" language="html" title="Enhanced Math Runner 3D Game">
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>러너 3D 슈팅 게임</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: Arial, sans-serif; 
            touch-action: none;
        }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            padding: 5px;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 1px 1px 1px black;
            z-index: 10;
        }
        #equationInfo {
            position: absolute;
            top: 40px;
            width: 100%;
            text-align: center;
            color: #ffcc00;
            padding: 5px;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 1px 1px 1px black;
            z-index: 10;
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none;
            z-index: 20;
        }
        #restartBtn {
            padding: 15px 30px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 18px;
            margin-top: 20px;
        }
        #restartBtn:hover {
            background-color: #45a049;
        }
        #controls {
            position: absolute;
            bottom: 30px;
            width: 100%;
            display: flex;
            justify-content: center;
            z-index: 10;
        }
        .controlBtn {
            width: 80px;
            height: 80px;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 40px;
            margin: 0 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
            user-select: none;
        }
    </style>
</head>
<body>
    <div id="info">아군: <span id="allyCount">1</span> | 시간: <span id="timer">60</span>초 | 점수: <span id="score">0</span></div>
    <div id="equationInfo">현재 패널: <span id="currentEquation">없음</span></div>
    <div id="gameOver">
        <h2>게임 종료!</h2>
        <p>최종 점수: <span id="finalScore">0</span></p>
        <button id="restartBtn">다시 시작</button>
    </div>
    <div id="controls">
        <div id="leftBtn" class="controlBtn">←</div>
        <div id="rightBtn" class="controlBtn">→</div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // 게임 변수
        let scene, camera, renderer, allies = [], enemies = [], bullets = [], panels = [];
        let gameTime = 60; // 1분
        let score = 0;
        let difficulty = 1;
        let gameActive = true;
        let lastPanelTime = 0;
        let lastEnemyWaveTime = 0;
        let lastFireTime = 0;
        let playerLane = 1; // 0: 왼쪽, 1: 중앙, 2: 오른쪽
        let isMoving = false;
        let roadSpeed = 0.5;
        let roadSegments = [];
        let gameDistance = 0;
        let activeEquation = "";
        
        // 레인 위치 정의
        const lanes = [-5, 0, 5];
        
        // 수학 연산자 (각각 강한 네온 색상으로 변경)
        const operators = [
            { symbol: "+", fn: (a, b) => a + b, color: 0x00FFFF, glow: 0x00FFFF }, // 네온 청록색
            { symbol: "-", fn: (a, b) => Math.max(1, a - b), color: 0xFF1493, glow: 0xFF1493 }, // 네온 핑크
            { symbol: "×", fn: (a, b) => a * b, color: 0x39FF14, glow: 0x39FF14 }, // 네온 그린
            { symbol: "÷", fn: (a, b) => Math.round(a / b) || 1, color: 0xFFD700, glow: 0xFFD700 } // 네온 골드
        ];
        
        // 게임 초기화
        function init() {
            // 씬 설정
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e); // 어두운 남색 배경
            
            // 안개 추가 (원근감) - 더 짙게 설정
            scene.fog = new THREE.Fog(0x1a1a2e, 30, 80);
            
            // 카메라 설정
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 8, 12); // 카메라 높이와 거리 조정
            camera.lookAt(0, 0, -20);
            
            // 렌더러 설정
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; // 그림자 활성화
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);
            
            // 조명 설정
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(0, 20, 10);
            directionalLight.castShadow = true; // 그림자 생성
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -20;
            directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20;
            directionalLight.shadow.camera.bottom = -20;
            scene.add(directionalLight);
            
            // 도로 생성
            createRoad();
            
            // 첫 아군 생성
            createAllies(1);
            
            // 이벤트 리스너
            window.addEventListener('resize', onWindowResize);
            document.getElementById('restartBtn').addEventListener('click', restartGame);
            
            // 모바일 컨트롤 초기화
            initControls();
            
            // 게임 타이머 시작
            startGameTimer();
            
            // 게임 루프 시작
            animate();
        }
        
        // 도로 생성 함수
        function createRoad() {
            // 도로 텍스처 (하늘색 그라데이션 패턴으로 변경)
            const roadWidth = 15;
            const roadLength = 1000;
            const segmentLength = 20;
            const segments = roadLength / segmentLength;
            
            // 도로 기본 재질 (네온 효과가 있는 어두운 색상)
            const roadMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x0f3460,
                roughness: 0.5,
                metalness: 0.7,
                emissive: 0x0f3460,
                emissiveIntensity: 0.2
            });
            
            // 도로 경계선 재질 (밝은 네온 색상)
            const lineMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xE94560, 
                emissive: 0xE94560,
                emissiveIntensity: 0.7
            });
            
            // 도로 가장자리 재질 (네온 푸른색)
            const sideMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x16213E,
                emissive: 0x0F52BA,
                emissiveIntensity: 0.3
            });
            
            // 도로 그라데이션을 위한 재질 배열 (네온 효과가 있는 패턴)
            const patternMaterials = [
                new THREE.MeshStandardMaterial({ 
                    color: 0x0f3460, 
                    emissive: 0x0f3460,
                    emissiveIntensity: 0.2
                }),
                new THREE.MeshStandardMaterial({ 
                    color: 0x16213E, 
                    emissive: 0x16213E,
                    emissiveIntensity: 0.2
                })
            ];
            
            // 여러 세그먼트로 도로 생성
            for (let i = 0; i < segments; i++) {
                // 도로 세그먼트 (패턴 적용)
                const roadGeometry = new THREE.PlaneGeometry(roadWidth, segmentLength);
                const road = new THREE.Mesh(roadGeometry, patternMaterials[i % 2]); // 번갈아가며 패턴 적용
                road.rotation.x = -Math.PI / 2;
                road.position.z = -i * segmentLength - segmentLength / 2;
                road.position.y = -0.1;
                road.receiveShadow = true; // 그림자 받기
                scene.add(road);
                roadSegments.push(road);
                
                // 도로 레인 구분선
                for (let j = -1; j <= 1; j += 2) {
                    const lineGeometry = new THREE.PlaneGeometry(0.3, segmentLength);
                    const line = new THREE.Mesh(lineGeometry, lineMaterial);
                    line.rotation.x = -Math.PI / 2;
                    line.position.set(j * roadWidth/6, -0.05, -i * segmentLength - segmentLength / 2);
                    line.receiveShadow = true;
                    scene.add(line);
                    roadSegments.push(line);
                }
                
                // 도로 가장자리
                for (let j = -1; j <= 1; j += 2) {
                    const sideGeometry = new THREE.BoxGeometry(2, 1, segmentLength);
                    const side = new THREE.Mesh(sideGeometry, sideMaterial);
                    side.position.set(j * (roadWidth/2 + 1), 0.4, -i * segmentLength - segmentLength / 2);
                    side.castShadow = true;
                    side.receiveShadow = true;
                    scene.add(side);
                    roadSegments.push(side);
                    
                    // 가드레일 기둥 추가
                    if (i % 2 === 0) {
                        const postGeometry = new THREE.BoxGeometry(0.5, 2, 0.5);
                        const postMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
                        const post = new THREE.Mesh(postGeometry, postMaterial);
                        post.position.set(j * (roadWidth/2 + 1), 1.5, -i * segmentLength - segmentLength / 2);
                        post.castShadow = true;
                        post.receiveShadow = true;
                        scene.add(post);
                        roadSegments.push(post);
                    }
                }
            }
        }
        
        // 도로 스크롤 함수
        function scrollRoad() {
            const resetPos = -1000; // 도로 총 길이
            
            roadSegments.forEach(segment => {
                segment.position.z += roadSpeed;
                
                // 도로 세그먼트가 카메라 뒤로 지나가면 다시 앞으로 재배치
                if (segment.position.z > 20) {
                    segment.position.z = resetPos + (segment.position.z - 20);
                }
            });
            
            // 거리 증가
            gameDistance += roadSpeed;
        }
        
        // 컨트롤 초기화
        function initControls() {
            const leftBtn = document.getElementById('leftBtn');
            const rightBtn = document.getElementById('rightBtn');
            
            // 터치 이벤트
            leftBtn.addEventListener('touchstart', moveLeft);
            rightBtn.addEventListener('touchstart', moveRight);
            
            // 마우스 이벤트 (데스크톱용)
            leftBtn.addEventListener('mousedown', moveLeft);
            rightBtn.addEventListener('mousedown', moveRight);
            
            // 키보드 이벤트
            window.addEventListener('keydown', function(e) {
                if (!gameActive || isMoving) return;
                
                if (e.key === 'ArrowLeft') {
                    moveLeft();
                } else if (e.key === 'ArrowRight') {
                    moveRight();
                }
            });
            
            function moveLeft() {
                if (!gameActive || isMoving || playerLane === 0) return;
                
                isMoving = true;
                playerLane--;
                moveAlliesTo(lanes[playerLane]);
            }
            
            function moveRight() {
                if (!gameActive || isMoving || playerLane === 2) return;
                
                isMoving = true;
                playerLane++;
                moveAlliesTo(lanes[playerLane]);
            }
        }
        
        // 아군 이동 함수
        function moveAlliesTo(targetX) {
            // 0.3초에 걸쳐 부드럽게 이동
            const frames = 15; // 60fps 기준 0.25초
            let currentFrame = 0;
            
            // 메인 아군 현재 위치
            const startX = allies[0].position.x;
            const moveAmount = (targetX - startX) / frames;
            
            const moveInterval = setInterval(() => {
                if (currentFrame >= frames) {
                    clearInterval(moveInterval);
                    isMoving = false;
                    return;
                }
                
                // 모든 아군 이동
                allies.forEach((ally, index) => {
                    if (index === 0) {
                        // 메인 아군
                        ally.position.x += moveAmount;
                    } else {
                        // 나머지 아군들은 메인 아군을 따라감
                        updateAllyFormation();
                    }
                });
                
                currentFrame++;
            }, 1000/60); // 60fps
        }
        
        // 아군 진형 업데이트
        function updateAllyFormation() {
            if (allies.length <= 1) return;
            
            const mainAlly = allies[0];
            const allyCount = allies.length;
            
            // 진영 크기 계산 - 아군이 많을수록 더 넓게 퍼짐
            const formationWidth = Math.min(3, 0.5 + (allyCount * 0.1));
            const formationDepth = Math.min(4, 1 + (allyCount * 0.15));
            
            for (let i = 1; i < allyCount; i++) {
                // 균등하게 분포된 위치 계산
                let row = Math.floor((i-1) / 3);
                let col = (i-1) % 3;
                
                // 중앙 정렬을 위한 오프셋
                let colOffset = col - 1; // -1, 0, 1
                let rowOffset = -row; // 항상 플레이어 뒤에 배치
                
                allies[i].position.x = mainAlly.position.x + (colOffset * formationWidth);
                allies[i].position.z = mainAlly.position.z + (rowOffset * formationDepth);
            }
        }
        
        // 아군 생성 함수 - 캐릭터 디자인 개선
        function createAllies(count) {
            // 기존 아군 제거
            allies.forEach(ally => scene.remove(ally));
            allies = [];
            
            // 최댓값 제한 (너무 많으면 게임이 쉬워짐)
            count = Math.min(count, 30);
            
            // 새 아군 생성 - 귀여운 오렌지색 캐릭터로 변경
            for (let i = 0; i < count; i++) {
                // 캐릭터 그룹
                const character = new THREE.Group();
                
                // 몸체 (구)
                const bodyGeometry = new THREE.SphereGeometry(0.5, 16, 16);
                const bodyMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFF9900, // 오렌지색
                    emissive: 0xAA5500,
                    emissiveIntensity: 0.2,
                    roughness: 0.7
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.castShadow = true;
                body.receiveShadow = true;
                character.add(body);
                
                // 캐릭터에 눈 추가
                const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
                
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(0.2, 0.2, 0.4);
                character.add(leftEye);
                
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(-0.2, 0.2, 0.4);
                character.add(rightEye);
                
                // 눈동자
                const pupilGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                const pupilMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
                
                const leftPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                leftPupil.position.set(0.2, 0.2, 0.45);
                character.add(leftPupil);
                
                const rightPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                rightPupil.position.set(-0.2, 0.2, 0.45);
                character.add(rightPupil);
                
                // 팔과 다리 추가 (메인 캐릭터만)
                if (i === 0) {
                    // 팔
                    const armGeometry = new THREE.SphereGeometry(0.15, 8, 8);
                    
                    const leftArm = new THREE.Mesh(armGeometry, bodyMaterial);
                    leftArm.position.set(0.6, 0, 0);
                    leftArm.castShadow = true;
                    character.add(leftArm);
                    
                    const rightArm = new THREE.Mesh(armGeometry, bodyMaterial);
                    rightArm.position.set(-0.6, 0, 0);
                    rightArm.castShadow = true;
                    character.add(rightArm);
                    
                    // 다리
                    const legGeometry = new THREE.CylinderGeometry(0.15, 0.1, 0.5, 8);
                    
                    const leftLeg = new THREE.Mesh(legGeometry, bodyMaterial);
                    leftLeg.position.set(0.2, -0.5, 0);
                    leftLeg.castShadow = true;
                    character.add(leftLeg);
                    
                    const rightLeg = new THREE.Mesh(legGeometry, bodyMaterial);
                    rightLeg.position.set(-0.2, -0.5, 0);
                    rightLeg.castShadow = true;
                    character.add(rightLeg);
                }
                
                if (i === 0) {
                    // 메인 아군 (플레이어)
                    character.position.set(lanes[playerLane], 0.5, 0);
                } else {
                    // 추가 아군들은 초기 위치만 설정 (updateAllyFormation에서 정확히 배치됨)
                    character.position.set(lanes[playerLane], 0.5, -i);
                    // 작게 만들기
                    character.scale.set(0.8, 0.8, 0.8);
                }
                
                scene.add(character);
                allies.push(character);
            }
            
            // 진형 업데이트
            updateAllyFormation();
            
            // UI 업데이트
            document.getElementById('allyCount').textContent = allies.length;
        }
        
        // 적 생성 함수 - 웨이브 형태로 생성
        function createEnemyWave() {
            const waveType = Math.floor(Math.random() * 4);
            
            switch (waveType) {
                case 0: // 일렬 웨이브
                    const randomLane = Math.floor(Math.random() * 3);
                    for (let i = 0; i < 5 + Math.floor(difficulty); i++) {
                        createEnemy(randomLane, -80 - (i * 4));
                    }
                    break;
                    
                case 1: // V 형태 웨이브
                    for (let i = 0; i < 7; i++) {
                        const laneOffset = (i <= 3) ? i : 6 - i; // 0,1,2,3,2,1,0
                        createEnemy(laneOffset, -80 - (i * 3));
                    }
                    break;
                    
                case 2: // 모든 레인 웨이브
                    for (let i = 0; i < 3; i++) {
                        for (let j = 0; j < 3; j++) {
                            createEnemy(j, -80 - (i * 5));
                        }
                    }
                    break;
                    
                case 3: // 랜덤 웨이브
                    const enemyCount = 5 + Math.floor(difficulty * 2);
                    for (let i = 0; i < enemyCount; i++) {
                        const randLane = Math.floor(Math.random() * 3);
                        const randDist = -80 - (Math.random() * 20);
                        createEnemy(randLane, randDist);
                    }
                    break;
            }
            
            function createEnemy(lane, zPos) {
                // 적 그룹
                const enemy = new THREE.Group();
                
                // 적 몸체 (더 큰 크기와 강한 네온 빨간색)
                const enemyGeometry = new THREE.SphereGeometry(0.6, 16, 16);
                const enemyMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xff0000,
                    emissive: 0xff0000,
                    emissiveIntensity: 0.8,
                    roughness: 0.3,
                    metalness: 0.7
                });
                const body = new THREE.Mesh(enemyGeometry, enemyMaterial);
                body.castShadow = true;
                body.receiveShadow = true;
                enemy.add(body);
                
                // 적 눈 (흰색)
                const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
                
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(0.2, 0.2, 0.4);
                enemy.add(leftEye);
                
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(-0.2, 0.2, 0.4);
                enemy.add(rightEye);
                
                // 적 눈동자 (검은색)
                const pupilGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                const pupilMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
                
                const leftPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                leftPupil.position.set(0.2, 0.2, 0.45);
                enemy.add(leftPupil);
                
                const rightPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                rightPupil.position.set(-0.2, 0.2, 0.45);
                enemy.add(rightPupil);
                
                enemy.position.set(lanes[lane], 0.5, zPos);
                scene.add(enemy);
                enemies.push(enemy);
            }
        }
        
        // 총알 발사 함수
        function fireBullets() {
            const currentTime = Date.now();
            
            // 자동 발사 간격 (아군 수에 따라 감소)
            const fireInterval = Math.max(100, 500 - (allies.length * 10));
            
            if (currentTime - lastFireTime < fireInterval) return;
            
            lastFireTime = currentTime;
            
            // 아군 수에 비례해서 총알 발사 (아군당 0.5발의 총알)
            const bulletsToFire = Math.max(1, Math.ceil(allies.length * 0.5));
            
            for (let i = 0; i < bulletsToFire; i++) {
                const bulletGeometry = new THREE.SphereGeometry(0.2, 8, 8);
                const bulletMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xffff00, 
                    emissive: 0xffff00,
                    emissiveIntensity: 0.8
                });
                const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
                
                // 총알 발사 방향 다각화
                let angleOffset = 0;
                if (bulletsToFire > 1) {
                    // 부채꼴 형태로 퍼지게 발사
                    const spreadFactor = Math.min(0.3, bulletsToFire * 0.02);  // 최대 0.3 라디안 (약 17도)
                    angleOffset = spreadFactor * ((i / (bulletsToFire - 1)) * 2 - 1);
                }
                
                // 총알 위치는 무작위 아군 위치에서 시작
                const shooterIndex = Math.floor(Math.random() * allies.length);
                bullet.position.copy(allies[shooterIndex].position);
                bullet.position.z -= 1; // 약간 앞에서 발사
                
                // 총알 방향 설정
                bullet.userData.direction = new THREE.Vector3(angleOffset, 0, -1).normalize();
                bullet.userData.speed = 1.5;
                
                scene.add(bullet);
                bullets.push(bullet);
                
                // 총알 발사 이펙트 (빛)
                const bulletLight = new THREE.PointLight(0xffff00, 2, 5);
                bulletLight.position.copy(bullet.position);
                scene.add(bulletLight);
                
                // 0.1초 후 이펙트 제거
                setTimeout(() => {
                    scene.remove(bulletLight);
                }, 100);
            }
        }
        
        // 사칙연산 패널 생성 함수
        function createMathPanels() {
            // 기존 패널 제거
            panels.forEach(panel => scene.remove(panel));
            panels = [];
            
            // 랜덤 연산자 선택
            const operator = operators[Math.floor(Math.random() * operators.length)];
            
            // 피연산자 선택 (난이도에 따라 증가)
            const operand = Math.floor(Math.random() * Math.min(5, difficulty)) + 1;
            
            // 현재 아군 수와 연산 결과 계산
            const currentAllies = allies.length;
            const result = operator.fn(currentAllies, operand);
            
            // 연산 표시 업데이트
            activeEquation = `${currentAllies} ${operator.symbol} ${operand} = ${result}`;
            document.getElementById('currentEquation').textContent = activeEquation;
            
            // 도로 세 레인에 패널 생성
            for (let i = 0; i < 3; i++) {
                createMathPanel(lanes[i], -60 - Math.random() * 10, operand, operator);
            }
            
            function createMathPanel(x, z, operand, operator) {
                // 패널 그룹
                const panel = new THREE.Group();
                
                // 패널 플랫폼
                const panelGeometry = new THREE.BoxGeometry(3, 0.3, 3);
                
                // 연산자에 맞는 색상 적용 (강한 네온 효과)
                const panelMaterial = new THREE.MeshStandardMaterial({ 
                    color: operator.color,
                    emissive: operator.glow,
                    emissiveIntensity: 0.8,
                    transparent: true,
                    opacity: 0.9
                });
                
                const panelMesh = new THREE.Mesh(panelGeometry, panelMaterial);
                panelMesh.castShadow = true;
                panelMesh.receiveShadow = true;
                panel.add(panelMesh);
                
                // 패널에 숫자 표시를 위한 텍스트 (Three.js에서는 실제 텍스트 렌더링이 어려워 대체 표현)
                const operatorSymbol = operator.symbol;
                const operatorTextGeometry = new THREE.BoxGeometry(1, 0.1, 1);
                const operatorTextMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFFFFFF,
                    emissive: 0xFFFFFF,
                    emissiveIntensity: 0.5
                });
                
                const operatorText = new THREE.Mesh(operatorTextGeometry, operatorTextMaterial);
                operatorText.position.y = 0.2;
                panel.add(operatorText);
                
                // 숫자 표시 (간소화된 형태)
                const numberGeometry = new THREE.BoxGeometry(0.5, 0.1, 0.5);
                const numberMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
                const numberMesh = new THREE.Mesh(numberGeometry, numberMaterial);
                numberMesh.position.set(0, 0.2, 0.5);
                panel.add(numberMesh);
                
                // 패널 위치 설정
                panel.position.set(x, 0, z);
                
                // 패널에 연산 데이터 추가
                panel.userData = {
                    operator: operatorSymbol,
                    operand: operand,
                    result: result
                };
                
                // 패널 발광 효과
                const panelLight = new THREE.PointLight(operator.color, 1, 5);
                panelLight.position.set(0, 0.5, 0);
                panel.add(panelLight);
                
                scene.add(panel);
                panels.push(panel);
            }
        }
        
        // 게임 업데이트 함수
        function updateGame() {
            const currentTime = Date.now();
            
            // 도로 스크롤
            scrollRoad();
            
            // 3초마다 패널 생성
            if (currentTime - lastPanelTime > 3000) {
                createMathPanels();
                lastPanelTime = currentTime;
            }
            
            // 난이도에 따라 적 웨이브 생성 주기 조절
            const enemyWaveInterval = Math.max(2000, 5000 - (difficulty * 300));
            if (currentTime - lastEnemyWaveTime > enemyWaveInterval) {
                createEnemyWave();
                lastEnemyWaveTime = currentTime;
            }
            
            // 자동 총알 발사
            fireBullets();
            
            // 패널 이동 (도로와 함께 이동)
            panels.forEach(panel => {
                panel.position.z += roadSpeed;
                
                // 화면 끝에 도달한 패널은 제거
                if (panel.position.z > 10) {
                    scene.remove(panel);
                    panels.splice(panels.indexOf(panel), 1);
                    
                    // 모든 패널이 사라졌을 때 현재 연산 초기화
                    if (panels.length === 0) {
                        document.getElementById('currentEquation').textContent = "없음";
                    }
                }
            });
            
            // 적 이동 (도로와 함께 이동, 약간 더 빠르게)
            enemies.forEach(enemy => {
                enemy.position.z += roadSpeed * 1.2;
                
                // 화면 끝에 도달한 적은 제거
                if (enemy.position.z > 10) {
                    scene.remove(enemy);
                    enemies.splice(enemies.indexOf(enemy), 1);
                }
                
                // 적 애니메이션 (약간 상하로 움직임)
                enemy.position.y = 0.5 + Math.sin(currentTime / 300 + enemy.position.z) * 0.1;
                
                // 추가: 적 회전 애니메이션
                enemy.rotation.y += 0.02;
            });
            
            // 아군 애니메이션 (약간 위아래로 움직임)
            allies.forEach((ally, index) => {
                // 메인 캐릭터 (0번 인덱스)만 특별한 애니메이션 적용
                if (index === 0) {
                    ally.position.y = 0.5 + Math.sin(currentTime / 500) * 0.05;
                    
                    // 달리기 애니메이션 효과 (앞뒤로 약간 기울임)
                    ally.rotation.x = Math.sin(currentTime / 200) * 0.1;
                } else {
                    // 다른 아군들은 약간 다른 주기로 움직여 자연스러움 증가
                    ally.position.y = 0.5 + Math.sin((currentTime / 500) + index * 0.5) * 0.05;
                }
            });
            
            // 총알 이동
            bullets.forEach(bullet => {
                const direction = bullet.userData.direction;
                bullet.position.x += direction.x * bullet.userData.speed;
                bullet.position.z += direction.z * bullet.userData.speed;
                
                // 총알 회전 효과 추가
                bullet.rotation.x += 0.2;
                bullet.rotation.y += 0.2;
                
                // 화면 밖으로 나간 총알 제거
                if (bullet.position.z < -100) {
                    scene.remove(bullet);
                    bullets.splice(bullets.indexOf(bullet), 1);
                }
            });
            
            // 충돌 체크
            checkCollisions();
            
            // 난이도 증가
            difficulty = 1 + ((60 - gameTime) / 5);
            
            // 도로 속도 증가 (난이도에 따라)
            roadSpeed = 0.5 + (difficulty * 0.05);
        }
        
        // 충돌 체크 함수 - 시각적 효과 추가
        function checkCollisions() {
            // 총알과 적의 충돌
            bullets.forEach(bullet => {
                enemies.forEach(enemy => {
                    const distance = bullet.position.distanceTo(enemy.position);
                    if (distance < 1) {
                        // 충돌 시 폭발 효과
                        createExplosion(enemy.position.clone());
                        
                        // 충돌 발생
                        scene.remove(bullet);
                        scene.remove(enemy);
                        bullets.splice(bullets.indexOf(bullet), 1);
                        enemies.splice(enemies.indexOf(enemy), 1);
                        
                        // 점수 추가
                        score += 10;
                        document.getElementById('score').textContent = score;
                    }
                });
            });
            
            // 플레이어(메인 아군)와 패널의 충돌
            if (allies.length > 0) {
                const player = allies[0];
                
                panels.forEach(panel => {
                    const distance = Math.sqrt(
                        Math.pow(player.position.x - panel.position.x, 2) +
                        Math.pow(player.position.z - panel.position.z, 2)
                    );
                    
                    if (distance < 2) {
                        // 패널과 충돌 - 사칙연산 수행
                        if (panel.userData.result !== undefined) {
                            // 패널 획득 효과
                            createPanelEffect(player.position.clone());
                            
                            createAllies(panel.userData.result);
                            
                            // 보너스 점수
                            score += 50;
                            document.getElementById('score').textContent = score;
                            
                            // 모든 패널 제거
                            panels.forEach(p => scene.remove(p));
                            panels = [];
                            
                            // 연산 초기화
                            document.getElementById('currentEquation').textContent = "없음";
                        }
                    }
                });
                
                // 플레이어와 적의 충돌
                enemies.forEach(enemy => {
                    const distance = player.position.distanceTo(enemy.position);
                    if (distance < 1.2) {
                        // 충돌 시 데미지 효과
                        createDamageEffect(player.position.clone());
                        
                        // 충돌 발생 - 아군 감소
                        if (allies.length > 1) {
                            createAllies(allies.length - 1);
                            
                            // 해당 적 제거
                            scene.remove(enemy);
                            enemies.splice(enemies.indexOf(enemy), 1);
                        } else {
                            // 마지막 아군이 적과 충돌하면 게임 오버
                            endGame();
                        }
                    }
                });
            }
        }
        
        // 폭발 효과 생성 함수
        function createExplosion(position) {
            // 폭발 파티클 그룹
            const explosionGroup = new THREE.Group();
            explosionGroup.position.copy(position);
            
            // 폭발 빛
            const explosionLight = new THREE.PointLight(0xff5500, 3, 8);
            explosionLight.position.set(0, 0, 0);
            explosionGroup.add(explosionLight);
            
            // 파티클 생성
            const particleCount = 10;
            const particles = [];
            
            for (let i = 0; i < particleCount; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const particleMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xff5500, 
                    transparent: true, 
                    opacity: 1
                });
                
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                
                // 랜덤 방향으로 튀어나감
                const angle1 = Math.random() * Math.PI * 2;
                const angle2 = Math.random() * Math.PI * 2;
                
                const speed = 0.1 + Math.random() * 0.2;
                particle.userData.velocity = new THREE.Vector3(
                    Math.sin(angle1) * Math.cos(angle2) * speed,
                    Math.sin(angle1) * Math.sin(angle2) * speed,
                    Math.cos(angle1) * speed
                );
                
                explosionGroup.add(particle);
                particles.push(particle);
            }
            
            scene.add(explosionGroup);
            
            // 0.5초 동안 폭발 애니메이션
            let elapsed = 0;
            const duration = 500; // 밀리초
            const interval = setInterval(() => {
                elapsed += 16;
                
                // 파티클 이동 및 페이드 아웃
                particles.forEach(particle => {
                    particle.position.add(particle.userData.velocity);
                    particle.material.opacity = 1 - (elapsed / duration);
                    particle.scale.multiplyScalar(0.98);
                });
                
                // 빛 감소
                explosionLight.intensity = 3 * (1 - elapsed / duration);
                
                if (elapsed >= duration) {
                    clearInterval(interval);
                    scene.remove(explosionGroup);
                }
            }, 16);
        }
        
        // 패널 획득 효과
        function createPanelEffect(position) {
            // 빛 생성
            const light = new THREE.PointLight(0x00ffff, 3, 10);
            light.position.copy(position);
            scene.add(light);
            
            // 0.5초 동안 빛 효과
            let elapsed = 0;
            const duration = 500; // 밀리초
            const interval = setInterval(() => {
                elapsed += 16;
                
                // 빛 강도 조절
                light.intensity = 3 * (1 - elapsed / duration);
                
                if (elapsed >= duration) {
                    clearInterval(interval);
                    scene.remove(light);
                }
            }, 16);
        }
        
        // 데미지 효과
        function createDamageEffect(position) {
            // 빨간 빛 생성
            const light = new THREE.PointLight(0xff0000, 3, 10);
            light.position.copy(position);
            scene.add(light);
            
            // 화면 빨갛게 깜빡임 (CSS 효과)
            const overlay = document.createElement('div');
            overlay.style.position = 'absolute';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.width = '100%';
            overlay.style.height = '100%';
            overlay.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
            overlay.style.pointerEvents = 'none';
            overlay.style.transition = 'opacity 0.5s';
            document.body.appendChild(overlay);
            
            // 0.5초 동안 효과
            setTimeout(() => {
                overlay.style.opacity = '0';
                setTimeout(() => {
                    document.body.removeChild(overlay);
                }, 500);
            }, 100);
            
            // 빛 효과 제거
            setTimeout(() => {
                scene.remove(light);
            }, 500);
        }
        
        // 게임 타이머 함수
        function startGameTimer() {
            const timerInterval = setInterval(() => {
                if (!gameActive) {
                    clearInterval(timerInterval);
                    return;
                }
                
                gameTime--;
                document.getElementById('timer').textContent = gameTime;
                
                if (gameTime <= 0) {
                    clearInterval(timerInterval);
                    endGame();
                }
            }, 1000);
        }
        
        // 게임 종료 함수
        function endGame() {
            gameActive = false;
            document.getElementById('gameOver').style.display = 'block';
            document.getElementById('finalScore').textContent = score;
            
            // 게임 오버 효과
            const gameOverLight = new THREE.AmbientLight(0xff0000, 0.3);
            scene.add(gameOverLight);
            
            // 모든 아군 회전 애니메이션
            const rotateAllies = () => {
                allies.forEach(ally => {
                    ally.rotation.y += 0.05;
                });
                
                if (gameActive) {
                    return;
                }
                
                requestAnimationFrame(rotateAllies);
            };
            
            rotateAllies();
        }
        
        // 게임 재시작 함수
        function restartGame() {
            // 기존 오브젝트 정리
            allies.forEach(ally => scene.remove(ally));
            enemies.forEach(enemy => scene.remove(enemy));
            bullets.forEach(bullet => scene.remove(bullet));
            panels.forEach(panel => scene.remove(panel));
            
            // 씬의 모든 빛 제거 (게임 오버 효과 제거)
            scene.children.forEach(child => {
                if (child instanceof THREE.Light && !(child instanceof THREE.DirectionalLight) && !(child instanceof THREE.AmbientLight && child.intensity === 0.6)) {
                    scene.remove(child);
                }
            });
            
            allies = [];
            enemies = [];
            bullets = [];
            panels = [];
            
            // 변수 초기화
            gameTime = 60;
            score = 0;
            difficulty = 1;
            gameActive = true;
            lastPanelTime = 0;
            lastEnemyWaveTime = 0;
            playerLane = 1; // 중앙 레인으로 초기화
            isMoving = false;
            roadSpeed = 0.5;
            gameDistance = 0;
            
            // UI 초기화
            document.getElementById('timer').textContent = gameTime;
            document.getElementById('score').textContent = score;
            document.getElementById('currentEquation').textContent = "없음";
            document.getElementById('gameOver').style.display = 'none';
            
            // 기본 조명 재설정
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(0, 20, 10);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // 첫 아군 생성
            createAllies(1);
            
            // 타이머 재시작
            startGameTimer();
        }
        
        // 애니메이션 루프
        function animate() {
            requestAnimationFrame(animate);
            
            if (gameActive) {
                updateGame();
            }
            
            renderer.render(scene, camera);
        }
        
        // 화면 크기 조정 이벤트
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // 게임 시작
        init();
    </script>
</body>
</html>
</antArtifact><antArtifact identifier="enhanced-game" type="application/vnd.ant.code" language="html" title="Enhanced Math Runner 3D Game">
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>러너 3D 슈팅 게임</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: Arial, sans-serif; 
            touch-action: none;
        }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            padding: 5px;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 1px 1px 1px black;
            z-index: 10;
        }
        #equationInfo {
            position: absolute;
            top: 40px;
            width: 100%;
            text-align: center;
            color: #ffcc00;
            padding: 5px;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 1px 1px 1px black;
            z-index: 10;
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none;
            z-index: 20;
        }
        #restartBtn {
            padding: 15px 30px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 18px;
            margin-top: 20px;
        }
        #restartBtn:hover {
            background-color: #45a049;
        }
        #controls {
            position: absolute;
            bottom: 30px;
            width: 100%;
            display: flex;
            justify-content: center;
            z-index: 10;
        }
        .controlBtn {
            width: 80px;
            height: 80px;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 40px;
            margin: 0 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
            user-select: none;
        }
    </style>
</head>
<body>
    <div id="info">아군: <span id="allyCount">1</span> | 시간: <span id="timer">60</span>초 | 점수: <span id="score">0</span></div>
    <div id="equationInfo">현재 패널: <span id="currentEquation">없음</span></div>
    <div id="gameOver">
        <h2>게임 종료!</h2>
        <p>최종 점수: <span id="finalScore">0</span></p>
        <button id="restartBtn">다시 시작</button>
    </div>
    <div id="controls">
        <div id="leftBtn" class="controlBtn">←</div>
        <div id="rightBtn" class="controlBtn">→</div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // 게임 변수
        let scene, camera, renderer, allies = [], enemies = [], bullets = [], panels = [];
        let gameTime = 60; // 1분
        let score = 0;
        let difficulty = 1;
        let gameActive = true;
        let lastPanelTime = 0;
        let lastEnemyWaveTime = 0;
        let lastFireTime = 0;
        let playerLane = 1; // 0: 왼쪽, 1: 중앙, 2: 오른쪽
        let isMoving = false;
        let roadSpeed = 0.5;
        let roadSegments = [];
        let gameDistance = 0;
        let activeEquation = "";
        
        // 레인 위치 정의
        const lanes = [-5, 0, 5];
        
        // 수학 연산자 (각각 강한 네온 색상으로 변경)
        const operators = [
            { symbol: "+", fn: (a, b) => a + b, color: 0x00FFFF, glow: 0x00FFFF }, // 네온 청록색
            { symbol: "-", fn: (a, b) => Math.max(1, a - b), color: 0xFF1493, glow: 0xFF1493 }, // 네온 핑크
            { symbol: "×", fn: (a, b) => a * b, color: 0x39FF14, glow: 0x39FF14 }, // 네온 그린
            { symbol: "÷", fn: (a, b) => Math.round(a / b) || 1, color: 0xFFD700, glow: 0xFFD700 } // 네온 골드
        ];
        
        // 게임 초기화
        function init() {
            // 씬 설정
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e); // 어두운 남색 배경
            
            // 안개 추가 (원근감) - 더 짙게 설정
            scene.fog = new THREE.Fog(0x1a1a2e, 30, 80);
            
            // 카메라 설정
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 8, 12); // 카메라 높이와 거리 조정
            camera.lookAt(0, 0, -20);
            
            // 렌더러 설정
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; // 그림자 활성화
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);
            
            // 조명 설정
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(0, 20, 10);
            directionalLight.castShadow = true; // 그림자 생성
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -20;
            directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20;
            directionalLight.shadow.camera.bottom = -20;
            scene.add(directionalLight);
            
            // 도로 생성
            createRoad();
            
            // 첫 아군 생성
            createAllies(1);
            
            // 이벤트 리스너
            window.addEventListener('resize', onWindowResize);
            document.getElementById('restartBtn').addEventListener('click', restartGame);
            
            // 모바일 컨트롤 초기화
            initControls();
            
            // 게임 타이머 시작
            startGameTimer();
            
            // 게임 루프 시작
            animate();
        }
        
        // 도로 생성 함수
        function createRoad() {
            // 도로 텍스처 (하늘색 그라데이션 패턴으로 변경)
            const roadWidth = 15;
            const roadLength = 1000;
            const segmentLength = 20;
            const segments = roadLength / segmentLength;
            
            // 도로 기본 재질 (네온 효과가 있는 어두운 색상)
            const roadMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x0f3460,
                roughness: 0.5,
                metalness: 0.7,
                emissive: 0x0f3460,
                emissiveIntensity: 0.2
            });
            
            // 도로 경계선 재질 (밝은 네온 색상)
            const lineMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xE94560, 
                emissive: 0xE94560,
                emissiveIntensity: 0.7
            });
            
            // 도로 가장자리 재질 (네온 푸른색)
            const sideMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x16213E,
                emissive: 0x0F52BA,
                emissiveIntensity: 0.3
            });
            
            // 도로 그라데이션을 위한 재질 배열 (네온 효과가 있는 패턴)
            const patternMaterials = [
                new THREE.MeshStandardMaterial({ 
                    color: 0x0f3460, 
                    emissive: 0x0f3460,
                    emissiveIntensity: 0.2
                }),
                new THREE.MeshStandardMaterial({ 
                    color: 0x16213E, 
                    emissive: 0x16213E,
                    emissiveIntensity: 0.2
                })
            ];
            
            // 여러 세그먼트로 도로 생성
            for (let i = 0; i < segments; i++) {
                // 도로 세그먼트 (패턴 적용)
                const roadGeometry = new THREE.PlaneGeometry(roadWidth, segmentLength);
                const road = new THREE.Mesh(roadGeometry, patternMaterials[i % 2]); // 번갈아가며 패턴 적용
                road.rotation.x = -Math.PI / 2;
                road.position.z = -i * segmentLength - segmentLength / 2;
                road.position.y = -0.1;
                road.receiveShadow = true; // 그림자 받기
                scene.add(road);
                roadSegments.push(road);
                
                // 도로 레인 구분선
                for (let j = -1; j <= 1; j += 2) {
                    const lineGeometry = new THREE.PlaneGeometry(0.3, segmentLength);
                    const line = new THREE.Mesh(lineGeometry, lineMaterial);
                    line.rotation.x = -Math.PI / 2;
                    line.position.set(j * roadWidth/6, -0.05, -i * segmentLength - segmentLength / 2);
                    line.receiveShadow = true;
                    scene.add(line);
                    roadSegments.push(line);
                }
                
                // 도로 가장자리
                for (let j = -1; j <= 1; j += 2) {
                    const sideGeometry = new THREE.BoxGeometry(2, 1, segmentLength);
                    const side = new THREE.Mesh(sideGeometry, sideMaterial);
                    side.position.set(j * (roadWidth/2 + 1), 0.4, -i * segmentLength - segmentLength / 2);
                    side.castShadow = true;
                    side.receiveShadow = true;
                    scene.add(side);
                    roadSegments.push(side);
                    
                    // 가드레일 기둥 추가
                    if (i % 2 === 0) {
                        const postGeometry = new THREE.BoxGeometry(0.5, 2, 0.5);
                        const postMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
                        const post = new THREE.Mesh(postGeometry, postMaterial);
                        post.position.set(j * (roadWidth/2 + 1), 1.5, -i * segmentLength - segmentLength / 2);
                        post.castShadow = true;
                        post.receiveShadow = true;
                        scene.add(post);
                        roadSegments.push(post);
                    }
                }
            }
        }
        
        // 도로 스크롤 함수
        function scrollRoad() {
            const resetPos = -1000; // 도로 총 길이
            
            roadSegments.forEach(segment => {
                segment.position.z += roadSpeed;
                
                // 도로 세그먼트가 카메라 뒤로 지나가면 다시 앞으로 재배치
                if (segment.position.z > 20) {
                    segment.position.z = resetPos + (segment.position.z - 20);
                }
            });
            
            // 거리 증가
            gameDistance += roadSpeed;
        }
        
        // 컨트롤 초기화
        function initControls() {
            const leftBtn = document.getElementById('leftBtn');
            const rightBtn = document.getElementById('rightBtn');
            
            // 터치 이벤트
            leftBtn.addEventListener('touchstart', moveLeft);
            rightBtn.addEventListener('touchstart', moveRight);
            
            // 마우스 이벤트 (데스크톱용)
            leftBtn.addEventListener('mousedown', moveLeft);
            rightBtn.addEventListener('mousedown', moveRight);
            
            // 키보드 이벤트
            window.addEventListener('keydown', function(e) {
                if (!gameActive || isMoving) return;
                
                if (e.key === 'ArrowLeft') {
                    moveLeft();
                } else if (e.key === 'ArrowRight') {
                    moveRight();
                }
            });
            
            function moveLeft() {
                if (!gameActive || isMoving || playerLane === 0) return;
                
                isMoving = true;
                playerLane--;
                moveAlliesTo(lanes[playerLane]);
            }
            
            function moveRight() {
                if (!gameActive || isMoving || playerLane === 2) return;
                
                isMoving = true;
                playerLane++;
                moveAlliesTo(lanes[playerLane]);
            }
        }
        
        // 아군 이동 함수
        function moveAlliesTo(targetX) {
            // 0.3초에 걸쳐 부드럽게 이동
            const frames = 15; // 60fps 기준 0.25초
            let currentFrame = 0;
            
            // 메인 아군 현재 위치
            const startX = allies[0].position.x;
            const moveAmount = (targetX - startX) / frames;
            
            const moveInterval = setInterval(() => {
                if (currentFrame >= frames) {
                    clearInterval(moveInterval);
                    isMoving = false;
                    return;
                }
                
                // 모든 아군 이동
                allies.forEach((ally, index) => {
                    if (index === 0) {
                        // 메인 아군
                        ally.position.x += moveAmount;
                    } else {
                        // 나머지 아군들은 메인 아군을 따라감
                        updateAllyFormation();
                    }
                });
                
                currentFrame++;
            }, 1000/60); // 60fps
        }
        
        // 아군 진형 업데이트
        function updateAllyFormation() {
            if (allies.length <= 1) return;
            
            const mainAlly = allies[0];
            const allyCount = allies.length;
            
            // 진영 크기 계산 - 아군이 많을수록 더 넓게 퍼짐
            const formationWidth = Math.min(3, 0.5 + (allyCount * 0.1));
            const formationDepth = Math.min(4, 1 + (allyCount * 0.15));
            
            for (let i = 1; i < allyCount; i++) {
                // 균등하게 분포된 위치 계산
                let row = Math.floor((i-1) / 3);
                let col = (i-1) % 3;
                
                // 중앙 정렬을 위한 오프셋
                let colOffset = col - 1; // -1, 0, 1
                let rowOffset = -row; // 항상 플레이어 뒤에 배치
                
                allies[i].position.x = mainAlly.position.x + (colOffset * formationWidth);
                allies[i].position.z = mainAlly.position.z + (rowOffset * formationDepth);
            }
        }
        
        // 아군 생성 함수 - 캐릭터 디자인 개선
        function createAllies(count) {
            // 기존 아군 제거
            allies.forEach(ally => scene.remove(ally));
            allies = [];
            
            // 최댓값 제한 (너무 많으면 게임이 쉬워짐)
            count = Math.min(count, 30);
            
            // 새 아군 생성 - 귀여운 오렌지색 캐릭터로 변경
            for (let i = 0; i < count; i++) {
                // 캐릭터 그룹
                const character = new THREE.Group();
                
                // 몸체 (구)
                const bodyGeometry = new THREE.SphereGeometry(0.5, 16, 16);
                const bodyMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFF9900, // 오렌지색
                    emissive: 0xAA5500,
                    emissiveIntensity: 0.2,
                    roughness: 0.7
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.castShadow = true;
                body.receiveShadow = true;
                character.add(body);
                
                // 캐릭터에 눈 추가
                const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
                
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(0.2, 0.2, 0.4);
                character.add(leftEye);
                
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(-0.2, 0.2, 0.4);
                character.add(rightEye);
                
                // 눈동자
                const pupilGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                const pupilMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
                
                const leftPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                leftPupil.position.set(0.2, 0.2, 0.45);
                character.add(leftPupil);
                
                const rightPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                rightPupil.position.set(-0.2, 0.2, 0.45);
                character.add(rightPupil);
                
                // 팔과 다리 추가 (메인 캐릭터만)
                if (i === 0) {
                    // 팔
                    const armGeometry = new THREE.SphereGeometry(0.15, 8, 8);
                    
                    const leftArm = new THREE.Mesh(armGeometry, bodyMaterial);
                    leftArm.position.set(0.6, 0, 0);
                    leftArm.castShadow = true;
                    character.add(leftArm);
                    
                    const rightArm = new THREE.Mesh(armGeometry, bodyMaterial);
                    rightArm.position.set(-0.6, 0, 0);
                    rightArm.castShadow = true;
                    character.add(rightArm);
                    
                    // 다리
                    const legGeometry = new THREE.CylinderGeometry(0.15, 0.1, 0.5, 8);
                    
                    const leftLeg = new THREE.Mesh(legGeometry, bodyMaterial);
                    leftLeg.position.set(0.2, -0.5, 0);
                    leftLeg.castShadow = true;
                    character.add(leftLeg);
                    
                    const rightLeg = new THREE.Mesh(legGeometry, bodyMaterial);
                    rightLeg.position.set(-0.2, -0.5, 0);
                    rightLeg.castShadow = true;
                    character.add(rightLeg);
                }
                
                if (i === 0) {
                    // 메인 아군 (플레이어)
                    character.position.set(lanes[playerLane], 0.5, 0);
                } else {
                    // 추가 아군들은 초기 위치만 설정 (updateAllyFormation에서 정확히 배치됨)
                    character.position.set(lanes[playerLane], 0.5, -i);
                    // 작게 만들기
                    character.scale.set(0.8, 0.8, 0.8);
                }
                
                scene.add(character);
                allies.push(character);
            }
            
            // 진형 업데이트
            updateAllyFormation();
            
            // UI 업데이트
            document.getElementById('allyCount').textContent = allies.length;
        }
        
        // 적 생성 함수 - 웨이브 형태로 생성
        function createEnemyWave() {
            const waveType = Math.floor(Math.random() * 4);
            
            switch (waveType) {
                case 0: // 일렬 웨이브
                    const randomLane = Math.floor(Math.random() * 3);
                    for (let i = 0; i < 5 + Math.floor(difficulty); i++) {
                        createEnemy(randomLane, -80 - (i * 4));
                    }
                    break;
                    
                case 1: // V 형태 웨이브
                    for (let i = 0; i < 7; i++) {
                        const laneOffset = (i <= 3) ? i : 6 - i; // 0,1,2,3,2,1,0
                        createEnemy(laneOffset, -80 - (i * 3));
                    }
                    break;
                    
                case 2: // 모든 레인 웨이브
                    for (let i = 0; i < 3; i++) {
                        for (let j = 0; j < 3; j++) {
                            createEnemy(j, -80 - (i * 5));
                        }
                    }
                    break;
                    
                case 3: // 랜덤 웨이브
                    const enemyCount = 5 + Math.floor(difficulty * 2);
                    for (let i = 0; i < enemyCount; i++) {
                        const randLane = Math.floor(Math.random() * 3);
                        const randDist = -80 - (Math.random() * 20);
                        createEnemy(randLane, randDist);
                    }
                    break;
            }
            
            function createEnemy(lane, zPos) {
                // 적 그룹
                const enemy = new THREE.Group();
                
                // 적 몸체 (더 큰 크기와 강한 네온 빨간색)
                const enemyGeometry = new THREE.SphereGeometry(0.6, 16, 16);
                const enemyMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xff0000,
                    emissive: 0xff0000,
                    emissiveIntensity: 0.8,
                    roughness: 0.3,
                    metalness: 0.7
                });
                const body = new THREE.Mesh(enemyGeometry, enemyMaterial);
                body.castShadow = true;
                body.receiveShadow = true;
                enemy.add(body);
                
                // 적 눈 (흰색)
                const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
                
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(0.2, 0.2, 0.4);
                enemy.add(leftEye);
                
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(-0.2, 0.2, 0.4);
                enemy.add(rightEye);
                
                // 적 눈동자 (검은색)
                const pupilGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                const pupilMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
                
                const leftPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                leftPupil.position.set(0.2, 0.2, 0.45);
                enemy.add(leftPupil);
                
                const rightPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                rightPupil.position.set(-0.2, 0.2, 0.45);
                enemy.add(rightPupil);
                
                enemy.position.set(lanes[lane], 0.5, zPos);
                scene.add(enemy);
                enemies.push(enemy);
            }
        }
        
        // 총알 발사 함수
        function fireBullets() {
            const currentTime = Date.now();
            
            // 자동 발사 간격 (아군 수에 따라 감소)
            const fireInterval = Math.max(100, 500 - (allies.length * 10));
            
            if (currentTime - lastFireTime < fireInterval) return;
            
            lastFireTime = currentTime;
            
            // 아군 수에 비례해서 총알 발사 (아군당 0.5발의 총알)
            const bulletsToFire = Math.max(1, Math.ceil(allies.length * 0.5));
            
            for (let i = 0; i < bulletsToFire; i++) {
                const bulletGeometry = new THREE.SphereGeometry(0.3, 8, 8);
                const bulletMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFFFF00, 
                    emissive: 0xFFFF00,
                    emissiveIntensity: 1.0,
                    metalness: 1.0,
                    roughness: 0.0
                });
                const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
                
                // 총알 발사 방향 다각화
                let angleOffset = 0;
                if (bulletsToFire > 1) {
                    // 부채꼴 형태로 퍼지게 발사
                    const spreadFactor = Math.min(0.3, bulletsToFire * 0.02);  // 최대 0.3 라디안 (약 17도)
                    angleOffset = spreadFactor * ((i / (bulletsToFire - 1)) * 2 - 1);
                }
                
                // 총알 위치는 무작위 아군 위치에서 시작
                const shooterIndex = Math.floor(Math.random() * allies.length);
                bullet.position.copy(allies[shooterIndex].position);
                bullet.position.z -= 1; // 약간 앞에서 발사
                
                // 총알 방향 설정
                bullet.userData.direction = new THREE.Vector3(angleOffset, 0, -1).normalize();
                bullet.userData.speed = 1.5;
                
                scene.add(bullet);
                bullets.push(bullet);
                
                // 총알 발사 이펙트 (빛)
                const bulletLight = new THREE.PointLight(0xffff00, 2, 5);
                bulletLight.position.copy(bullet.position);
                scene.add(bulletLight);
                
                // 0.1초 후 이펙트 제거
                setTimeout(() => {
                    scene.remove(bulletLight);
                }, 100);
            }
        }
        
        // 사칙연산 패널 생성 함수
        function createMathPanels() {
            // 기존 패널 제거
            panels.forEach(panel => scene.remove(panel));
            panels = [];
            
            // 랜덤 연산자 선택
            const operator = operators[Math.floor(Math.random() * operators.length)];
            
            // 피연산자 선택 (난이도에 따라 증가)
            const operand = Math.floor(Math.random() * Math.min(5, difficulty)) + 1;
            
            // 현재 아군 수와 연산 결과 계산
            const currentAllies = allies.length;
            const result = operator.fn(currentAllies, operand);
            
            // 연산 표시 업데이트
            activeEquation = `${currentAllies} ${operator.symbol} ${operand} = ${result}`;
            document.getElementById('currentEquation').textContent = activeEquation;
            
            // 도로 세 레인에 패널 생성
            for (let i = 0; i < 3; i++) {
                createMathPanel(lanes[i], -60 - Math.random() * 10, operand, operator);
            }
            
            function createMathPanel(x, z, operand, operator) {
                // 패널 그룹
                const panel = new THREE.Group();
                
                // 패널 플랫폼
                const panelGeometry = new THREE.BoxGeometry(3, 0.3, 3);
                
                // 연산자에 맞는 색상 적용 (강한 네온 효과)
                const panelMaterial = new THREE.MeshStandardMaterial({ 
                    color: operator.color,
                    emissive: operator.glow,
                    emissiveIntensity: 0.8,
                    transparent: true,
                    opacity: 0.9
                });
                
                const panelMesh = new THREE.Mesh(panelGeometry, panelMaterial);
                panelMesh.castShadow = true;
                panelMesh.receiveShadow = true;
                panel.add(panelMesh);
                
                // 패널에 숫자 표시를 위한 텍스트 (Three.js에서는 실제 텍스트 렌더링이 어려워 대체 표현)
                const operatorSymbol = operator.symbol;
                const operatorTextGeometry = new THREE.BoxGeometry(1, 0.1, 1);
                const operatorTextMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFFFFFF,
                    emissive: 0xFFFFFF,
                    emissiveIntensity: 0.5
                });
                
                const operatorText = new THREE.Mesh(operatorTextGeometry, operatorTextMaterial);
                operatorText.position.y = 0.2;
                panel.add(operatorText);
                
                // 숫자 표시 (간소화된 형태)
                const numberGeometry = new THREE.BoxGeometry(0.5, 0.1, 0.5);
                const numberMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
                const numberMesh = new THREE.Mesh(numberGeometry, numberMaterial);
                numberMesh.position.set(0, 0.2, 0.5);
                panel.add(numberMesh);
                
                // 패널 위치 설정
                panel.position.set(x, 0, z);
                
                // 패널에 연산 데이터 추가
                panel.userData = {
                    operator: operatorSymbol,
                    operand: operand,
                    result: result
                };
                
                // 패널 발광 효과
                const panelLight = new THREE.PointLight(operator.color, 1, 5);
                panelLight.position.set(0, 0.5, 0);
                panel.add(panelLight);
                
                scene.add(panel);
                panels.push(panel);
            }
        }
        
        // 게임 업데이트 함수
        function updateGame() {
            const currentTime = Date.now();
            
            // 도로 스크롤
            scrollRoad();
            
            // 3초마다 패널 생성
            if (currentTime - lastPanelTime > 3000) {
                createMathPanels();
                lastPanelTime = currentTime;
            }
            
            // 난이도에 따라 적 웨이브 생성 주기 조절
            const enemyWaveInterval = Math.max(2000, 5000 - (difficulty * 300));
            if (currentTime - lastEnemyWaveTime > enemyWaveInterval) {
                createEnemyWave();
                lastEnemyWaveTime = currentTime;
            }
            
            // 자동 총알 발사
            fireBullets();
            
            // 패널 이동 (도로와 함께 이동)
            panels.forEach(panel => {
                panel.position.z += roadSpeed;
                
                // 화면 끝에 도달한 패널은 제거
                if (panel.position.z > 10) {
                    scene.remove(panel);
                    panels.splice(panels.indexOf(panel), 1);
                    
                    // 모든 패널이 사라졌을 때 현재 연산 초기화
                    if (panels.length === 0) {
                        document.getElementById('currentEquation').textContent = "없음";
                    }
                }
            });
            
            // 적 이동 (도로와 함께 이동, 약간 더 빠르게)
            enemies.forEach(enemy => {
                enemy.position.z += roadSpeed * 1.2;
                
                // 화면 끝에 도달한 적은 제거
                if (enemy.position.z > 10) {
                    scene.remove(enemy);
                    enemies.splice(enemies.indexOf(enemy), 1);
                }
                
                // 적 애니메이션 (약간 상하로 움직임)
                enemy.position.y = 0.5 + Math.sin(currentTime / 300 + enemy.position.z) * 0.1;
                
                // 추가: 적 회전 애니메이션
                enemy.rotation.y += 0.02;
            });
            
            // 아군 애니메이션 (약간 위아래로 움직임)
            allies.forEach((ally, index) => {
                // 메인 캐릭터 (0번 인덱스)만 특별한 애니메이션 적용
                if (index === 0) {
                    ally.position.y = 0.5 + Math.sin(currentTime / 500) * 0.05;
                    
                    // 달리기 애니메이션 효과 (앞뒤로 약간 기울임)
                    ally.rotation.x = Math.sin(currentTime / 200) * 0.1;
                } else {
                    // 다른 아군들은 약간 다른 주기로 움직여 자연스러움 증가
                    ally.position.y = 0.5 + Math.sin((currentTime / 500) + index * 0.5) * 0.05;
                }
            });
            
            // 총알 이동
            bullets.forEach(bullet => {
                const direction = bullet.userData.direction;
                bullet.position.x += direction.x * bullet.userData.speed;
                bullet.position.z += direction.z * bullet.userData.speed;
                
                // 총알 회전 효과 추가
                bullet.rotation.x += 0.2;
                bullet.rotation.y += 0.2;
                
                // 화면 밖으로 나간 총알 제거
                if (bullet.position.z < -100) {
                    scene.remove(bullet);
                    bullets.splice(bullets.indexOf(bullet), 1);
                }
            });
            
            // 충돌 체크
            checkCollisions();
            
            // 난이도 증가
            difficulty = 1 + ((60 - gameTime) / 5);
            
            // 도로 속도 증가 (난이도에 따라)
            roadSpeed = 0.5 + (difficulty * 0.05);
        }
        
        // 충돌 체크 함수 - 시각적 효과 추가
        function checkCollisions() {
            // 총알과 적의 충돌
            bullets.forEach(bullet => {
                enemies.forEach(enemy => {
                    const distance = bullet.position.distanceTo(enemy.position);
                    if (distance < 1) {
                        // 충돌 시 폭발 효과
                        createExplosion(enemy.position.clone());
                        
                        // 충돌 발생
                        scene.remove(bullet);
                        scene.remove(enemy);
                        bullets.splice(bullets.indexOf(bullet), 1);
                        enemies.splice(enemies.indexOf(enemy), 1);
                        
                        // 점수 추가
                        score += 10;
                        document.getElementById('score').textContent = score;
                    }
                });
            });
            
            // 플레이어(메인 아군)와 패널의 충돌
            if (allies.length > 0) {
                const player = allies[0];
                
                panels.forEach(panel => {
                    const distance = Math.sqrt(
                        Math.pow(player.position.x - panel.position.x, 2) +
                        Math.pow(player.position.z - panel.position.z, 2)
                    );
                    
                    if (distance < 2) {
                        // 패널과 충돌 - 사칙연산 수행
                        if (panel.userData.result !== undefined) {
                            // 패널 획득 효과
                            createPanelEffect(player.position.clone());
                            
                            createAllies(panel.userData.result);
                            
                            // 보너스 점수
                            score += 50;
                            document.getElementById('score').textContent = score;
                            
                            // 모든 패널 제거
                            panels.forEach(p => scene.remove(p));
                            panels = [];
                            
                            // 연산 초기화
                            document.getElementById('currentEquation').textContent = "없음";
                        }
                    }
                });
                
                // 플레이어와 적의 충돌
                enemies.forEach(enemy => {
                    const distance = player.position.distanceTo(enemy.position);
                    if (distance < 1.2) {
                        // 충돌 시 데미지 효과
                        createDamageEffect(player.position.clone());
                        
                        // 충돌 발생 - 아군 감소
                        if (allies.length > 1) {
                            createAllies(allies.length - 1);
                            
                            // 해당 적 제거
                            scene.remove(enemy);
                            enemies.splice(enemies.indexOf(enemy), 1);
                        } else {
                            // 마지막 아군이 적과 충돌하면 게임 오버
                            endGame();
                        }
                    }
                });
            }
        }
        
        // 폭발 효과 생성 함수
        function createExplosion(position) {
            // 폭발 파티클 그룹
            const explosionGroup = new THREE.Group();
            explosionGroup.position.copy(position);
            
            // 폭발 빛
            const explosionLight = new THREE.PointLight(0xff5500, 3, 8);
            explosionLight.position.set(0, 0, 0);
            explosionGroup.add(explosionLight);
            
            // 파티클 생성
            const particleCount = 10;
            const particles = [];
            
            for (let i = 0; i < particleCount; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const particleMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xff5500, 
                    transparent: true, 
                    opacity: 1
                });
                
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                
                // 랜덤 방향으로 튀어나감
                const angle1 = Math.random() * Math.PI * 2;
                const angle2 = Math.random() * Math.PI * 2;
                
                const speed = 0.1 + Math.random() * 0.2;
                particle.userData.velocity = new THREE.Vector3(
                    Math.sin(angle1) * Math.cos(angle2) * speed,
                    Math.sin(angle1) * Math.sin(angle2) * speed,
                    Math.cos(angle1) * speed
                );
                
                explosionGroup.add(particle);
                particles.push(particle);
            }
            
            scene.add(explosionGroup);
            
            // 0.5초 동안 폭발 애니메이션
            let elapsed = 0;
            const duration = 500; // 밀리초
            const interval = setInterval(() => {
                elapsed += 16;
                
                // 파티클 이동 및 페이드 아웃
                particles.forEach(particle => {
                    particle.position.add(particle.userData.velocity);
                    particle.material.opacity = 1 - (elapsed / duration);
                    particle.scale.multiplyScalar(0.98);
                });
                
                // 빛 감소
                explosionLight.intensity = 3 * (1 - elapsed / duration);
                
                if (elapsed >= duration) {
                    clearInterval(interval);
                    scene.remove(explosionGroup);
                }
            }, 16);
        }
        
        // 패널 획득 효과
        function createPanelEffect(position) {
            // 빛 생성
            const light = new THREE.PointLight(0x00ffff, 3, 10);
            light.position.copy(position);
            scene.add(light);
            
            // 0.5초 동안 빛 효과
            let elapsed = 0;
            const duration = 500; // 밀리초
            const interval = setInterval(() => {
                elapsed += 16;
                
                // 빛 강도 조절
                light.intensity = 3 * (1 - elapsed / duration);
                
                if (elapsed >= duration) {
                    clearInterval(interval);
                    scene.remove(light);
                }
            }, 16);
        }
        
        // 데미지 효과
        function createDamageEffect(position) {
            // 빨간 빛 생성
            const light = new THREE.PointLight(0xff0000, 3, 10);
            light.position.copy(position);
            scene.add(light);
            
            // 화면 빨갛게 깜빡임 (CSS 효과)
            const overlay = document.createElement('div');
            overlay.style.position = 'absolute';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.width = '100%';
            overlay.style.height = '100%';
            overlay.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
            overlay.style.pointerEvents = 'none';
            overlay.style.transition = 'opacity 0.5s';
            document.body.appendChild(overlay);
            
            // 0.5초 동안 효과
            setTimeout(() => {
                overlay.style.opacity = '0';
                setTimeout(() => {
                    document.body.removeChild(overlay);
                }, 500);
            }, 100);
            
            // 빛 효과 제거
            setTimeout(() => {
                scene.remove(light);
            }, 500);
        }
        
        // 게임 타이머 함수
        function startGameTimer() {
            const timerInterval = setInterval(() => {
                if (!gameActive) {
                    clearInterval(timerInterval);
                    return;
                }
                
                gameTime--;
                document.getElementById('timer').textContent = gameTime;
                
                if (gameTime <= 0) {
                    clearInterval(timerInterval);
                    endGame();
                }
            }, 1000);
        }
        
        // 게임 종료 함수
        function endGame() {
            gameActive = false;
            document.getElementById('gameOver').style.display = 'block';
            document.getElementById('finalScore').textContent = score;
            
            // 게임 오버 효과
            const gameOverLight = new THREE.AmbientLight(0xff0000, 0.3);
            scene.add(gameOverLight);
            
            // 모든 아군 회전 애니메이션
            const rotateAllies = () => {
                allies.forEach(ally => {
                    ally.rotation.y += 0.05;
                });
                
                if (gameActive) {
                    return;
                }
                
                requestAnimationFrame(rotateAllies);
            };
            
            rotateAllies();
        }
        
        // 게임 재시작 함수
        function restartGame() {
            // 기존 오브젝트 정리
            allies.forEach(ally => scene.remove(ally));
            enemies.forEach(enemy => scene.remove(enemy));
            bullets.forEach(bullet => scene.remove(bullet));
            panels.forEach(panel => scene.remove(panel));
            
            // 씬의 모든 빛 제거 (게임 오버 효과 제거)
            scene.children.forEach(child => {
                if (child instanceof THREE.Light && !(child instanceof THREE.DirectionalLight) && !(child instanceof THREE.AmbientLight && child.intensity === 0.6)) {
                    scene.remove(child);
                }
            });
            
            allies = [];
            enemies = [];
            bullets = [];
            panels = [];
            
            // 변수 초기화
            gameTime = 60;
            score = 0;
            difficulty = 1;
            gameActive = true;
            lastPanelTime = 0;
            lastEnemyWaveTime = 0;
            playerLane = 1; // 중앙 레인으로 초기화
            isMoving = false;
            roadSpeed = 0.5;
            gameDistance = 0;
            
            // UI 초기화
            document.getElementById('timer').textContent = gameTime;
            document.getElementById('score').textContent = score;
            document.getElementById('currentEquation').textContent = "없음";
            document.getElementById('gameOver').style.display = 'none';
            
            // 기본 조명 재설정
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(0, 20, 10);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // 첫 아군 생성
            createAllies(1);
            
            // 타이머 재시작
            startGameTimer();
        }
        
        // 애니메이션 루프
        function animate() {
            requestAnimationFrame(animate);
            
            if (gameActive) {
                updateGame();
            }
            
            renderer.render(scene, camera);
        }
        
        // 화면 크기 조정 이벤트
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // 게임 시작
        init();
    </script>
</body>
</html>
</antArtifact><antArtifact identifier="enhanced-game" type="application/vnd.ant.code" language="html" title="Enhanced Math Runner 3D Game">
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>러너 3D 슈팅 게임</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: Arial, sans-serif; 
            touch-action: none;
        }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            padding: 5px;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 1px 1px 1px black;
            z-index: 10;
        }
        #equationInfo {
            position: absolute;
            top: 40px;
            width: 100%;
            text-align: center;
            color: #ffcc00;
            padding: 5px;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 1px 1px 1px black;
            z-index: 10;
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none;
            z-index: 20;
        }
        #restartBtn {
            padding: 15px 30px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 18px;
            margin-top: 20px;
        }
        #restartBtn:hover {
            background-color: #45a049;
        }
        #controls {
            position: absolute;
            bottom: 30px;
            width: 100%;
            display: flex;
            justify-content: center;
            z-index: 10;
        }
        .controlBtn {
            width: 80px;
            height: 80px;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 40px;
            margin: 0 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
            user-select: none;
        }
    </style>
</head>
<body>
    <div id="info">아군: <span id="allyCount">1</span> | 시간: <span id="timer">60</span>초 | 점수: <span id="score">0</span></div>
    <div id="equationInfo">현재 패널: <span id="currentEquation">없음</span></div>
    <div id="gameOver">
        <h2>게임 종료!</h2>
        <p>최종 점수: <span id="finalScore">0</span></p>
        <button id="restartBtn">다시 시작</button>
    </div>
    <div id="controls">
        <div id="leftBtn" class="controlBtn">←</div>
        <div id="rightBtn" class="controlBtn">→</div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // 게임 변수
        let scene, camera, renderer, allies = [], enemies = [], bullets = [], panels = [];
        let gameTime = 60; // 1분
        let score = 0;
        let difficulty = 1;
        let gameActive = true;
        let lastPanelTime = 0;
        let lastEnemyWaveTime = 0;
        let lastFireTime = 0;
        let playerLane = 1; // 0: 왼쪽, 1: 중앙, 2: 오른쪽
        let isMoving = false;
        let roadSpeed = 0.5;
        let roadSegments = [];
        let gameDistance = 0;
        let activeEquation = "";
        
        // 레인 위치 정의
        const lanes = [-5, 0, 5];
        
        // 수학 연산자 (각각 강한 네온 색상으로 변경)
        const operators = [
            { symbol: "+", fn: (a, b) => a + b, color: 0x00FFFF, glow: 0x00FFFF }, // 네온 청록색
            { symbol: "-", fn: (a, b) => Math.max(1, a - b), color: 0xFF1493, glow: 0xFF1493 }, // 네온 핑크
            { symbol: "×", fn: (a, b) => a * b, color: 0x39FF14, glow: 0x39FF14 }, // 네온 그린
            { symbol: "÷", fn: (a, b) => Math.round(a / b) || 1, color: 0xFFD700, glow: 0xFFD700 } // 네온 골드
        ];
        
        // 게임 초기화
        function init() {
            // 씬 설정
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e); // 어두운 남색 배경
            
            // 안개 추가 (원근감) - 더 짙게 설정
            scene.fog = new THREE.Fog(0x1a1a2e, 30, 80);
            
            // 카메라 설정
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 8, 12); // 카메라 높이와 거리 조정
            camera.lookAt(0, 0, -20);
            
            // 렌더러 설정
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; // 그림자 활성화
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);
            
            // 조명 설정
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(0, 20, 10);
            directionalLight.castShadow = true; // 그림자 생성
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -20;
            directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20;
            directionalLight.shadow.camera.bottom = -20;
            scene.add(directionalLight);
            
            // 도로 생성
            createRoad();
            
            // 첫 아군 생성
            createAllies(1);
            
            // 이벤트 리스너
            window.addEventListener('resize', onWindowResize);
            document.getElementById('restartBtn').addEventListener('click', restartGame);
            
            // 모바일 컨트롤 초기화
            initControls();
            
            // 게임 타이머 시작
            startGameTimer();
            
            // 게임 루프 시작
            animate();
        }
        
        // 도로 생성 함수
        function createRoad() {
            // 도로 텍스처 (하늘색 그라데이션 패턴으로 변경)
            const roadWidth = 15;
            const roadLength = 1000;
            const segmentLength = 20;
            const segments = roadLength / segmentLength;
            
            // 도로 기본 재질 (네온 효과가 있는 어두운 색상)
            const roadMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x0f3460,
                roughness: 0.5,
                metalness: 0.7,
                emissive: 0x0f3460,
                emissiveIntensity: 0.2
            });
            
            // 도로 경계선 재질 (밝은 네온 색상)
            const lineMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xE94560, 
                emissive: 0xE94560,
                emissiveIntensity: 0.7
            });
            
            // 도로 가장자리 재질 (네온 푸른색)
            const sideMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x16213E,
                emissive: 0x0F52BA,
                emissiveIntensity: 0.3
            });
            
            // 도로 그라데이션을 위한 재질 배열 (네온 효과가 있는 패턴)
            const patternMaterials = [
                new THREE.MeshStandardMaterial({ 
                    color: 0x0f3460, 
                    emissive: 0x0f3460,
                    emissiveIntensity: 0.2
                }),
                new THREE.MeshStandardMaterial({ 
                    color: 0x16213E, 
                    emissive: 0x16213E,
                    emissiveIntensity: 0.2
                })
            ];
            
            // 여러 세그먼트로 도로 생성
            for (let i = 0; i < segments; i++) {
                // 도로 세그먼트 (패턴 적용)
                const roadGeometry = new THREE.PlaneGeometry(roadWidth, segmentLength);
                const road = new THREE.Mesh(roadGeometry, patternMaterials[i % 2]); // 번갈아가며 패턴 적용
                road.rotation.x = -Math.PI / 2;
                road.position.z = -i * segmentLength - segmentLength / 2;
                road.position.y = -0.1;
                road.receiveShadow = true; // 그림자 받기
                scene.add(road);
                roadSegments.push(road);
                
                // 도로 레인 구분선
                for (let j = -1; j <= 1; j += 2) {
                    const lineGeometry = new THREE.PlaneGeometry(0.3, segmentLength);
                    const line = new THREE.Mesh(lineGeometry, lineMaterial);
                    line.rotation.x = -Math.PI / 2;
                    line.position.set(j * roadWidth/6, -0.05, -i * segmentLength - segmentLength / 2);
                    line.receiveShadow = true;
                    scene.add(line);
                    roadSegments.push(line);
                }
                
                // 도로 가장자리
                for (let j = -1; j <= 1; j += 2) {
                    const sideGeometry = new THREE.BoxGeometry(2, 1, segmentLength);
                    const side = new THREE.Mesh(sideGeometry, sideMaterial);
                    side.position.set(j * (roadWidth/2 + 1), 0.4, -i * segmentLength - segmentLength / 2);
                    side.castShadow = true;
                    side.receiveShadow = true;
                    scene.add(side);
                    roadSegments.push(side);
                    
                    // 가드레일 기둥 추가
                    if (i % 2 === 0) {
                        const postGeometry = new THREE.BoxGeometry(0.5, 2, 0.5);
                        const postMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
                        const post = new THREE.Mesh(postGeometry, postMaterial);
                        post.position.set(j * (roadWidth/2 + 1), 1.5, -i * segmentLength - segmentLength / 2);
                        post.castShadow = true;
                        post.receiveShadow = true;
                        scene.add(post);
                        roadSegments.push(post);
                    }
                }
            }
        }
        
        // 도로 스크롤 함수
        function scrollRoad() {
            const resetPos = -1000; // 도로 총 길이
            
            roadSegments.forEach(segment => {
                segment.position.z += roadSpeed;
                
                // 도로 세그먼트가 카메라 뒤로 지나가면 다시 앞으로 재배치
                if (segment.position.z > 20) {
                    segment.position.z = resetPos + (segment.position.z - 20);
                }
            });
            
            // 거리 증가
            gameDistance += roadSpeed;
        }
        
        // 컨트롤 초기화
        function initControls() {
            const leftBtn = document.getElementById('leftBtn');
            const rightBtn = document.getElementById('rightBtn');
            
            // 터치 이벤트
            leftBtn.addEventListener('touchstart', moveLeft);
            rightBtn.addEventListener('touchstart', moveRight);
            
            // 마우스 이벤트 (데스크톱용)
            leftBtn.addEventListener('mousedown', moveLeft);
            rightBtn.addEventListener('mousedown', moveRight);
            
            // 키보드 이벤트
            window.addEventListener('keydown', function(e) {
                if (!gameActive || isMoving) return;
                
                if (e.key === 'ArrowLeft') {
                    moveLeft();
                } else if (e.key === 'ArrowRight') {
                    moveRight();
                }
            });
            
            function moveLeft() {
                if (!gameActive || isMoving || playerLane === 0) return;
                
                isMoving = true;
                playerLane--;
                moveAlliesTo(lanes[playerLane]);
            }
            
            function moveRight() {
                if (!gameActive || isMoving || playerLane === 2) return;
                
                isMoving = true;
                playerLane++;
                moveAlliesTo(lanes[playerLane]);
            }
        }
        
        // 아군 이동 함수
        function moveAlliesTo(targetX) {
            // 0.3초에 걸쳐 부드럽게 이동
            const frames = 15; // 60fps 기준 0.25초
            let currentFrame = 0;
            
            // 메인 아군 현재 위치
            const startX = allies[0].position.x;
            const moveAmount = (targetX - startX) / frames;
            
            const moveInterval = setInterval(() => {
                if (currentFrame >= frames) {
                    clearInterval(moveInterval);
                    isMoving = false;
                    return;
                }
                
                // 모든 아군 이동
                allies.forEach((ally, index) => {
                    if (index === 0) {
                        // 메인 아군
                        ally.position.x += moveAmount;
                    } else {
                        // 나머지 아군들은 메인 아군을 따라감
                        updateAllyFormation();
                    }
                });
                
                currentFrame++;
            }, 1000/60); // 60fps
        }
        
        // 아군 진형 업데이트
        function updateAllyFormation() {
            if (allies.length <= 1) return;
            
            const mainAlly = allies[0];
            const allyCount = allies.length;
            
            // 진영 크기 계산 - 아군이 많을수록 더 넓게 퍼짐
            const formationWidth = Math.min(3, 0.5 + (allyCount * 0.1));
            const formationDepth = Math.min(4, 1 + (allyCount * 0.15));
            
            for (let i = 1; i < allyCount; i++) {
                // 균등하게 분포된 위치 계산
                let row = Math.floor((i-1) / 3);
                let col = (i-1) % 3;
                
                // 중앙 정렬을 위한 오프셋
                let colOffset = col - 1; // -1, 0, 1
                let rowOffset = -row; // 항상 플레이어 뒤에 배치
                
                allies[i].position.x = mainAlly.position.x + (colOffset * formationWidth);
                allies[i].position.z = mainAlly.position.z + (rowOffset * formationDepth);
            }
        }
        
        // 아군 생성 함수 - 캐릭터 디자인 개선
        function createAllies(count) {
            // 기존 아군 제거
            allies.forEach(ally => scene.remove(ally));
            allies = [];
            
            // 최댓값 제한 (너무 많으면 게임이 쉬워짐)
            count = Math.min(count, 30);
            
            // 새 아군 생성 - 귀여운 오렌지색 캐릭터로 변경
            for (let i = 0; i < count; i++) {
                // 캐릭터 그룹
                const character = new THREE.Group();
                
                // 몸체 (구)
                const bodyGeometry = new THREE.SphereGeometry(0.5, 16, 16);
                const bodyMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFF9900, // 오렌지색
                    emissive: 0xAA5500,
                    emissiveIntensity: 0.2,
                    roughness: 0.7
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.castShadow = true;
                body.receiveShadow = true;
                character.add(body);
                
                // 캐릭터에 눈 추가
                const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
                
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(0.2, 0.2, 0.4);
                character.add(leftEye);
                
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(-0.2, 0.2, 0.4);
                character.add(rightEye);
                
                // 눈동자
                const pupilGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                const pupilMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
                
                const leftPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                leftPupil.position.set(0.2, 0.2, 0.45);
                character.add(leftPupil);
                
                const rightPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                rightPupil.position.set(-0.2, 0.2, 0.45);
                character.add(rightPupil);
                
                // 팔과 다리 추가 (메인 캐릭터만)
                if (i === 0) {
                    // 팔
                    const armGeometry = new THREE.SphereGeometry(0.15, 8, 8);
                    
                    const leftArm = new THREE.Mesh(armGeometry, bodyMaterial);
                    leftArm.position.set(0.6, 0, 0);
                    leftArm.castShadow = true;
                    character.add(leftArm);
                    
                    const rightArm = new THREE.Mesh(armGeometry, bodyMaterial);
                    rightArm.position.set(-0.6, 0, 0);
                    rightArm.castShadow = true;
                    character.add(rightArm);
                    
                    // 다리
                    const legGeometry = new THREE.CylinderGeometry(0.15, 0.1, 0.5, 8);
                    
                    const leftLeg = new THREE.Mesh(legGeometry, bodyMaterial);
                    leftLeg.position.set(0.2, -0.5, 0);
                    leftLeg.castShadow = true;
                    character.add(leftLeg);
                    
                    const rightLeg = new THREE.Mesh(legGeometry, bodyMaterial);
                    rightLeg.position.set(-0.2, -0.5, 0);
                    rightLeg.castShadow = true;
                    character.add(rightLeg);
                }
                
                if (i === 0) {
                    // 메인 아군 (플레이어)
                    character.position.set(lanes[playerLane], 0.5, 0);
                } else {
                    // 추가 아군들은 초기 위치만 설정 (updateAllyFormation에서 정확히 배치됨)
                    character.position.set(lanes[playerLane], 0.5, -i);
                    // 작게 만들기
                    character.scale.set(0.8, 0.8, 0.8);
                }
                
                scene.add(character);
                allies.push(character);
            }
            
            // 진형 업데이트
            updateAllyFormation();
            
            // UI 업데이트
            document.getElementById('allyCount').textContent = allies.length;
        }
        
        // 적 생성 함수 - 웨이브 형태로 생성
        function createEnemyWave() {
            const waveType = Math.floor(Math.random() * 4);
            
            switch (waveType) {
                case 0: // 일렬 웨이브
                    const randomLane = Math.floor(Math.random() * 3);
                    for (let i = 0; i < 5 + Math.floor(difficulty); i++) {
                        createEnemy(randomLane, -80 - (i * 4));
                    }
                    break;
                    
                case 1: // V 형태 웨이브
                    for (let i = 0; i < 7; i++) {
                        const laneOffset = (i <= 3) ? i : 6 - i; // 0,1,2,3,2,1,0
                        createEnemy(laneOffset, -80 - (i * 3));
                    }
                    break;
                    
                case 2: // 모든 레인 웨이브
                    for (let i = 0; i < 3; i++) {
                        for (let j = 0; j < 3; j++) {
                            createEnemy(j, -80 - (i * 5));
                        }
                    }
                    break;
                    
                case 3: // 랜덤 웨이브
                    const enemyCount = 5 + Math.floor(difficulty * 2);
                    for (let i = 0; i < enemyCount; i++) {
                        const randLane = Math.floor(Math.random() * 3);
                        const randDist = -80 - (Math.random() * 20);
                        createEnemy(randLane, randDist);
                    }
                    break;
            }
            
            function createEnemy(lane, zPos) {
                // 적 그룹
                const enemy = new THREE.Group();
                
                // 적 몸체 (더 큰 크기와 강한 네온 빨간색)
                const enemyGeometry = new THREE.SphereGeometry(0.6, 16, 16);
                const enemyMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xff0000,
                    emissive: 0xff0000,
                    emissiveIntensity: 0.8,
                    roughness: 0.3,
                    metalness: 0.7
                });
                const body = new THREE.Mesh(enemyGeometry, enemyMaterial);
                body.castShadow = true;
                body.receiveShadow = true;
                enemy.add(body);
                
                // 적 눈 (흰색)
                const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
                
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(0.2, 0.2, 0.4);
                enemy.add(leftEye);
                
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(-0.2, 0.2, 0.4);
                enemy.add(rightEye);
                
                // 적 눈동자 (검은색)
                const pupilGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                const pupilMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
                
                const leftPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                leftPupil.position.set(0.2, 0.2, 0.45);
                enemy.add(leftPupil);
                
                const rightPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                rightPupil.position.set(-0.2, 0.2, 0.45);
                enemy.add(rightPupil);
                
                enemy.position.set(lanes[lane], 0.5, zPos);
                scene.add(enemy);
                enemies.push(enemy);
            }
        }
        
        // 총알 발사 함수
        function fireBullets() {
            const currentTime = Date.now();
            
            // 자동 발사 간격 (아군 수에 따라 감소)
            const fireInterval = Math.max(100, 500 - (allies.length * 10));
            
            if (currentTime - lastFireTime < fireInterval) return;
            
            lastFireTime = currentTime;
            
            // 아군 수에 비례해서 총알 발사 (아군당 0.5발의 총알)
            const bulletsToFire = Math.max(1, Math.ceil(allies.length * 0.5));
            
            for (let i = 0; i < bulletsToFire; i++) {
                const bulletGeometry = new THREE.SphereGeometry(0.3, 8, 8);
                const bulletMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFFFF00, 
                    emissive: 0xFFFF00,
                    emissiveIntensity: 1.0,
                    metalness: 1.0,
                    roughness: 0.0
                });
                const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
                
                // 총알 발사 방향 다각화
                let angleOffset = 0;
                if (bulletsToFire > 1) {
                    // 부채꼴 형태로 퍼지게 발사
                    const spreadFactor = Math.min(0.3, bulletsToFire * 0.02);  // 최대 0.3 라디안 (약 17도)
                    angleOffset = spreadFactor * ((i / (bulletsToFire - 1)) * 2 - 1);
                }
                
                // 총알 위치는 무작위 아군 위치에서 시작
                const shooterIndex = Math.floor(Math.random() * allies.length);
                bullet.position.copy(allies[shooterIndex].position);
                bullet.position.z -= 1; // 약간 앞에서 발사
                
                // 총알 방향 설정
                bullet.userData.direction = new THREE.Vector3(angleOffset, 0, -1).normalize();
                bullet.userData.speed = 1.5;
                
                scene.add(bullet);
                bullets.push(bullet);
                
                // 총알 발사 이펙트 (강한 빛)
                const bulletLight = new THREE.PointLight(0xffff00, 5, 8);
                bulletLight.position.copy(bullet.position);
                scene.add(bulletLight);
                
                // 추가 발광 효과 (더 넓은 범위)
                const bulletGlow = new THREE.PointLight(0xffff00, 2, 15);
                bulletGlow.position.copy(bullet.position);
                scene.add(bulletGlow);
                
                // 0.1초 후 이펙트 제거
                setTimeout(() => {
                    scene.remove(bulletLight);
                }, 100);
            }
        }
        
        // 사칙연산 패널 생성 함수
        function createMathPanels() {
            // 기존 패널 제거
            panels.forEach(panel => scene.remove(panel));
            panels = [];
            
            // 랜덤 연산자 선택
            const operator = operators[Math.floor(Math.random() * operators.length)];
            
            // 피연산자 선택 (난이도에 따라 증가)
            const operand = Math.floor(Math.random() * Math.min(5, difficulty)) + 1;
            
            // 현재 아군 수와 연산 결과 계산
            const currentAllies = allies.length;
            const result = operator.fn(currentAllies, operand);
            
            // 연산 표시 업데이트
            activeEquation = `${currentAllies} ${operator.symbol} ${operand} = ${result}`;
            document.getElementById('currentEquation').textContent = activeEquation;
            
            // 도로 세 레인에 패널 생성
            for (let i = 0; i < 3; i++) {
                createMathPanel(lanes[i], -60 - Math.random() * 10, operand, operator);
            }
            
            function createMathPanel(x, z, operand, operator) {
                // 패널 그룹
                const panel = new THREE.Group();
                
                // 패널 플랫폼
                const panelGeometry = new THREE.BoxGeometry(3, 0.3, 3);
                
                // 연산자에 맞는 색상 적용 (강한 네온 효과)
                const panelMaterial = new THREE.MeshStandardMaterial({ 
                    color: operator.color,
                    emissive: operator.glow,
                    emissiveIntensity: 0.8,
                    transparent: true,
                    opacity: 0.9
                });
                
                const panelMesh = new THREE.Mesh(panelGeometry, panelMaterial);
                panelMesh.castShadow = true;
                panelMesh.receiveShadow = true;
                panel.add(panelMesh);
                
                // 패널에 숫자 표시를 위한 텍스트 (Three.js에서는 실제 텍스트 렌더링이 어려워 대체 표현)
                const operatorSymbol = operator.symbol;
                const operatorTextGeometry = new THREE.BoxGeometry(1, 0.1, 1);
                const operatorTextMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFFFFFF,
                    emissive: 0xFFFFFF,
                    emissiveIntensity: 0.5
                });
                
                const operatorText = new THREE.Mesh(operatorTextGeometry, operatorTextMaterial);
                operatorText.position.y = 0.2;
                panel.add(operatorText);
                
                // 숫자 표시 (간소화된 형태)
                const numberGeometry = new THREE.BoxGeometry(0.5, 0.1, 0.5);
                const numberMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
                const numberMesh = new THREE.Mesh(numberGeometry, numberMaterial);
                numberMesh.position.set(0, 0.2, 0.5);
                panel.add(numberMesh);
                
                // 패널 위치 설정
                panel.position.set(x, 0, z);
                
                // 패널에 연산 데이터 추가
                panel.userData = {
                    operator: operatorSymbol,
                    operand: operand,
                    result: result
                };
                
                // 패널 발광 효과
                const panelLight = new THREE.PointLight(operator.color, 1, 5);
                panelLight.position.set(0, 0.5, 0);
                panel.add(panelLight);
                
                scene.add(panel);
                panels.push(panel);
            }
        }
        
        // 게임 업데이트 함수
        function updateGame() {
            const currentTime = Date.now();
            
            // 도로 스크롤
            scrollRoad();
            
            // 3초마다 패널 생성
            if (currentTime - lastPanelTime > 3000) {
                createMathPanels();
                lastPanelTime = currentTime;
            }
            
            // 난이도에 따라 적 웨이브 생성 주기 조절
            const enemyWaveInterval = Math.max(2000, 5000 - (difficulty * 300));
            if (currentTime - lastEnemyWaveTime > enemyWaveInterval) {
                createEnemyWave();
                lastEnemyWaveTime = currentTime;
            }
            
            // 자동 총알 발사
            fireBullets();
            
            // 패널 이동 (도로와 함께 이동)
            panels.forEach(panel => {
                panel.position.z += roadSpeed;
                
                // 화면 끝에 도달한 패널은 제거
                if (panel.position.z > 10) {
                    scene.remove(panel);
                    panels.splice(panels.indexOf(panel), 1);
                    
                    // 모든 패널이 사라졌을 때 현재 연산 초기화
                    if (panels.length === 0) {
                        document.getElementById('currentEquation').textContent = "없음";
                    }
                }
            });
            
            // 적 이동 (도로와 함께 이동, 약간 더 빠르게)
            enemies.forEach(enemy => {
                enemy.position.z += roadSpeed * 1.2;
                
                // 화면 끝에 도달한 적은 제거
                if (enemy.position.z > 10) {
                    scene.remove(enemy);
                    enemies.splice(enemies.indexOf(enemy), 1);
                }
                
                // 적 애니메이션 (약간 상하로 움직임)
                enemy.position.y = 0.5 + Math.sin(currentTime / 300 + enemy.position.z) * 0.1;
                
                // 추가: 적 회전 애니메이션
                enemy.rotation.y += 0.02;
            });
            
            // 아군 애니메이션 (약간 위아래로 움직임)
            allies.forEach((ally, index) => {
                // 메인 캐릭터 (0번 인덱스)만 특별한 애니메이션 적용
                if (index === 0) {
                    ally.position.y = 0.5 + Math.sin(currentTime / 500) * 0.05;
                    
                    // 달리기 애니메이션 효과 (앞뒤로 약간 기울임)
                    ally.rotation.x = Math.sin(currentTime / 200) * 0.1;
                } else {
                    // 다른 아군들은 약간 다른 주기로 움직여 자연스러움 증가
                    ally.position.y = 0.5 + Math.sin((currentTime / 500) + index * 0.5) * 0.05;
                }
            });
            
            // 총알 이동
            bullets.forEach(bullet => {
                const direction = bullet.userData.direction;
                bullet.position.x += direction.x * bullet.userData.speed;
                bullet.position.z += direction.z * bullet.userData.speed;
                
                // 총알 회전 효과 추가
                bullet.rotation.x += 0.2;
                bullet.rotation.y += 0.2;
                
                // 화면 밖으로 나간 총알 제거
                if (bullet.position.z < -100) {
                    scene.remove(bullet);
                    bullets.splice(bullets.indexOf(bullet), 1);
                }
            });
            
            // 충돌 체크
            checkCollisions();
            
            // 난이도 증가
            difficulty = 1 + ((60 - gameTime) / 5);
            
            // 도로 속도 증가 (난이도에 따라)
            roadSpeed = 0.5 + (difficulty * 0.05);
        }
        
        // 충돌 체크 함수 - 시각적 효과 추가
        function checkCollisions() {
            // 총알과 적의 충돌
            bullets.forEach(bullet => {
                enemies.forEach(enemy => {
                    const distance = bullet.position.distanceTo(enemy.position);
                    if (distance < 1) {
                        // 충돌 시 폭발 효과
                        createExplosion(enemy.position.clone());
                        
                        // 충돌 발생
                        scene.remove(bullet);
                        scene.remove(enemy);
                        bullets.splice(bullets.indexOf(bullet), 1);
                        enemies.splice(enemies.indexOf(enemy), 1);
                        
                        // 점수 추가
                        score += 10;
                        document.getElementById('score').textContent = score;
                    }
                });
            });
            
            // 플레이어(메인 아군)와 패널의 충돌
            if (allies.length > 0) {
                const player = allies[0];
                
                panels.forEach(panel => {
                    const distance = Math.sqrt(
                        Math.pow(player.position.x - panel.position.x, 2) +
                        Math.pow(player.position.z - panel.position.z, 2)
                    );
                    
                    if (distance < 2) {
                        // 패널과 충돌 - 사칙연산 수행
                        if (panel.userData.result !== undefined) {
                            // 패널 획득 효과
                            createPanelEffect(player.position.clone());
                            
                            createAllies(panel.userData.result);
                            
                            // 보너스 점수
                            score += 50;
                            document.getElementById('score').textContent = score;
                            
                            // 모든 패널 제거
                            panels.forEach(p => scene.remove(p));
                            panels = [];
                            
                            // 연산 초기화
                            document.getElementById('currentEquation').textContent = "없음";
                        }
                    }
                });
                
                // 플레이어와 적의 충돌
                enemies.forEach(enemy => {
                    const distance = player.position.distanceTo(enemy.position);
                    if (distance < 1.2) {
                        // 충돌 시 데미지 효과
                        createDamageEffect(player.position.clone());
                        
                        // 충돌 발생 - 아군 감소
                        if (allies.length > 1) {
                            createAllies(allies.length - 1);
                            
                            // 해당 적 제거
                            scene.remove(enemy);
                            enemies.splice(enemies.indexOf(enemy), 1);
                        } else {
                            // 마지막 아군이 적과 충돌하면 게임 오버
                            endGame();
                        }
                    }
                });
            }
        }
        
        // 폭발 효과 생성 함수
        function createExplosion(position) {
            // 폭발 파티클 그룹
            const explosionGroup = new THREE.Group();
            explosionGroup.position.copy(position);
            
            // 폭발 빛
            const explosionLight = new THREE.PointLight(0xff5500, 3, 8);
            explosionLight.position.set(0, 0, 0);
            explosionGroup.add(explosionLight);
            
            // 파티클 생성
            const particleCount = 10;
            const particles = [];
            
            for (let i = 0; i < particleCount; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const particleMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xff5500, 
                    transparent: true, 
                    opacity: 1
                });
                
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                
                // 랜덤 방향으로 튀어나감
                const angle1 = Math.random() * Math.PI * 2;
                const angle2 = Math.random() * Math.PI * 2;
                
                const speed = 0.1 + Math.random() * 0.2;
                particle.userData.velocity = new THREE.Vector3(
                    Math.sin(angle1) * Math.cos(angle2) * speed,
                    Math.sin(angle1) * Math.sin(angle2) * speed,
                    Math.cos(angle1) * speed
                );
                
                explosionGroup.add(particle);
                particles.push(particle);
            }
            
            scene.add(explosionGroup);
            
            // 0.5초 동안 폭발 애니메이션
            let elapsed = 0;
            const duration = 500; // 밀리초
            const interval = setInterval(() => {
                elapsed += 16;
                
                // 파티클 이동 및 페이드 아웃
                particles.forEach(particle => {
                    particle.position.add(particle.userData.velocity);
                    particle.material.opacity = 1 - (elapsed / duration);
                    particle.scale.multiplyScalar(0.98);
                });
                
                // 빛 감소
                explosionLight.intensity = 3 * (1 - elapsed / duration);
                
                if (elapsed >= duration) {
                    clearInterval(interval);
                    scene.remove(explosionGroup);
                }
            }, 16);
        }
        
        // 패널 획득 효과
        function createPanelEffect(position) {
            // 빛 생성
            const light = new THREE.PointLight(0x00ffff, 3, 10);
            light.position.copy(position);
            scene.add(light);
            
            // 0.5초 동안 빛 효과
            let elapsed = 0;
            const duration = 500; // 밀리초
            const interval = setInterval(() => {
                elapsed += 16;
                
                // 빛 강도 조절
                light.intensity = 3 * (1 - elapsed / duration);
                
                if (elapsed >= duration) {
                    clearInterval(interval);
                    scene.remove(light);
                }
            }, 16);
        }
        
        // 데미지 효과
        function createDamageEffect(position) {
            // 빨간 빛 생성
            const light = new THREE.PointLight(0xff0000, 3, 10);
            light.position.copy(position);
            scene.add(light);
            
            // 화면 빨갛게 깜빡임 (CSS 효과)
            const overlay = document.createElement('div');
            overlay.style.position = 'absolute';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.width = '100%';
            overlay.style.height = '100%';
            overlay.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
            overlay.style.pointerEvents = 'none';
            overlay.style.transition = 'opacity 0.5s';
            document.body.appendChild(overlay);
            
            // 0.5초 동안 효과
            setTimeout(() => {
                overlay.style.opacity = '0';
                setTimeout(() => {
                    document.body.removeChild(overlay);
                }, 500);
            }, 100);
            
            // 빛 효과 제거
            setTimeout(() => {
                scene.remove(light);
            }, 500);
        }
        
        // 게임 타이머 함수
        function startGameTimer() {
            const timerInterval = setInterval(() => {
                if (!gameActive) {
                    clearInterval(timerInterval);
                    return;
                }
                
                gameTime--;
                document.getElementById('timer').textContent = gameTime;
                
                if (gameTime <= 0) {
                    clearInterval(timerInterval);
                    endGame();
                }
            }, 1000);
        }
        
        // 게임 종료 함수
        function endGame() {
            gameActive = false;
            document.getElementById('gameOver').style.display = 'block';
            document.getElementById('finalScore').textContent = score;
            
            // 게임 오버 효과
            const gameOverLight = new THREE.AmbientLight(0xff0000, 0.3);
            scene.add(gameOverLight);
            
            // 모든 아군 회전 애니메이션
            const rotateAllies = () => {
                allies.forEach(ally => {
                    ally.rotation.y += 0.05;
                });
                
                if (gameActive) {
                    return;
                }
                
                requestAnimationFrame(rotateAllies);
            };
            
            rotateAllies();
        }
        
        // 게임 재시작 함수
        function restartGame() {
            // 기존 오브젝트 정리
            allies.forEach(ally => scene.remove(ally));
            enemies.forEach(enemy => scene.remove(enemy));
            bullets.forEach(bullet => scene.remove(bullet));
            panels.forEach(panel => scene.remove(panel));
            
            // 씬의 모든 빛 제거 (게임 오버 효과 제거)
            scene.children.forEach(child => {
                if (child instanceof THREE.Light && !(child instanceof THREE.DirectionalLight) && !(child instanceof THREE.AmbientLight && child.intensity === 0.6)) {
                    scene.remove(child);
                }
            });
            
            allies = [];
            enemies = [];
            bullets = [];
            panels = [];
            
            // 변수 초기화
            gameTime = 60;
            score = 0;
            difficulty = 1;
            gameActive = true;
            lastPanelTime = 0;
            lastEnemyWaveTime = 0;
            playerLane = 1; // 중앙 레인으로 초기화
            isMoving = false;
            roadSpeed = 0.5;
            gameDistance = 0;
            
            // UI 초기화
            document.getElementById('timer').textContent = gameTime;
            document.getElementById('score').textContent = score;
            document.getElementById('currentEquation').textContent = "없음";
            document.getElementById('gameOver').style.display = 'none';
            
            // 기본 조명 재설정
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(0, 20, 10);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // 첫 아군 생성
            createAllies(1);
            
            // 타이머 재시작
            startGameTimer();
        }
        
        // 애니메이션 루프
        function animate() {
            requestAnimationFrame(animate);
            
            if (gameActive) {
                updateGame();
            }
            
            renderer.render(scene, camera);
        }
        
        // 화면 크기 조정 이벤트
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // 게임 시작
        init();
    </script>
</body>
</html>
</antArtifact><antArtifact identifier="enhanced-game" type="application/vnd.ant.code" language="html" title="Enhanced Math Runner 3D Game">
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>러너 3D 슈팅 게임</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: Arial, sans-serif; 
            touch-action: none;
        }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            padding: 5px;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 1px 1px 1px black;
            z-index: 10;
        }
        #equationInfo {
            position: absolute;
            top: 40px;
            width: 100%;
            text-align: center;
            color: #ffcc00;
            padding: 5px;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 1px 1px 1px black;
            z-index: 10;
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none;
            z-index: 20;
        }
        #restartBtn {
            padding: 15px 30px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 18px;
            margin-top: 20px;
        }
        #restartBtn:hover {
            background-color: #45a049;
        }
        #controls {
            position: absolute;
            bottom: 30px;
            width: 100%;
            display: flex;
            justify-content: center;
            z-index: 10;
        }
        .controlBtn {
            width: 80px;
            height: 80px;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 40px;
            margin: 0 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
            user-select: none;
        }
    </style>
</head>
<body>
    <div id="info">아군: <span id="allyCount">1</span> | 시간: <span id="timer">60</span>초 | 점수: <span id="score">0</span></div>
    <div id="equationInfo">현재 패널: <span id="currentEquation">없음</span></div>
    <div id="gameOver">
        <h2>게임 종료!</h2>
        <p>최종 점수: <span id="finalScore">0</span></p>
        <button id="restartBtn">다시 시작</button>
    </div>
    <div id="controls">
        <div id="leftBtn" class="controlBtn">←</div>
        <div id="rightBtn" class="controlBtn">→</div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // 게임 변수
        let scene, camera, renderer, allies = [], enemies = [], bullets = [], panels = [];
        let gameTime = 60; // 1분
        let score = 0;
        let difficulty = 1;
        let gameActive = true;
        let lastPanelTime = 0;
        let lastEnemyWaveTime = 0;
        let lastFireTime = 0;
        let playerLane = 1; // 0: 왼쪽, 1: 중앙, 2: 오른쪽
        let isMoving = false;
        let roadSpeed = 0.5;
        let roadSegments = [];
        let gameDistance = 0;
        let activeEquation = "";
        
        // 레인 위치 정의
        const lanes = [-5, 0, 5];
        
        // 수학 연산자 (각각 강한 네온 색상으로 변경)
        const operators = [
            { symbol: "+", fn: (a, b) => a + b, color: 0x00FFFF, glow: 0x00FFFF }, // 네온 청록색
            { symbol: "-", fn: (a, b) => Math.max(1, a - b), color: 0xFF1493, glow: 0xFF1493 }, // 네온 핑크
            { symbol: "×", fn: (a, b) => a * b, color: 0x39FF14, glow: 0x39FF14 }, // 네온 그린
            { symbol: "÷", fn: (a, b) => Math.round(a / b) || 1, color: 0xFFD700, glow: 0xFFD700 } // 네온 골드
        ];
        
        // 게임 초기화
        function init() {
            // 씬 설정
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e); // 어두운 남색 배경
            
            // 안개 추가 (원근감) - 더 짙게 설정
            scene.fog = new THREE.Fog(0x1a1a2e, 30, 80);
            
            // 카메라 설정
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 8, 12); // 카메라 높이와 거리 조정
            camera.lookAt(0, 0, -20);
            
            // 렌더러 설정
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; // 그림자 활성화
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);
            
            // 조명 설정
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(0, 20, 10);
            directionalLight.castShadow = true; // 그림자 생성
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -20;
            directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20;
            directionalLight.shadow.camera.bottom = -20;
            scene.add(directionalLight);
            
            // 도로 생성
            createRoad();
            
            // 첫 아군 생성
            createAllies(1);
            
            // 이벤트 리스너
            window.addEventListener('resize', onWindowResize);
            document.getElementById('restartBtn').addEventListener('click', restartGame);
            
            // 모바일 컨트롤 초기화
            initControls();
            
            // 게임 타이머 시작
            startGameTimer();
            
            // 게임 루프 시작
            animate();
        }
        
        // 도로 생성 함수
        function createRoad() {
            // 도로 텍스처 (하늘색 그라데이션 패턴으로 변경)
            const roadWidth = 15;
            const roadLength = 1000;
            const segmentLength = 20;
            const segments = roadLength / segmentLength;
            
            // 도로 기본 재질 (네온 효과가 있는 어두운 색상)
            const roadMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x0f3460,
                roughness: 0.5,
                metalness: 0.7,
                emissive: 0x0f3460,
                emissiveIntensity: 0.2
            });
            
            // 도로 경계선 재질 (밝은 네온 색상)
            const lineMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xE94560, 
                emissive: 0xE94560,
                emissiveIntensity: 0.7
            });
            
            // 도로 가장자리 재질 (네온 푸른색)
            const sideMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x16213E,
                emissive: 0x0F52BA,
                emissiveIntensity: 0.3
            });
            
            // 도로 그라데이션을 위한 재질 배열 (네온 효과가 있는 패턴)
            const patternMaterials = [
                new THREE.MeshStandardMaterial({ 
                    color: 0x0f3460, 
                    emissive: 0x0f3460,
                    emissiveIntensity: 0.2
                }),
                new THREE.MeshStandardMaterial({ 
                    color: 0x16213E, 
                    emissive: 0x16213E,
                    emissiveIntensity: 0.2
                })
            ];
            
            // 여러 세그먼트로 도로 생성
            for (let i = 0; i < segments; i++) {
                // 도로 세그먼트 (패턴 적용)
                const roadGeometry = new THREE.PlaneGeometry(roadWidth, segmentLength);
                const road = new THREE.Mesh(roadGeometry, patternMaterials[i % 2]); // 번갈아가며 패턴 적용
                road.rotation.x = -Math.PI / 2;
                road.position.z = -i * segmentLength - segmentLength / 2;
                road.position.y = -0.1;
                road.receiveShadow = true; // 그림자 받기
                scene.add(road);
                roadSegments.push(road);
                
                // 도로 레인 구분선
                for (let j = -1; j <= 1; j += 2) {
                    const lineGeometry = new THREE.PlaneGeometry(0.3, segmentLength);
                    const line = new THREE.Mesh(lineGeometry, lineMaterial);
                    line.rotation.x = -Math.PI / 2;
                    line.position.set(j * roadWidth/6, -0.05, -i * segmentLength - segmentLength / 2);
                    line.receiveShadow = true;
                    scene.add(line);
                    roadSegments.push(line);
                }
                
                // 도로 가장자리
                for (let j = -1; j <= 1; j += 2) {
                    const sideGeometry = new THREE.BoxGeometry(2, 1, segmentLength);
                    const side = new THREE.Mesh(sideGeometry, sideMaterial);
                    side.position.set(j * (roadWidth/2 + 1), 0.4, -i * segmentLength - segmentLength / 2);
                    side.castShadow = true;
                    side.receiveShadow = true;
                    scene.add(side);
                    roadSegments.push(side);
                    
                    // 가드레일 기둥 추가
                    if (i % 2 === 0) {
                        const postGeometry = new THREE.BoxGeometry(0.5, 2, 0.5);
                        const postMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
                        const post = new THREE.Mesh(postGeometry, postMaterial);
                        post.position.set(j * (roadWidth/2 + 1), 1.5, -i * segmentLength - segmentLength / 2);
                        post.castShadow = true;
                        post.receiveShadow = true;
                        scene.add(post);
                        roadSegments.push(post);
                    }
                }
            }
        }
        
        // 도로 스크롤 함수
        function scrollRoad() {
            const resetPos = -1000; // 도로 총 길이
            
            roadSegments.forEach(segment => {
                segment.position.z += roadSpeed;
                
                // 도로 세그먼트가 카메라 뒤로 지나가면 다시 앞으로 재배치
                if (segment.position.z > 20) {
                    segment.position.z = resetPos + (segment.position.z - 20);
                }
            });
            
            // 거리 증가
            gameDistance += roadSpeed;
        }
        
        // 컨트롤 초기화
        function initControls() {
            const leftBtn = document.getElementById('leftBtn');
            const rightBtn = document.getElementById('rightBtn');
            
            // 터치 이벤트
            leftBtn.addEventListener('touchstart', moveLeft);
            rightBtn.addEventListener('touchstart', moveRight);
            
            // 마우스 이벤트 (데스크톱용)
            leftBtn.addEventListener('mousedown', moveLeft);
            rightBtn.addEventListener('mousedown', moveRight);
            
            // 키보드 이벤트
            window.addEventListener('keydown', function(e) {
                if (!gameActive || isMoving) return;
                
                if (e.key === 'ArrowLeft') {
                    moveLeft();
                } else if (e.key === 'ArrowRight') {
                    moveRight();
                }
            });
            
            function moveLeft() {
                if (!gameActive || isMoving || playerLane === 0) return;
                
                isMoving = true;
                playerLane--;
                moveAlliesTo(lanes[playerLane]);
            }
            
            function moveRight() {
                if (!gameActive || isMoving || playerLane === 2) return;
                
                isMoving = true;
                playerLane++;
                moveAlliesTo(lanes[playerLane]);
            }
        }
        
        // 아군 이동 함수
        function moveAlliesTo(targetX) {
            // 0.3초에 걸쳐 부드럽게 이동
            const frames = 15; // 60fps 기준 0.25초
            let currentFrame = 0;
            
            // 메인 아군 현재 위치
            const startX = allies[0].position.x;
            const moveAmount = (targetX - startX) / frames;
            
            const moveInterval = setInterval(() => {
                if (currentFrame >= frames) {
                    clearInterval(moveInterval);
                    isMoving = false;
                    return;
                }
                
                // 모든 아군 이동
                allies.forEach((ally, index) => {
                    if (index === 0) {
                        // 메인 아군
                        ally.position.x += moveAmount;
                    } else {
                        // 나머지 아군들은 메인 아군을 따라감
                        updateAllyFormation();
                    }
                });
                
                currentFrame++;
            }, 1000/60); // 60fps
        }
        
        // 아군 진형 업데이트
        function updateAllyFormation() {
            if (allies.length <= 1) return;
            
            const mainAlly = allies[0];
            const allyCount = allies.length;
            
            // 진영 크기 계산 - 아군이 많을수록 더 넓게 퍼짐
            const formationWidth = Math.min(3, 0.5 + (allyCount * 0.1));
            const formationDepth = Math.min(4, 1 + (allyCount * 0.15));
            
            for (let i = 1; i < allyCount; i++) {
                // 균등하게 분포된 위치 계산
                let row = Math.floor((i-1) / 3);
                let col = (i-1) % 3;
                
                // 중앙 정렬을 위한 오프셋
                let colOffset = col - 1; // -1, 0, 1
                let rowOffset = -row; // 항상 플레이어 뒤에 배치
                
                allies[i].position.x = mainAlly.position.x + (colOffset * formationWidth);
                allies[i].position.z = mainAlly.position.z + (rowOffset * formationDepth);
            }
        }
        
        // 아군 생성 함수 - 캐릭터 디자인 개선
        function createAllies(count) {
            // 기존 아군 제거
            allies.forEach(ally => scene.remove(ally));
            allies = [];
            
            // 최댓값 제한 (너무 많으면 게임이 쉬워짐)
            count = Math.min(count, 30);
            
            // 새 아군 생성 - 귀여운 오렌지색 캐릭터로 변경
            for (let i = 0; i < count; i++) {
                // 캐릭터 그룹
                const character = new THREE.Group();
                
                // 몸체 (구)
                const bodyGeometry = new THREE.SphereGeometry(0.5, 16, 16);
                const bodyMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFF9900, // 오렌지색
                    emissive: 0xAA5500,
                    emissiveIntensity: 0.2,
                    roughness: 0.7
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.castShadow = true;
                body.receiveShadow = true;
                character.add(body);
                
                // 캐릭터에 눈 추가
                const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
                
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(0.2, 0.2, 0.4);
                character.add(leftEye);
                
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(-0.2, 0.2, 0.4);
                character.add(rightEye);
                
                // 눈동자
                const pupilGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                const pupilMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
                
                const leftPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                leftPupil.position.set(0.2, 0.2, 0.45);
                character.add(leftPupil);
                
                const rightPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                rightPupil.position.set(-0.2, 0.2, 0.45);
                character.add(rightPupil);
                
                // 팔과 다리 추가 (메인 캐릭터만)
                if (i === 0) {
                    // 팔
                    const armGeometry = new THREE.SphereGeometry(0.15, 8, 8);
                    
                    const leftArm = new THREE.Mesh(armGeometry, bodyMaterial);
                    leftArm.position.set(0.6, 0, 0);
                    leftArm.castShadow = true;
                    character.add(leftArm);
                    
                    const rightArm = new THREE.Mesh(armGeometry, bodyMaterial);
                    rightArm.position.set(-0.6, 0, 0);
                    rightArm.castShadow = true;
                    character.add(rightArm);
                    
                    // 다리
                    const legGeometry = new THREE.CylinderGeometry(0.15, 0.1, 0.5, 8);
                    
                    const leftLeg = new THREE.Mesh(legGeometry, bodyMaterial);
                    leftLeg.position.set(0.2, -0.5, 0);
                    leftLeg.castShadow = true;
                    character.add(leftLeg);
                    
                    const rightLeg = new THREE.Mesh(legGeometry, bodyMaterial);
                    rightLeg.position.set(-0.2, -0.5, 0);
                    rightLeg.castShadow = true;
                    character.add(rightLeg);
                }
                
                if (i === 0) {
                    // 메인 아군 (플레이어)
                    character.position.set(lanes[playerLane], 0.5, 0);
                } else {
                    // 추가 아군들은 초기 위치만 설정 (updateAllyFormation에서 정확히 배치됨)
                    character.position.set(lanes[playerLane], 0.5, -i);
                    // 작게 만들기
                    character.scale.set(0.8, 0.8, 0.8);
                }
                
                scene.add(character);
                allies.push(character);
            }
            
            // 진형 업데이트
            updateAllyFormation();
            
            // UI 업데이트
            document.getElementById('allyCount').textContent = allies.length;
        }
        
        // 적 생성 함수 - 웨이브 형태로 생성
        function createEnemyWave() {
            const waveType = Math.floor(Math.random() * 4);
            
            switch (waveType) {
                case 0: // 일렬 웨이브
                    const randomLane = Math.floor(Math.random() * 3);
                    for (let i = 0; i < 5 + Math.floor(difficulty); i++) {
                        createEnemy(randomLane, -80 - (i * 4));
                    }
                    break;
                    
                case 1: // V 형태 웨이브
                    for (let i = 0; i < 7; i++) {
                        const laneOffset = (i <= 3) ? i : 6 - i; // 0,1,2,3,2,1,0
                        createEnemy(laneOffset, -80 - (i * 3));
                    }
                    break;
                    
                case 2: // 모든 레인 웨이브
                    for (let i = 0; i < 3; i++) {
                        for (let j = 0; j < 3; j++) {
                            createEnemy(j, -80 - (i * 5));
                        }
                    }
                    break;
                    
                case 3: // 랜덤 웨이브
                    const enemyCount = 5 + Math.floor(difficulty * 2);
                    for (let i = 0; i < enemyCount; i++) {
                        const randLane = Math.floor(Math.random() * 3);
                        const randDist = -80 - (Math.random() * 20);
                        createEnemy(randLane, randDist);
                    }
                    break;
            }
            
            function createEnemy(lane, zPos) {
                // 적 그룹
                const enemy = new THREE.Group();
                
                // 적 몸체 (더 큰 크기와 강한 네온 빨간색)
                const enemyGeometry = new THREE.SphereGeometry(0.6, 16, 16);
                const enemyMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xff0000,
                    emissive: 0xff0000,
                    emissiveIntensity: 0.8,
                    roughness: 0.3,
                    metalness: 0.7
                });
                const body = new THREE.Mesh(enemyGeometry, enemyMaterial);
                body.castShadow = true;
                body.receiveShadow = true;
                enemy.add(body);
                
                // 적 눈 (흰색)
                const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
                
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(0.2, 0.2, 0.4);
                enemy.add(leftEye);
                
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(-0.2, 0.2, 0.4);
                enemy.add(rightEye);
                
                // 적 눈동자 (검은색)
                const pupilGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                const pupilMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
                
                const leftPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                leftPupil.position.set(0.2, 0.2, 0.45);
                enemy.add(leftPupil);
                
                const rightPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                rightPupil.position.set(-0.2, 0.2, 0.45);
                enemy.add(rightPupil);
                
                enemy.position.set(lanes[lane], 0.5, zPos);
                scene.add(enemy);
                enemies.push(enemy);
            }
        }
        
        // 총알 발사 함수
        function fireBullets() {
            const currentTime = Date.now();
            
            // 자동 발사 간격 (아군 수에 따라 감소)
            const fireInterval = Math.max(100, 500 - (allies.length * 10));
            
            if (currentTime - lastFireTime < fireInterval) return;
            
            lastFireTime = currentTime;
            
            // 아군 수에 비례해서 총알 발사 (아군당 0.5발의 총알)
            const bulletsToFire = Math.max(1, Math.ceil(allies.length * 0.5));
            
            for (let i = 0; i < bulletsToFire; i++) {
                const bulletGeometry = new THREE.SphereGeometry(0.3, 8, 8);
                const bulletMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFFFF00, 
                    emissive: 0xFFFF00,
                    emissiveIntensity: 1.0,
                    metalness: 1.0,
                    roughness: 0.0
                });
                const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
                
                // 총알 발사 방향 다각화
                let angleOffset = 0;
                if (bulletsToFire > 1) {
                    // 부채꼴 형태로 퍼지게 발사
                    const spreadFactor = Math.min(0.3, bulletsToFire * 0.02);  // 최대 0.3 라디안 (약 17도)
                    angleOffset = spreadFactor * ((i / (bulletsToFire - 1)) * 2 - 1);
                }
                
                // 총알 위치는 무작위 아군 위치에서 시작
                const shooterIndex = Math.floor(Math.random() * allies.length);
                bullet.position.copy(allies[shooterIndex].position);
                bullet.position.z -= 1; // 약간 앞에서 발사
                
                // 총알 방향 설정
                bullet.userData.direction = new THREE.Vector3(angleOffset, 0, -1).normalize();
                bullet.userData.speed = 1.5;
                
                scene.add(bullet);
                bullets.push(bullet);
                
                // 총알 발사 이펙트 (강한 빛)
                const bulletLight = new THREE.PointLight(0xffff00, 5, 8);
                bulletLight.position.copy(bullet.position);
                scene.add(bulletLight);
                
                // 추가 발광 효과 (더 넓은 범위)
                const bulletGlow = new THREE.PointLight(0xffff00, 2, 15);
                bulletGlow.position.copy(bullet.position);
                scene.add(bulletGlow);
                
                // 0.1초 후 이펙트 제거
                setTimeout(() => {
                    scene.remove(bulletLight);
                }, 100);
            }
        }
        
        // 사칙연산 패널 생성 함수
        function createMathPanels() {
            // 기존 패널 제거
            panels.forEach(panel => scene.remove(panel));
            panels = [];
            
            // 랜덤 연산자 선택
            const operator = operators[Math.floor(Math.random() * operators.length)];
            
            // 피연산자 선택 (난이도에 따라 증가)
            const operand = Math.floor(Math.random() * Math.min(5, difficulty)) + 1;
            
            // 현재 아군 수와 연산 결과 계산
            const currentAllies = allies.length;
            const result = operator.fn(currentAllies, operand);
            
            // 연산 표시 업데이트
            activeEquation = `${currentAllies} ${operator.symbol} ${operand} = ${result}`;
            document.getElementById('currentEquation').textContent = activeEquation;
            
            // 도로 세 레인에 패널 생성
            for (let i = 0; i < 3; i++) {
                createMathPanel(lanes[i], -60 - Math.random() * 10, operand, operator);
            }
            
            function createMathPanel(x, z, operand, operator) {
                // 패널 그룹
                const panel = new THREE.Group();
                
                // 패널 플랫폼
                const panelGeometry = new THREE.BoxGeometry(3, 0.3, 3);
                
                // 연산자에 맞는 색상 적용 (강한 네온 효과)
                const panelMaterial = new THREE.MeshStandardMaterial({ 
                    color: operator.color,
                    emissive: operator.glow,
                    emissiveIntensity: 0.8,
                    transparent: true,
                    opacity: 0.9
                });
                
                const panelMesh = new THREE.Mesh(panelGeometry, panelMaterial);
                panelMesh.castShadow = true;
                panelMesh.receiveShadow = true;
                panel.add(panelMesh);
                
                // 패널에 숫자 표시를 위한 텍스트 (Three.js에서는 실제 텍스트 렌더링이 어려워 대체 표현)
                const operatorSymbol = operator.symbol;
                const operatorTextGeometry = new THREE.BoxGeometry(1, 0.1, 1);
                const operatorTextMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFFFFFF,
                    emissive: 0xFFFFFF,
                    emissiveIntensity: 0.5
                });
                
                const operatorText = new THREE.Mesh(operatorTextGeometry, operatorTextMaterial);
                operatorText.position.y = 0.2;
                panel.add(operatorText);
                
                // 숫자 표시 (간소화된 형태)
                const numberGeometry = new THREE.BoxGeometry(0.5, 0.1, 0.5);
                const numberMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
                const numberMesh = new THREE.Mesh(numberGeometry, numberMaterial);
                numberMesh.position.set(0, 0.2, 0.5);
                panel.add(numberMesh);
                
                // 패널 위치 설정
                panel.position.set(x, 0, z);
                
                // 패널에 연산 데이터 추가
                panel.userData = {
                    operator: operatorSymbol,
                    operand: operand,
                    result: result
                };
                
                // 패널 발광 효과
                const panelLight = new THREE.PointLight(operator.color, 1, 5);
                panelLight.position.set(0, 0.5, 0);
                panel.add(panelLight);
                
                scene.add(panel);
                panels.push(panel);
            }
        }
        
        // 게임 업데이트 함수
        function updateGame() {
            const currentTime = Date.now();
            
            // 도로 스크롤
            scrollRoad();
            
            // 3초마다 패널 생성
            if (currentTime - lastPanelTime > 3000) {
                createMathPanels();
                lastPanelTime = currentTime;
            }
            
            // 난이도에 따라 적 웨이브 생성 주기 조절
            const enemyWaveInterval = Math.max(2000, 5000 - (difficulty * 300));
            if (currentTime - lastEnemyWaveTime > enemyWaveInterval) {
                createEnemyWave();
                lastEnemyWaveTime = currentTime;
            }
            
            // 자동 총알 발사
            fireBullets();
            
            // 패널 이동 (도로와 함께 이동)
            panels.forEach(panel => {
                panel.position.z += roadSpeed;
                
                // 화면 끝에 도달한 패널은 제거
                if (panel.position.z > 10) {
                    scene.remove(panel);
                    panels.splice(panels.indexOf(panel), 1);
                    
                    // 모든 패널이 사라졌을 때 현재 연산 초기화
                    if (panels.length === 0) {
                        document.getElementById('currentEquation').textContent = "없음";
                    }
                }
            });
            
            // 적 이동 (도로와 함께 이동, 약간 더 빠르게)
            enemies.forEach(enemy => {
                enemy.position.z += roadSpeed * 1.2;
                
                // 화면 끝에 도달한 적은 제거
                if (enemy.position.z > 10) {
                    scene.remove(enemy);
                    enemies.splice(enemies.indexOf(enemy), 1);
                }
                
                // 적 애니메이션 (약간 상하로 움직임)
                enemy.position.y = 0.5 + Math.sin(currentTime / 300 + enemy.position.z) * 0.1;
                
                // 추가: 적 회전 애니메이션
                enemy.rotation.y += 0.02;
            });
            
            // 아군 애니메이션 (약간 위아래로 움직임)
            allies.forEach((ally, index) => {
                // 메인 캐릭터 (0번 인덱스)만 특별한 애니메이션 적용
                if (index === 0) {
                    ally.position.y = 0.5 + Math.sin(currentTime / 500) * 0.05;
                    
                    // 달리기 애니메이션 효과 (앞뒤로 약간 기울임)
                    ally.rotation.x = Math.sin(currentTime / 200) * 0.1;
                } else {
                    // 다른 아군들은 약간 다른 주기로 움직여 자연스러움 증가
                    ally.position.y = 0.5 + Math.sin((currentTime / 500) + index * 0.5) * 0.05;
                }
            });
            
            // 총알 이동
            bullets.forEach(bullet => {
                const direction = bullet.userData.direction;
                bullet.position.x += direction.x * bullet.userData.speed;
                bullet.position.z += direction.z * bullet.userData.speed;
                
                // 총알 회전 효과 추가
                bullet.rotation.x += 0.2;
                bullet.rotation.y += 0.2;
                
                // 화면 밖으로 나간 총알 제거
                if (bullet.position.z < -100) {
                    scene.remove(bullet);
                    bullets.splice(bullets.indexOf(bullet), 1);
                }
            });
            
            // 충돌 체크
            checkCollisions();
            
            // 난이도 증가
            difficulty = 1 + ((60 - gameTime) / 5);
            
            // 도로 속도 증가 (난이도에 따라)
            roadSpeed = 0.5 + (difficulty * 0.05);
        }
        
        // 충돌 체크 함수 - 시각적 효과 추가
        function checkCollisions() {
            // 총알과 적의 충돌
            bullets.forEach(bullet => {
                enemies.forEach(enemy => {
                    const distance = bullet.position.distanceTo(enemy.position);
                    if (distance < 1) {
                        // 충돌 시 폭발 효과
                        createExplosion(enemy.position.clone());
                        
                        // 충돌 발생
                        scene.remove(bullet);
                        scene.remove(enemy);
                        bullets.splice(bullets.indexOf(bullet), 1);
                        enemies.splice(enemies.indexOf(enemy), 1);
                        
                        // 점수 추가
                        score += 10;
                        document.getElementById('score').textContent = score;
                    }
                });
            });
            
            // 플레이어(메인 아군)와 패널의 충돌
            if (allies.length > 0) {
                const player = allies[0];
                
                panels.forEach(panel => {
                    const distance = Math.sqrt(
                        Math.pow(player.position.x - panel.position.x, 2) +
                        Math.pow(player.position.z - panel.position.z, 2)
                    );
                    
                    if (distance < 2) {
                        // 패널과 충돌 - 사칙연산 수행
                        if (panel.userData.result !== undefined) {
                            // 패널 획득 효과
                            createPanelEffect(player.position.clone());
                            
                            createAllies(panel.userData.result);
                            
                            // 보너스 점수
                            score += 50;
                            document.getElementById('score').textContent = score;
                            
                            // 모든 패널 제거
                            panels.forEach(p => scene.remove(p));
                            panels = [];
                            
                            // 연산 초기화
                            document.getElementById('currentEquation').textContent = "없음";
                        }
                    }
                });
                
                // 플레이어와 적의 충돌
                enemies.forEach(enemy => {
                    const distance = player.position.distanceTo(enemy.position);
                    if (distance < 1.2) {
                        // 충돌 시 데미지 효과
                        createDamageEffect(player.position.clone());
                        
                        // 충돌 발생 - 아군 감소
                        if (allies.length > 1) {
                            createAllies(allies.length - 1);
                            
                            // 해당 적 제거
                            scene.remove(enemy);
                            enemies.splice(enemies.indexOf(enemy), 1);
                        } else {
                            // 마지막 아군이 적과 충돌하면 게임 오버
                            endGame();
                        }
                    }
                });
            }
        }
        
        // 폭발 효과 생성 함수
        function createExplosion(position) {
            // 폭발 파티클 그룹
            const explosionGroup = new THREE.Group();
            explosionGroup.position.copy(position);
            
            // 폭발 빛
            const explosionLight = new THREE.PointLight(0xff5500, 3, 8);
            explosionLight.position.set(0, 0, 0);
            explosionGroup.add(explosionLight);
            
            // 파티클 생성
            const particleCount = 10;
            const particles = [];
            
            for (let i = 0; i < particleCount; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const particleMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xff5500, 
                    transparent: true, 
                    opacity: 1
                });
                
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                
                // 랜덤 방향으로 튀어나감
                const angle1 = Math.random() * Math.PI * 2;
                const angle2 = Math.random() * Math.PI * 2;
                
                const speed = 0.1 + Math.random() * 0.2;
                particle.userData.velocity = new THREE.Vector3(
                    Math.sin(angle1) * Math.cos(angle2) * speed,
                    Math.sin(angle1) * Math.sin(angle2) * speed,
                    Math.cos(angle1) * speed
                );
                
                explosionGroup.add(particle);
                particles.push(particle);
            }
            
            scene.add(explosionGroup);
            
            // 0.5초 동안 폭발 애니메이션
            let elapsed = 0;
            const duration = 500; // 밀리초
            const interval = setInterval(() => {
                elapsed += 16;
                
                // 파티클 이동 및 페이드 아웃
                particles.forEach(particle => {
                    particle.position.add(particle.userData.velocity);
                    particle.material.opacity = 1 - (elapsed / duration);
                    particle.scale.multiplyScalar(0.98);
                });
                
                // 빛 감소
                explosionLight.intensity = 3 * (1 - elapsed / duration);
                
                if (elapsed >= duration) {
                    clearInterval(interval);
                    scene.remove(explosionGroup);
                }
            }, 16);
        }
        
        // 패널 획득 효과
        function createPanelEffect(position) {
            // 빛 생성
            const light = new THREE.PointLight(0x00ffff, 3, 10);
            light.position.copy(position);
            scene.add(light);
            
            // 0.5초 동안 빛 효과
            let elapsed = 0;
            const duration = 500; // 밀리초
            const interval = setInterval(() => {
                elapsed += 16;
                
                // 빛 강도 조절
                light.intensity = 3 * (1 - elapsed / duration);
                
                if (elapsed >= duration) {
                    clearInterval(interval);
                    scene.remove(light);
                }
            }, 16);
        }
        
        // 데미지 효과
        function createDamageEffect(position) {
            // 빨간 빛 생성
            const light = new THREE.PointLight(0xff0000, 3, 10);
            light.position.copy(position);
            scene.add(light);
            
            // 화면 빨갛게 깜빡임 (CSS 효과)
            const overlay = document.createElement('div');
            overlay.style.position = 'absolute';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.width = '100%';
            overlay.style.height = '100%';
            overlay.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
            overlay.style.pointerEvents = 'none';
            overlay.style.transition = 'opacity 0.5s';
            document.body.appendChild(overlay);
            
            // 0.5초 동안 효과
            setTimeout(() => {
                overlay.style.opacity = '0';
                setTimeout(() => {
                    document.body.removeChild(overlay);
                }, 500);
            }, 100);
            
            // 빛 효과 제거
            setTimeout(() => {
                scene.remove(light);
            }, 500);
        }
        
        // 게임 타이머 함수
        function startGameTimer() {
            const timerInterval = setInterval(() => {
                if (!gameActive) {
                    clearInterval(timerInterval);
                    return;
                }
                
                gameTime--;
                document.getElementById('timer').textContent = gameTime;
                
                if (gameTime <= 0) {
                    clearInterval(timerInterval);
                    endGame();
                }
            }, 1000);
        }
        
        // 게임 종료 함수
        function endGame() {
            gameActive = false;
            document.getElementById('gameOver').style.display = 'block';
            document.getElementById('finalScore').textContent = score;
            
            // 게임 오버 효과
            const gameOverLight = new THREE.AmbientLight(0xff0000, 0.3);
            scene.add(gameOverLight);
            
            // 모든 아군 회전 애니메이션
            const rotateAllies = () => {
                allies.forEach(ally => {
                    ally.rotation.y += 0.05;
                });
                
                if (gameActive) {
                    return;
                }
                
                requestAnimationFrame(rotateAllies);
            };
            
            rotateAllies();
        }
        
        // 게임 재시작 함수
        function restartGame() {
            // 기존 오브젝트 정리
            allies.forEach(ally => scene.remove(ally));
            enemies.forEach(enemy => scene.remove(enemy));
            bullets.forEach(bullet => scene.remove(bullet));
            panels.forEach(panel => scene.remove(panel));
            
            // 씬의 모든 빛 제거 (게임 오버 효과 제거)
            scene.children.forEach(child => {
                if (child instanceof THREE.Light && !(child instanceof THREE.DirectionalLight) && !(child instanceof THREE.AmbientLight && child.intensity === 0.6)) {
                    scene.remove(child);
                }
            });
            
            allies = [];
            enemies = [];
            bullets = [];
            panels = [];
            
            // 변수 초기화
            gameTime = 60;
            score = 0;
            difficulty = 1;
            gameActive = true;
            lastPanelTime = 0;
            lastEnemyWaveTime = 0;
            playerLane = 1; // 중앙 레인으로 초기화
            isMoving = false;
            roadSpeed = 0.5;
            gameDistance = 0;
            
            // UI 초기화
            document.getElementById('timer').textContent = gameTime;
            document.getElementById('score').textContent = score;
            document.getElementById('currentEquation').textContent = "없음";
            document.getElementById('gameOver').style.display = 'none';
            
            // 기본 조명 재설정
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(0, 20, 10);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // 첫 아군 생성
            createAllies(1);
            
            // 타이머 재시작
            startGameTimer();
        }
        
        // 애니메이션 루프
        function animate() {
            requestAnimationFrame(animate);
            
            if (gameActive) {
                updateGame();
            }
            
            renderer.render(scene, camera);
        }
        
        // 화면 크기 조정 이벤트
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // 게임 시작
        init();
    </script>
</body>
</html>
</antArtifact><antArtifact identifier="enhanced-game" type="application/vnd.ant.code" language="html" title="Enhanced Math Runner 3D Game">
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>러너 3D 슈팅 게임</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: Arial, sans-serif; 
            touch-action: none;
        }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            padding: 5px;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 1px 1px 1px black;
            z-index: 10;
        }
        #equationInfo {
            position: absolute;
            top: 40px;
            width: 100%;
            text-align: center;
            color: #ffcc00;
            padding: 5px;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 1px 1px 1px black;
            z-index: 10;
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none;
            z-index: 20;
        }
        #restartBtn {
            padding: 15px 30px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 18px;
            margin-top: 20px;
        }
        #restartBtn:hover {
            background-color: #45a049;
        }
        #controls {
            position: absolute;
            bottom: 30px;
            width: 100%;
            display: flex;
            justify-content: center;
            z-index: 10;
        }
        .controlBtn {
            width: 80px;
            height: 80px;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 40px;
            margin: 0 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
            user-select: none;
        }
    </style>
</head>
<body>
    <div id="info">아군: <span id="allyCount">1</span> | 시간: <span id="timer">60</span>초 | 점수: <span id="score">0</span></div>
    <div id="equationInfo">현재 패널: <span id="currentEquation">없음</span></div>
    <div id="gameOver">
        <h2>게임 종료!</h2>
        <p>최종 점수: <span id="finalScore">0</span></p>
        <button id="restartBtn">다시 시작</button>
    </div>
    <div id="controls">
        <div id="leftBtn" class="controlBtn">←</div>
        <div id="rightBtn" class="controlBtn">→</div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // 게임 변수
        let scene, camera, renderer, allies = [], enemies = [], bullets = [], panels = [];
        let gameTime = 60; // 1분
        let score = 0;
        let difficulty = 1;
        let gameActive = true;
        let lastPanelTime = 0;
        let lastEnemyWaveTime = 0;
        let lastFireTime = 0;
        let playerLane = 1; // 0: 왼쪽, 1: 중앙, 2: 오른쪽
        let isMoving = false;
        let roadSpeed = 0.5;
        let roadSegments = [];
        let gameDistance = 0;
        let activeEquation = "";
        
        // 레인 위치 정의
        const lanes = [-5, 0, 5];
        
        // 수학 연산자 (각각 강한 네온 색상으로 변경)
        const operators = [
            { symbol: "+", fn: (a, b) => a + b, color: 0x00FFFF, glow: 0x00FFFF }, // 네온 청록색
            { symbol: "-", fn: (a, b) => Math.max(1, a - b), color: 0xFF1493, glow: 0xFF1493 }, // 네온 핑크
            { symbol: "×", fn: (a, b) => a * b, color: 0x39FF14, glow: 0x39FF14 }, // 네온 그린
            { symbol: "÷", fn: (a, b) => Math.round(a / b) || 1, color: 0xFFD700, glow: 0xFFD700 } // 네온 골드
        ];
        
        // 게임 초기화
        function init() {
            // 씬 설정
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e); // 어두운 남색 배경
            
            // 안개 추가 (원근감) - 더 짙게 설정
            scene.fog = new THREE.Fog(0x1a1a2e, 30, 80);
            
            // 카메라 설정
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 8, 12); // 카메라 높이와 거리 조정
            camera.lookAt(0, 0, -20);
            
            // 렌더러 설정
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; // 그림자 활성화
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);
            
            // 조명 설정
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(0, 20, 10);
            directionalLight.castShadow = true; // 그림자 생성
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -20;
            directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20;
            directionalLight.shadow.camera.bottom = -20;
            scene.add(directionalLight);
            
            // 도로 생성
            createRoad();
            
            // 첫 아군 생성
            createAllies(1);
            
            // 이벤트 리스너
            window.addEventListener('resize', onWindowResize);
            document.getElementById('restartBtn').addEventListener('click', restartGame);
            
            // 모바일 컨트롤 초기화
            initControls();
            
            // 게임 타이머 시작
            startGameTimer();
            
            // 게임 루프 시작
            animate();
        }
        
        // 도로 생성 함수
        function createRoad() {
            // 도로 텍스처 (하늘색 그라데이션 패턴으로 변경)
            const roadWidth = 15;
            const roadLength = 1000;
            const segmentLength = 20;
            const segments = roadLength / segmentLength;
            
            // 도로 기본 재질 (네온 효과가 있는 어두운 색상)
            const roadMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x0f3460,
                roughness: 0.5,
                metalness: 0.7,
                emissive: 0x0f3460,
                emissiveIntensity: 0.2
            });
            
            // 도로 경계선 재질 (밝은 네온 색상)
            const lineMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xE94560, 
                emissive: 0xE94560,
                emissiveIntensity: 0.7
            });
            
            // 도로 가장자리 재질 (네온 푸른색)
            const sideMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x16213E,
                emissive: 0x0F52BA,
                emissiveIntensity: 0.3
            });
            
            // 도로 그라데이션을 위한 재질 배열 (네온 효과가 있는 패턴)
            const patternMaterials = [
                new THREE.MeshStandardMaterial({ 
                    color: 0x0f3460, 
                    emissive: 0x0f3460,
                    emissiveIntensity: 0.2
                }),
                new THREE.MeshStandardMaterial({ 
                    color: 0x16213E, 
                    emissive: 0x16213E,
                    emissiveIntensity: 0.2
                })
            ];
            
            // 여러 세그먼트로 도로 생성
            for (let i = 0; i < segments; i++) {
                // 도로 세그먼트 (패턴 적용)
                const roadGeometry = new THREE.PlaneGeometry(roadWidth, segmentLength);
                const road = new THREE.Mesh(roadGeometry, patternMaterials[i % 2]); // 번갈아가며 패턴 적용
                road.rotation.x = -Math.PI / 2;
                road.position.z = -i * segmentLength - segmentLength / 2;
                road.position.y = -0.1;
                road.receiveShadow = true; // 그림자 받기
                scene.add(road);
                roadSegments.push(road);
                
                // 도로 레인 구분선
                for (let j = -1; j <= 1; j += 2) {
                    const lineGeometry = new THREE.PlaneGeometry(0.3, segmentLength);
                    const line = new THREE.Mesh(lineGeometry, lineMaterial);
                    line.rotation.x = -Math.PI / 2;
                    line.position.set(j * roadWidth/6, -0.05, -i * segmentLength - segmentLength / 2);
                    line.receiveShadow = true;
                    scene.add(line);
                    roadSegments.push(line);
                }
                
                // 도로 가장자리
                for (let j = -1; j <= 1; j += 2) {
                    const sideGeometry = new THREE.BoxGeometry(2, 1, segmentLength);
                    const side = new THREE.Mesh(sideGeometry, sideMaterial);
                    side.position.set(j * (roadWidth/2 + 1), 0.4, -i * segmentLength - segmentLength / 2);
                    side.castShadow = true;
                    side.receiveShadow = true;
                    scene.add(side);
                    roadSegments.push(side);
                    
                    // 가드레일 기둥 추가
                    if (i % 2 === 0) {
                        const postGeometry = new THREE.BoxGeometry(0.5, 2, 0.5);
                        const postMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
                        const post = new THREE.Mesh(postGeometry, postMaterial);
                        post.position.set(j * (roadWidth/2 + 1), 1.5, -i * segmentLength - segmentLength / 2);
                        post.castShadow = true;
                        post.receiveShadow = true;
                        scene.add(post);
                        roadSegments.push(post);
                    }
                }
            }
        }
        
        // 도로 스크롤 함수
        function scrollRoad() {
            const resetPos = -1000; // 도로 총 길이
            
            roadSegments.forEach(segment => {
                segment.position.z += roadSpeed;
                
                // 도로 세그먼트가 카메라 뒤로 지나가면 다시 앞으로 재배치
                if (segment.position.z > 20) {
                    segment.position.z = resetPos + (segment.position.z - 20);
                }
            });
            
            // 거리 증가
            gameDistance += roadSpeed;
        }
        
        // 컨트롤 초기화
        function initControls() {
            const leftBtn = document.getElementById('leftBtn');
            const rightBtn = document.getElementById('rightBtn');
            
            // 터치 이벤트
            leftBtn.addEventListener('touchstart', moveLeft);
            rightBtn.addEventListener('touchstart', moveRight);
            
            // 마우스 이벤트 (데스크톱용)
            leftBtn.addEventListener('mousedown', moveLeft);
            rightBtn.addEventListener('mousedown', moveRight);
            
            // 키보드 이벤트
            window.addEventListener('keydown', function(e) {
                if (!gameActive || isMoving) return;
                
                if (e.key === 'ArrowLeft') {
                    moveLeft();
                } else if (e.key === 'ArrowRight') {
                    moveRight();
                }
            });
            
            function moveLeft() {
                if (!gameActive || isMoving || playerLane === 0) return;
                
                isMoving = true;
                playerLane--;
                moveAlliesTo(lanes[playerLane]);
            }
            
            function moveRight() {
                if (!gameActive || isMoving || playerLane === 2) return;
                
                isMoving = true;
                playerLane++;
                moveAlliesTo(lanes[playerLane]);
            }
        }
        
        // 아군 이동 함수
        function moveAlliesTo(targetX) {
            // 0.3초에 걸쳐 부드럽게 이동
            const frames = 15; // 60fps 기준 0.25초
            let currentFrame = 0;
            
            // 메인 아군 현재 위치
            const startX = allies[0].position.x;
            const moveAmount = (targetX - startX) / frames;
            
            const moveInterval = setInterval(() => {
                if (currentFrame >= frames) {
                    clearInterval(moveInterval);
                    isMoving = false;
                    return;
                }
                
                // 모든 아군 이동
                allies.forEach((ally, index) => {
                    if (index === 0) {
                        // 메인 아군
                        ally.position.x += moveAmount;
                    } else {
                        // 나머지 아군들은 메인 아군을 따라감
                        updateAllyFormation();
                    }
                });
                
                currentFrame++;
            }, 1000/60); // 60fps
        }
        
        // 아군 진형 업데이트
        function updateAllyFormation() {
            if (allies.length <= 1) return;
            
            const mainAlly = allies[0];
            const allyCount = allies.length;
            
            // 진영 크기 계산 - 아군이 많을수록 더 넓게 퍼짐
            const formationWidth = Math.min(3, 0.5 + (allyCount * 0.1));
            const formationDepth = Math.min(4, 1 + (allyCount * 0.15));
            
            for (let i = 1; i < allyCount; i++) {
                // 균등하게 분포된 위치 계산
                let row = Math.floor((i-1) / 3);
                let col = (i-1) % 3;
                
                // 중앙 정렬을 위한 오프셋
                let colOffset = col - 1; // -1, 0, 1
                let rowOffset = -row; // 항상 플레이어 뒤에 배치
                
                allies[i].position.x = mainAlly.position.x + (colOffset * formationWidth);
                allies[i].position.z = mainAlly.position.z + (rowOffset * formationDepth);
            }
        }
        
        // 아군 생성 함수 - 캐릭터 디자인 개선
        function createAllies(count) {
            // 기존 아군 제거
            allies.forEach(ally => scene.remove(ally));
            allies = [];
            
            // 최댓값 제한 (너무 많으면 게임이 쉬워짐)
            count = Math.min(count, 30);
            
            // 새 아군 생성 - 귀여운 오렌지색 캐릭터로 변경
            for (let i = 0; i < count; i++) {
                // 캐릭터 그룹
                const character = new THREE.Group();
                
                // 몸체 (구)
                const bodyGeometry = new THREE.SphereGeometry(0.5, 16, 16);
                const bodyMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFF9900, // 오렌지색
                    emissive: 0xAA5500,
                    emissiveIntensity: 0.2,
                    roughness: 0.7
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.castShadow = true;
                body.receiveShadow = true;
                character.add(body);
                
                // 캐릭터에 눈 추가
                const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
                
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(0.2, 0.2, 0.4);
                character.add(leftEye);
                
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(-0.2, 0.2, 0.4);
                character.add(rightEye);
                
                // 눈동자
                const pupilGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                const pupilMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
                
                const leftPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                leftPupil.position.set(0.2, 0.2, 0.45);
                character.add(leftPupil);
                
                const rightPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                rightPupil.position.set(-0.2, 0.2, 0.45);
                character.add(rightPupil);
                
                // 팔과 다리 추가 (메인 캐릭터만)
                if (i === 0) {
                    // 팔
                    const armGeometry = new THREE.SphereGeometry(0.15, 8, 8);
                    
                    const leftArm = new THREE.Mesh(armGeometry, bodyMaterial);
                    leftArm.position.set(0.6, 0, 0);
                    leftArm.castShadow = true;
                    character.add(leftArm);
                    
                    const rightArm = new THREE.Mesh(armGeometry, bodyMaterial);
                    rightArm.position.set(-0.6, 0, 0);
                    rightArm.castShadow = true;
                    character.add(rightArm);
                    
                    // 다리
                    const legGeometry = new THREE.CylinderGeometry(0.15, 0.1, 0.5, 8);
                    
                    const leftLeg = new THREE.Mesh(legGeometry, bodyMaterial);
                    leftLeg.position.set(0.2, -0.5, 0);
                    leftLeg.castShadow = true;
                    character.add(leftLeg);
                    
                    const rightLeg = new THREE.Mesh(legGeometry, bodyMaterial);
                    rightLeg.position.set(-0.2, -0.5, 0);
                    rightLeg.castShadow = true;
                    character.add(rightLeg);
                }
                
                if (i === 0) {
                    // 메인 아군 (플레이어)
                    character.position.set(lanes[playerLane], 0.5, 0);
                } else {
                    // 추가 아군들은 초기 위치만 설정 (updateAllyFormation에서 정확히 배치됨)
                    character.position.set(lanes[playerLane], 0.5, -i);
                    // 작게 만들기
                    character.scale.set(0.8, 0.8, 0.8);
                }
                
                scene.add(character);
                allies.push(character);
            }
            
            // 진형 업데이트
            updateAllyFormation();
            
            // UI 업데이트
            document.getElementById('allyCount').textContent = allies.length;
        }
        
        // 적 생성 함수 - 웨이브 형태로 생성
        function createEnemyWave() {
            const waveType = Math.floor(Math.random() * 4);
            
            switch (waveType) {
                case 0: // 일렬 웨이브
                    const randomLane = Math.floor(Math.random() * 3);
                    for (let i = 0; i < 5 + Math.floor(difficulty); i++) {
                        createEnemy(randomLane, -80 - (i * 4));
                    }
                    break;
                    
                case 1: // V 형태 웨이브
                    for (let i = 0; i < 7; i++) {
                        const laneOffset = (i <= 3) ? i : 6 - i; // 0,1,2,3,2,1,0
                        createEnemy(laneOffset, -80 - (i * 3));
                    }
                    break;
                    
                case 2: // 모든 레인 웨이브
                    for (let i = 0; i < 3; i++) {
                        for (let j = 0; j < 3; j++) {
                            createEnemy(j, -80 - (i * 5));
                        }
                    }
                    break;
                    
                case 3: // 랜덤 웨이브
                    const enemyCount = 5 + Math.floor(difficulty * 2);
                    for (let i = 0; i < enemyCount; i++) {
                        const randLane = Math.floor(Math.random() * 3);
                        const randDist = -80 - (Math.random() * 20);
                        createEnemy(randLane, randDist);
                    }
                    break;
            }
            
            function createEnemy(lane, zPos) {
                // 적 그룹
                const enemy = new THREE.Group();
                
                // 적 몸체 (더 큰 크기와 강한 네온 빨간색)
                const enemyGeometry = new THREE.SphereGeometry(0.6, 16, 16);
                const enemyMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xff0000,
                    emissive: 0xff0000,
                    emissiveIntensity: 0.8,
                    roughness: 0.3,
                    metalness: 0.7
                });
                const body = new THREE.Mesh(enemyGeometry, enemyMaterial);
                body.castShadow = true;
                body.receiveShadow = true;
                enemy.add(body);
                
                // 적 눈 (흰색)
                const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
                
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(0.2, 0.2, 0.4);
                enemy.add(leftEye);
                
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(-0.2, 0.2, 0.4);
                enemy.add(rightEye);
                
                // 적 눈동자 (검은색)
                const pupilGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                const pupilMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
                
                const leftPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                leftPupil.position.set(0.2, 0.2, 0.45);
                enemy.add(leftPupil);
                
                const rightPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                rightPupil.position.set(-0.2, 0.2, 0.45);
                enemy.add(rightPupil);
                
                enemy.position.set(lanes[lane], 0.5, zPos);
                scene.add(enemy);
                enemies.push(enemy);
            }
        }
        
        // 총알 발사 함수
        function fireBullets() {
            const currentTime = Date.now();
            
            // 자동 발사 간격 (아군 수에 따라 감소)
            const fireInterval = Math.max(100, 500 - (allies.length * 10));
            
            if (currentTime - lastFireTime < fireInterval) return;
            
            lastFireTime = currentTime;
            
            // 아군 수에 비례해서 총알 발사 (아군당 0.5발의 총알)
            const bulletsToFire = Math.max(1, Math.ceil(allies.length * 0.5));
            
            for (let i = 0; i < bulletsToFire; i++) {
                const bulletGeometry = new THREE.SphereGeometry(0.3, 8, 8);
                const bulletMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFFFF00, 
                    emissive: 0xFFFF00,
                    emissiveIntensity: 1.0,
                    metalness: 1.0,
                    roughness: 0.0
                });
                const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
                
                // 총알 발사 방향 다각화
                let angleOffset = 0;
                if (bulletsToFire > 1) {
                    // 부채꼴 형태로 퍼지게 발사
                    const spreadFactor = Math.min(0.3, bulletsToFire * 0.02);  // 최대 0.3 라디안 (약 17도)
                    angleOffset = spreadFactor * ((i / (bulletsToFire - 1)) * 2 - 1);
                }
                
                // 총알 위치는 무작위 아군 위치에서 시작
                const shooterIndex = Math.floor(Math.random() * allies.length);
                bullet.position.copy(allies[shooterIndex].position);
                bullet.position.z -= 1; // 약간 앞에서 발사
                
                // 총알 방향 설정
                bullet.userData.direction = new THREE.Vector3(angleOffset, 0, -1).normalize();
                bullet.userData.speed = 1.5;
                
                scene.add(bullet);
                bullets.push(bullet);
                
                // 총알 발사 이펙트 (강한 빛)
                const bulletLight = new THREE.PointLight(0xffff00, 5, 8);
                bulletLight.position.copy(bullet.position);
                scene.add(bulletLight);
                
                // 추가 발광 효과 (더 넓은 범위)
                const bulletGlow = new THREE.PointLight(0xffff00, 2, 15);
                bulletGlow.position.copy(bullet.position);
                scene.add(bulletGlow);
                
                // 0.1초 후 이펙트 제거
                setTimeout(() => {
                    scene.remove(bulletLight);
                }, 100);
            }
        }
        
        // 사칙연산 패널 생성 함수
        function createMathPanels() {
            // 기존 패널 제거
            panels.forEach(panel => scene.remove(panel));
            panels = [];
            
            // 랜덤 연산자 선택
            const operator = operators[Math.floor(Math.random() * operators.length)];
            
            // 피연산자 선택 (난이도에 따라 증가)
            const operand = Math.floor(Math.random() * Math.min(5, difficulty)) + 1;
            
            // 현재 아군 수와 연산 결과 계산
            const currentAllies = allies.length;
            const result = operator.fn(currentAllies, operand);
            
            // 연산 표시 업데이트
            activeEquation = `${currentAllies} ${operator.symbol} ${operand} = ${result}`;
            document.getElementById('currentEquation').textContent = activeEquation;
            
            // 도로 세 레인에 패널 생성
            for (let i = 0; i < 3; i++) {
                createMathPanel(lanes[i], -60 - Math.random() * 10, operand, operator);
            }
            
            function createMathPanel(x, z, operand, operator) {
                // 패널 그룹
                const panel = new THREE.Group();
                
                // 패널 플랫폼
                const panelGeometry = new THREE.BoxGeometry(3, 0.3, 3);
                
                // 연산자에 맞는 색상 적용 (강한 네온 효과)
                const panelMaterial = new THREE.MeshStandardMaterial({ 
                    color: operator.color,
                    emissive: operator.glow,
                    emissiveIntensity: 0.8,
                    transparent: true,
                    opacity: 0.9
                });
                
                const panelMesh = new THREE.Mesh(panelGeometry, panelMaterial);
                panelMesh.castShadow = true;
                panelMesh.receiveShadow = true;
                panel.add(panelMesh);
                
                // 패널에 숫자 표시를 위한 텍스트 (Three.js에서는 실제 텍스트 렌더링이 어려워 대체 표현)
                const operatorSymbol = operator.symbol;
                const operatorTextGeometry = new THREE.BoxGeometry(1, 0.1, 1);
                const operatorTextMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFFFFFF,
                    emissive: 0xFFFFFF,
                    emissiveIntensity: 0.5
                });
                
                const operatorText = new THREE.Mesh(operatorTextGeometry, operatorTextMaterial);
                operatorText.position.y = 0.2;
                panel.add(operatorText);
                
                // 숫자 표시 (간소화된 형태)
                const numberGeometry = new THREE.BoxGeometry(0.5, 0.1, 0.5);
                const numberMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
                const numberMesh = new THREE.Mesh(numberGeometry, numberMaterial);
                numberMesh.position.set(0, 0.2, 0.5);
                panel.add(numberMesh);
                
                // 패널 위치 설정
                panel.position.set(x, 0, z);
                
                // 패널에 연산 데이터 추가
                panel.userData = {
                    operator: operatorSymbol,
                    operand: operand,
                    result: result
                };
                
                // 패널 강한 발광 효과
                const panelLight = new THREE.PointLight(operator.color, 2, 8);
                panelLight.position.set(0, 0.5, 0);
                panel.add(panelLight);
                
                // 추가 외곽 발광 효과
                const outerGlow = new THREE.PointLight(operator.color, 1, 15);
                outerGlow.position.set(0, 1, 0);
                panel.add(outerGlow);
                
                // 패널 주변 네온 효과를 위한 추가 메시
                const glowGeometry = new THREE.BoxGeometry(3.2, 0.1, 3.2);
                const glowMaterial = new THREE.MeshBasicMaterial({ 
                    color: operator.color,
                    transparent: true,
                    opacity: 0.5
                });
                const glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
                glowMesh.position.y = -0.2;
                panel.add(glowMesh);
                
                scene.add(panel);
                panels.push(panel);
            }
        }
        
        // 게임 업데이트 함수
        function updateGame() {
            const currentTime = Date.now();
            
            // 도로 스크롤
            scrollRoad();
            
            // 3초마다 패널 생성
            if (currentTime - lastPanelTime > 3000) {
                createMathPanels();
                lastPanelTime = currentTime;
            }
            
            // 난이도에 따라 적 웨이브 생성 주기 조절
            const enemyWaveInterval = Math.max(2000, 5000 - (difficulty * 300));
            if (currentTime - lastEnemyWaveTime > enemyWaveInterval) {
                createEnemyWave();
                lastEnemyWaveTime = currentTime;
            }
            
            // 자동 총알 발사
            fireBullets();
            
            // 패널 이동 (도로와 함께 이동)
            panels.forEach(panel => {
                panel.position.z += roadSpeed;
                
                // 화면 끝에 도달한 패널은 제거
                if (panel.position.z > 10) {
                    scene.remove(panel);
                    panels.splice(panels.indexOf(panel), 1);
                    
                    // 모든 패널이 사라졌을 때 현재 연산 초기화
                    if (panels.length === 0) {
                        document.getElementById('currentEquation').textContent = "없음";
                    }
                }
            });
            
            // 적 이동 (도로와 함께 이동, 약간 더 빠르게)
            enemies.forEach(enemy => {
                enemy.position.z += roadSpeed * 1.2;
                
                // 화면 끝에 도달한 적은 제거
                if (enemy.position.z > 10) {
                    scene.remove(enemy);
                    enemies.splice(enemies.indexOf(enemy), 1);
                }
                
                // 적 애니메이션 (약간 상하로 움직임)
                enemy.position.y = 0.5 + Math.sin(currentTime / 300 + enemy.position.z) * 0.1;
                
                // 추가: 적 회전 애니메이션
                enemy.rotation.y += 0.02;
            });
            
            // 아군 애니메이션 (약간 위아래로 움직임)
            allies.forEach((ally, index) => {
                // 메인 캐릭터 (0번 인덱스)만 특별한 애니메이션 적용
                if (index === 0) {
                    ally.position.y = 0.5 + Math.sin(currentTime / 500) * 0.05;
                    
                    // 달리기 애니메이션 효과 (앞뒤로 약간 기울임)
                    ally.rotation.x = Math.sin(currentTime / 200) * 0.1;
                } else {
                    // 다른 아군들은 약간 다른 주기로 움직여 자연스러움 증가
                    ally.position.y = 0.5 + Math.sin((currentTime / 500) + index * 0.5) * 0.05;
                }
            });
            
            // 총알 이동
            bullets.forEach(bullet => {
                const direction = bullet.userData.direction;
                bullet.position.x += direction.x * bullet.userData.speed;
                bullet.position.z += direction.z * bullet.userData.speed;
                
                // 총알 회전 효과 추가
                bullet.rotation.x += 0.2;
                bullet.rotation.y += 0.2;
                
                // 화면 밖으로 나간 총알 제거
                if (bullet.position.z < -100) {
                    scene.remove(bullet);
                    bullets.splice(bullets.indexOf(bullet), 1);
                }
            });
            
            // 충돌 체크
            checkCollisions();
            
            // 난이도 증가
            difficulty = 1 + ((60 - gameTime) / 5);
            
            // 도로 속도 증가 (난이도에 따라)
            roadSpeed = 0.5 + (difficulty * 0.05);
        }
        
        // 충돌 체크 함수 - 시각적 효과 추가
        function checkCollisions() {
            // 총알과 적의 충돌
            bullets.forEach(bullet => {
                enemies.forEach(enemy => {
                    const distance = bullet.position.distanceTo(enemy.position);
                    if (distance < 1) {
                        // 충돌 시 폭발 효과
                        createExplosion(enemy.position.clone());
                        
                        // 충돌 발생
                        scene.remove(bullet);
                        scene.remove(enemy);
                        bullets.splice(bullets.indexOf(bullet), 1);
                        enemies.splice(enemies.indexOf(enemy), 1);
                        
                        // 점수 추가
                        score += 10;
                        document.getElementById('score').textContent = score;
                    }
                });
            });
            
            // 플레이어(메인 아군)와 패널의 충돌
            if (allies.length > 0) {
                const player = allies[0];
                
                panels.forEach(panel => {
                    const distance = Math.sqrt(
                        Math.pow(player.position.x - panel.position.x, 2) +
                        Math.pow(player.position.z - panel.position.z, 2)
                    );
                    
                    if (distance < 2) {
                        // 패널과 충돌 - 사칙연산 수행
                        if (panel.userData.result !== undefined) {
                            // 패널 획득 효과
                            createPanelEffect(player.position.clone());
                            
                            createAllies(panel.userData.result);
                            
                            // 보너스 점수
                            score += 50;
                            document.getElementById('score').textContent = score;
                            
                            // 모든 패널 제거
                            panels.forEach(p => scene.remove(p));
                            panels = [];
                            
                            // 연산 초기화
                            document.getElementById('currentEquation').textContent = "없음";
                        }
                    }
                });
                
                // 플레이어와 적의 충돌
                enemies.forEach(enemy => {
                    const distance = player.position.distanceTo(enemy.position);
                    if (distance < 1.2) {
                        // 충돌 시 데미지 효과
                        createDamageEffect(player.position.clone());
                        
                        // 충돌 발생 - 아군 감소
                        if (allies.length > 1) {
                            createAllies(allies.length - 1);
                            
                            // 해당 적 제거
                            scene.remove(enemy);
                            enemies.splice(enemies.indexOf(enemy), 1);
                        } else {
                            // 마지막 아군이 적과 충돌하면 게임 오버
                            endGame();
                        }
                    }
                });
            }
        }
        
        // 폭발 효과 생성 함수
        function createExplosion(position) {
            // 폭발 파티클 그룹
            const explosionGroup = new THREE.Group();
            explosionGroup.position.copy(position);
            
            // 폭발 빛
            const explosionLight = new THREE.PointLight(0xff5500, 3, 8);
            explosionLight.position.set(0, 0, 0);
            explosionGroup.add(explosionLight);
            
            // 파티클 생성
            const particleCount = 10;
            const particles = [];
            
            for (let i = 0; i < particleCount; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const particleMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xff5500, 
                    transparent: true, 
                    opacity: 1
                });
                
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                
                // 랜덤 방향으로 튀어나감
                const angle1 = Math.random() * Math.PI * 2;
                const angle2 = Math.random() * Math.PI * 2;
                
                const speed = 0.1 + Math.random() * 0.2;
                particle.userData.velocity = new THREE.Vector3(
                    Math.sin(angle1) * Math.cos(angle2) * speed,
                    Math.sin(angle1) * Math.sin(angle2) * speed,
                    Math.cos(angle1) * speed
                );
                
                explosionGroup.add(particle);
                particles.push(particle);
            }
            
            scene.add(explosionGroup);
            
            // 0.5초 동안 폭발 애니메이션
            let elapsed = 0;
            const duration = 500; // 밀리초
            const interval = setInterval(() => {
                elapsed += 16;
                
                // 파티클 이동 및 페이드 아웃
                particles.forEach(particle => {
                    particle.position.add(particle.userData.velocity);
                    particle.material.opacity = 1 - (elapsed / duration);
                    particle.scale.multiplyScalar(0.98);
                });
                
                // 빛 감소
                explosionLight.intensity = 3 * (1 - elapsed / duration);
                
                if (elapsed >= duration) {
                    clearInterval(interval);
                    scene.remove(explosionGroup);
                }
            }, 16);
        }
        
        // 패널 획득 효과
        function createPanelEffect(position) {
            // 빛 생성
            const light = new THREE.PointLight(0x00ffff, 3, 10);
            light.position.copy(position);
            scene.add(light);
            
            // 0.5초 동안 빛 효과
            let elapsed = 0;
            const duration = 500; // 밀리초
            const interval = setInterval(() => {
                elapsed += 16;
                
                // 빛 강도 조절
                light.intensity = 3 * (1 - elapsed / duration);
                
                if (elapsed >= duration) {
                    clearInterval(interval);
                    scene.remove(light);
                }
            }, 16);
        }
        
        // 데미지 효과
        function createDamageEffect(position) {
            // 빨간 빛 생성
            const light = new THREE.PointLight(0xff0000, 3, 10);
            light.position.copy(position);
            scene.add(light);
            
            // 화면 빨갛게 깜빡임 (CSS 효과)
            const overlay = document.createElement('div');
            overlay.style.position = 'absolute';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.width = '100%';
            overlay.style.height = '100%';
            overlay.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
            overlay.style.pointerEvents = 'none';
            overlay.style.transition = 'opacity 0.5s';
            document.body.appendChild(overlay);
            
            // 0.5초 동안 효과
            setTimeout(() => {
                overlay.style.opacity = '0';
                setTimeout(() => {
                    document.body.removeChild(overlay);
                }, 500);
            }, 100);
            
            // 빛 효과 제거
            setTimeout(() => {
                scene.remove(light);
            }, 500);
        }
        
        // 게임 타이머 함수
        function startGameTimer() {
            const timerInterval = setInterval(() => {
                if (!gameActive) {
                    clearInterval(timerInterval);
                    return;
                }
                
                gameTime--;
                document.getElementById('timer').textContent = gameTime;
                
                if (gameTime <= 0) {
                    clearInterval(timerInterval);
                    endGame();
                }
            }, 1000);
        }
        
        // 게임 종료 함수
        function endGame() {
            gameActive = false;
            document.getElementById('gameOver').style.display = 'block';
            document.getElementById('finalScore').textContent = score;
            
            // 게임 오버 효과
            const gameOverLight = new THREE.AmbientLight(0xff0000, 0.3);
            scene.add(gameOverLight);
            
            // 모든 아군 회전 애니메이션
            const rotateAllies = () => {
                allies.forEach(ally => {
                    ally.rotation.y += 0.05;
                });
                
                if (gameActive) {
                    return;
                }
                
                requestAnimationFrame(rotateAllies);
            };
            
            rotateAllies();
        }
        
        // 게임 재시작 함수
        function restartGame() {
            // 기존 오브젝트 정리
            allies.forEach(ally => scene.remove(ally));
            enemies.forEach(enemy => scene.remove(enemy));
            bullets.forEach(bullet => scene.remove(bullet));
            panels.forEach(panel => scene.remove(panel));
            
            // 씬의 모든 빛 제거 (게임 오버 효과 제거)
            scene.children.forEach(child => {
                if (child instanceof THREE.Light && !(child instanceof THREE.DirectionalLight) && !(child instanceof THREE.AmbientLight && child.intensity === 0.6)) {
                    scene.remove(child);
                }
            });
            
            allies = [];
            enemies = [];
            bullets = [];
            panels = [];
            
            // 변수 초기화
            gameTime = 60;
            score = 0;
            difficulty = 1;
            gameActive = true;
            lastPanelTime = 0;
            lastEnemyWaveTime = 0;
            playerLane = 1; // 중앙 레인으로 초기화
            isMoving = false;
            roadSpeed = 0.5;
            gameDistance = 0;
            
            // UI 초기화
            document.getElementById('timer').textContent = gameTime;
            document.getElementById('score').textContent = score;
            document.getElementById('currentEquation').textContent = "없음";
            document.getElementById('gameOver').style.display = 'none';
            
            // 기본 조명 재설정
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(0, 20, 10);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // 첫 아군 생성
            createAllies(1);
            
            // 타이머 재시작
            startGameTimer();
        }
        
        // 애니메이션 루프
        function animate() {
            requestAnimationFrame(animate);
            
            if (gameActive) {
                updateGame();
            }
            
            renderer.render(scene, camera);
        }
        
        // 화면 크기 조정 이벤트
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // 게임 시작
        init();
    </script>
</body>
</html>
</antArtifact><antArtifact identifier="enhanced-game" type="application/vnd.ant.code" language="html" title="Enhanced Math Runner 3D Game">
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>러너 3D 슈팅 게임</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: Arial, sans-serif; 
            touch-action: none;
            background-color: #000;
        }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: #00ffff; /* 네온 청록색 */
            padding: 5px;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff, 0 0 30px #00ffff;
            z-index: 10;
            letter-spacing: 1px;
        }
        #equationInfo {
            position: absolute;
            top: 50px;
            width: 100%;
            text-align: center;
            color: #ff00ff; /* 네온 핑크 */
            padding: 5px;
            font-size: 22px;
            font-weight: bold;
            text-shadow: 0 0 10px #ff00ff, 0 0 20px #ff00ff;
            z-index: 10;
            letter-spacing: 1px;
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none;
            z-index: 20;
        }
        #restartBtn {
            padding: 15px 30px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 18px;
            margin-top: 20px;
        }
        #restartBtn:hover {
            background-color: #45a049;
        }
        #controls {
            position: absolute;
            bottom: 30px;
            width: 100%;
            display: flex;
            justify-content: center;
            z-index: 10;
        }
        .controlBtn {
            width: 80px;
            height: 80px;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 40px;
            margin: 0 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
            user-select: none;
        }
    </style>
</head>
<body>
    <div id="info">아군: <span id="allyCount">1</span> | 시간: <span id="timer">60</span>초 | 점수: <span id="score">0</span></div>
    <div id="equationInfo">현재 패널: <span id="currentEquation">없음</span></div>
    <div id="gameOver">
        <h2>게임 종료!</h2>
        <p>최종 점수: <span id="finalScore">0</span></p>
        <button id="restartBtn">다시 시작</button>
    </div>
    <div id="controls">
        <div id="leftBtn" class="controlBtn">←</div>
        <div id="rightBtn" class="controlBtn">→</div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // 게임 변수
        let scene, camera, renderer, allies = [], enemies = [], bullets = [], panels = [];
        let gameTime = 60; // 1분
        let score = 0;
        let difficulty = 1;
        let gameActive = true;
        let lastPanelTime = 0;
        let lastEnemyWaveTime = 0;
        let lastFireTime = 0;
        let playerLane = 1; // 0: 왼쪽, 1: 중앙, 2: 오른쪽
        let isMoving = false;
        let roadSpeed = 0.5;
        let roadSegments = [];
        let gameDistance = 0;
        let activeEquation = "";
        
        // 레인 위치 정의
        const lanes = [-5, 0, 5];
        
        // 수학 연산자 (각각 강한 네온 색상으로 변경)
        const operators = [
            { symbol: "+", fn: (a, b) => a + b, color: 0x00FFFF, glow: 0x00FFFF }, // 네온 청록색
            { symbol: "-", fn: (a, b) => Math.max(1, a - b), color: 0xFF1493, glow: 0xFF1493 }, // 네온 핑크
            { symbol: "×", fn: (a, b) => a * b, color: 0x39FF14, glow: 0x39FF14 }, // 네온 그린
            { symbol: "÷", fn: (a, b) => Math.round(a / b) || 1, color: 0xFFD700, glow: 0xFFD700 } // 네온 골드
        ];
        
        // 게임 초기화
        function init() {
            // 씬 설정
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e); // 어두운 남색 배경
            
            // 안개 추가 (원근감) - 더 짙게 설정
            scene.fog = new THREE.Fog(0x1a1a2e, 30, 80);
            
            // 카메라 설정
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 8, 12); // 카메라 높이와 거리 조정
            camera.lookAt(0, 0, -20);
            
            // 렌더러 설정
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; // 그림자 활성화
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);
            
            // 조명 설정
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(0, 20, 10);
            directionalLight.castShadow = true; // 그림자 생성
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -20;
            directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20;
            directionalLight.shadow.camera.bottom = -20;
            scene.add(directionalLight);
            
            // 도로 생성
            createRoad();
            
            // 첫 아군 생성
            createAllies(1);
            
            // 이벤트 리스너
            window.addEventListener('resize', onWindowResize);
            document.getElementById('restartBtn').addEventListener('click', restartGame);
            
            // 모바일 컨트롤 초기화
            initControls();
            
            // 게임 타이머 시작
            startGameTimer();
            
            // 게임 루프 시작
            animate();
        }
        
        // 도로 생성 함수
        function createRoad() {
            // 도로 텍스처 (하늘색 그라데이션 패턴으로 변경)
            const roadWidth = 15;
            const roadLength = 1000;
            const segmentLength = 20;
            const segments = roadLength / segmentLength;
            
            // 도로 기본 재질 (네온 효과가 있는 어두운 색상)
            const roadMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x0f3460,
                roughness: 0.5,
                metalness: 0.7,
                emissive: 0x0f3460,
                emissiveIntensity: 0.2
            });
            
            // 도로 경계선 재질 (밝은 네온 색상)
            const lineMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xE94560, 
                emissive: 0xE94560,
                emissiveIntensity: 0.7
            });
            
            // 도로 가장자리 재질 (네온 푸른색)
            const sideMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x16213E,
                emissive: 0x0F52BA,
                emissiveIntensity: 0.3
            });
            
            // 도로 그라데이션을 위한 재질 배열 (네온 효과가 있는 패턴)
            const patternMaterials = [
                new THREE.MeshStandardMaterial({ 
                    color: 0x0f3460, 
                    emissive: 0x0f3460,
                    emissiveIntensity: 0.2
                }),
                new THREE.MeshStandardMaterial({ 
                    color: 0x16213E, 
                    emissive: 0x16213E,
                    emissiveIntensity: 0.2
                })
            ];
            
            // 여러 세그먼트로 도로 생성
            for (let i = 0; i < segments; i++) {
                // 도로 세그먼트 (패턴 적용)
                const roadGeometry = new THREE.PlaneGeometry(roadWidth, segmentLength);
                const road = new THREE.Mesh(roadGeometry, patternMaterials[i % 2]); // 번갈아가며 패턴 적용
                road.rotation.x = -Math.PI / 2;
                road.position.z = -i * segmentLength - segmentLength / 2;
                road.position.y = -0.1;
                road.receiveShadow = true; // 그림자 받기
                scene.add(road);
                roadSegments.push(road);
                
                // 도로 레인 구분선
                for (let j = -1; j <= 1; j += 2) {
                    const lineGeometry = new THREE.PlaneGeometry(0.3, segmentLength);
                    const line = new THREE.Mesh(lineGeometry, lineMaterial);
                    line.rotation.x = -Math.PI / 2;
                    line.position.set(j * roadWidth/6, -0.05, -i * segmentLength - segmentLength / 2);
                    line.receiveShadow = true;
                    scene.add(line);
                    roadSegments.push(line);
                }
                
                // 도로 가장자리
                for (let j = -1; j <= 1; j += 2) {
                    const sideGeometry = new THREE.BoxGeometry(2, 1, segmentLength);
                    const side = new THREE.Mesh(sideGeometry, sideMaterial);
                    side.position.set(j * (roadWidth/2 + 1), 0.4, -i * segmentLength - segmentLength / 2);
                    side.castShadow = true;
                    side.receiveShadow = true;
                    scene.add(side);
                    roadSegments.push(side);
                    
                    // 가드레일 기둥 추가
                    if (i % 2 === 0) {
                        const postGeometry = new THREE.BoxGeometry(0.5, 2, 0.5);
                        const postMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
                        const post = new THREE.Mesh(postGeometry, postMaterial);
                        post.position.set(j * (roadWidth/2 + 1), 1.5, -i * segmentLength - segmentLength / 2);
                        post.castShadow = true;
                        post.receiveShadow = true;
                        scene.add(post);
                        roadSegments.push(post);
                    }
                }
            }
        }
        
        // 도로 스크롤 함수
        function scrollRoad() {
            const resetPos = -1000; // 도로 총 길이
            
            roadSegments.forEach(segment => {
                segment.position.z += roadSpeed;
                
                // 도로 세그먼트가 카메라 뒤로 지나가면 다시 앞으로 재배치
                if (segment.position.z > 20) {
                    segment.position.z = resetPos + (segment.position.z - 20);
                }
            });
            
            // 거리 증가
            gameDistance += roadSpeed;
        }
        
        // 컨트롤 초기화
        function initControls() {
            const leftBtn = document.getElementById('leftBtn');
            const rightBtn = document.getElementById('rightBtn');
            
            // 터치 이벤트
            leftBtn.addEventListener('touchstart', moveLeft);
            rightBtn.addEventListener('touchstart', moveRight);
            
            // 마우스 이벤트 (데스크톱용)
            leftBtn.addEventListener('mousedown', moveLeft);
            rightBtn.addEventListener('mousedown', moveRight);
            
            // 키보드 이벤트
            window.addEventListener('keydown', function(e) {
                if (!gameActive || isMoving) return;
                
                if (e.key === 'ArrowLeft') {
                    moveLeft();
                } else if (e.key === 'ArrowRight') {
                    moveRight();
                }
            });
            
            function moveLeft() {
                if (!gameActive || isMoving || playerLane === 0) return;
                
                isMoving = true;
                playerLane--;
                moveAlliesTo(lanes[playerLane]);
            }
            
            function moveRight() {
                if (!gameActive || isMoving || playerLane === 2) return;
                
                isMoving = true;
                playerLane++;
                moveAlliesTo(lanes[playerLane]);
            }
        }
        
        // 아군 이동 함수
        function moveAlliesTo(targetX) {
            // 0.3초에 걸쳐 부드럽게 이동
            const frames = 15; // 60fps 기준 0.25초
            let currentFrame = 0;
            
            // 메인 아군 현재 위치
            const startX = allies[0].position.x;
            const moveAmount = (targetX - startX) / frames;
            
            const moveInterval = setInterval(() => {
                if (currentFrame >= frames) {
                    clearInterval(moveInterval);
                    isMoving = false;
                    return;
                }
                
                // 모든 아군 이동
                allies.forEach((ally, index) => {
                    if (index === 0) {
                        // 메인 아군
                        ally.position.x += moveAmount;
                    } else {
                        // 나머지 아군들은 메인 아군을 따라감
                        updateAllyFormation();
                    }
                });
                
                currentFrame++;
            }, 1000/60); // 60fps
        }
        
        // 아군 진형 업데이트
        function updateAllyFormation() {
            if (allies.length <= 1) return;
            
            const mainAlly = allies[0];
            const allyCount = allies.length;
            
            // 진영 크기 계산 - 아군이 많을수록 더 넓게 퍼짐
            const formationWidth = Math.min(3, 0.5 + (allyCount * 0.1));
            const formationDepth = Math.min(4, 1 + (allyCount * 0.15));
            
            for (let i = 1; i < allyCount; i++) {
                // 균등하게 분포된 위치 계산
                let row = Math.floor((i-1) / 3);
                let col = (i-1) % 3;
                
                // 중앙 정렬을 위한 오프셋
                let colOffset = col - 1; // -1, 0, 1
                let rowOffset = -row; // 항상 플레이어 뒤에 배치
                
                allies[i].position.x = mainAlly.position.x + (colOffset * formationWidth);
                allies[i].position.z = mainAlly.position.z + (rowOffset * formationDepth);
            }
        }
        
        // 아군 생성 함수 - 캐릭터 디자인 개선
        function createAllies(count) {
            // 기존 아군 제거
            allies.forEach(ally => scene.remove(ally));
            allies = [];
            
            // 최댓값 제한 (너무 많으면 게임이 쉬워짐)
            count = Math.min(count, 30);
            
            // 새 아군 생성 - 귀여운 오렌지색 캐릭터로 변경
            for (let i = 0; i < count; i++) {
                // 캐릭터 그룹
                const character = new THREE.Group();
                
                // 몸체 (구)
                const bodyGeometry = new THREE.SphereGeometry(0.5, 16, 16);
                const bodyMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFF9900, // 오렌지색
                    emissive: 0xAA5500,
                    emissiveIntensity: 0.2,
                    roughness: 0.7
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.castShadow = true;
                body.receiveShadow = true;
                character.add(body);
                
                // 캐릭터에 눈 추가
                const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
                
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(0.2, 0.2, 0.4);
                character.add(leftEye);
                
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(-0.2, 0.2, 0.4);
                character.add(rightEye);
                
                // 눈동자
                const pupilGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                const pupilMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
                
                const leftPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                leftPupil.position.set(0.2, 0.2, 0.45);
                character.add(leftPupil);
                
                const rightPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                rightPupil.position.set(-0.2, 0.2, 0.45);
                character.add(rightPupil);
                
                // 팔과 다리 추가 (메인 캐릭터만)
                if (i === 0) {
                    // 팔
                    const armGeometry = new THREE.SphereGeometry(0.15, 8, 8);
                    
                    const leftArm = new THREE.Mesh(armGeometry, bodyMaterial);
                    leftArm.position.set(0.6, 0, 0);
                    leftArm.castShadow = true;
                    character.add(leftArm);
                    
                    const rightArm = new THREE.Mesh(armGeometry, bodyMaterial);
                    rightArm.position.set(-0.6, 0, 0);
                    rightArm.castShadow = true;
                    character.add(rightArm);
                    
                    // 다리
                    const legGeometry = new THREE.CylinderGeometry(0.15, 0.1, 0.5, 8);
                    
                    const leftLeg = new THREE.Mesh(legGeometry, bodyMaterial);
                    leftLeg.position.set(0.2, -0.5, 0);
                    leftLeg.castShadow = true;
                    character.add(leftLeg);
                    
                    const rightLeg = new THREE.Mesh(legGeometry, bodyMaterial);
                    rightLeg.position.set(-0.2, -0.5, 0);
                    rightLeg.castShadow = true;
                    character.add(rightLeg);
                }
                
                if (i === 0) {
                    // 메인 아군 (플레이어)
                    character.position.set(lanes[playerLane], 0.5, 0);
                } else {
                    // 추가 아군들은 초기 위치만 설정 (updateAllyFormation에서 정확히 배치됨)
                    character.position.set(lanes[playerLane], 0.5, -i);
                    // 작게 만들기
                    character.scale.set(0.8, 0.8, 0.8);
                }
                
                scene.add(character);
                allies.push(character);
            }
            
            // 진형 업데이트
            updateAllyFormation();
            
            // UI 업데이트
            document.getElementById('allyCount').textContent = allies.length;
        }
        
        // 적 생성 함수 - 웨이브 형태로 생성
        function createEnemyWave() {
            const waveType = Math.floor(Math.random() * 4);
            
            switch (waveType) {
                case 0: // 일렬 웨이브
                    const randomLane = Math.floor(Math.random() * 3);
                    for (let i = 0; i < 5 + Math.floor(difficulty); i++) {
                        createEnemy(randomLane, -80 - (i * 4));
                    }
                    break;
                    
                case 1: // V 형태 웨이브
                    for (let i = 0; i < 7; i++) {
                        const laneOffset = (i <= 3) ? i : 6 - i; // 0,1,2,3,2,1,0
                        createEnemy(laneOffset, -80 - (i * 3));
                    }
                    break;
                    
                case 2: // 모든 레인 웨이브
                    for (let i = 0; i < 3; i++) {
                        for (let j = 0; j < 3; j++) {
                            createEnemy(j, -80 - (i * 5));
                        }
                    }
                    break;
                    
                case 3: // 랜덤 웨이브
                    const enemyCount = 5 + Math.floor(difficulty * 2);
                    for (let i = 0; i < enemyCount; i++) {
                        const randLane = Math.floor(Math.random() * 3);
                        const randDist = -80 - (Math.random() * 20);
                        createEnemy(randLane, randDist);
                    }
                    break;
            }
            
            function createEnemy(lane, zPos) {
                // 적 그룹
                const enemy = new THREE.Group();
                
                // 적 몸체 (더 큰 크기와 강한 네온 빨간색)
                const enemyGeometry = new THREE.SphereGeometry(0.6, 16, 16);
                const enemyMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xff0000,
                    emissive: 0xff0000,
                    emissiveIntensity: 0.8,
                    roughness: 0.3,
                    metalness: 0.7
                });
                const body = new THREE.Mesh(enemyGeometry, enemyMaterial);
                body.castShadow = true;
                body.receiveShadow = true;
                enemy.add(body);
                
                // 적 눈 (흰색)
                const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
                
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(0.2, 0.2, 0.4);
                enemy.add(leftEye);
                
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(-0.2, 0.2, 0.4);
                enemy.add(rightEye);
                
                // 적 눈동자 (검은색)
                const pupilGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                const pupilMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
                
                const leftPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                leftPupil.position.set(0.2, 0.2, 0.45);
                enemy.add(leftPupil);
                
                const rightPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                rightPupil.position.set(-0.2, 0.2, 0.45);
                enemy.add(rightPupil);
                
                enemy.position.set(lanes[lane], 0.5, zPos);
                scene.add(enemy);
                enemies.push(enemy);
            }
        }
        
        // 총알 발사 함수
        function fireBullets() {
            const currentTime = Date.now();
            
            // 자동 발사 간격 (아군 수에 따라 감소)
            const fireInterval = Math.max(100, 500 - (allies.length * 10));
            
            if (currentTime - lastFireTime < fireInterval) return;
            
            lastFireTime = currentTime;
            
            // 아군 수에 비례해서 총알 발사 (아군당 0.5발의 총알)
            const bulletsToFire = Math.max(1, Math.ceil(allies.length * 0.5));
            
            for (let i = 0; i < bulletsToFire; i++) {
                const bulletGeometry = new THREE.SphereGeometry(0.3, 8, 8);
                const bulletMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFFFF00, 
                    emissive: 0xFFFF00,
                    emissiveIntensity: 1.0,
                    metalness: 1.0,
                    roughness: 0.0
                });
                const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
                
                // 총알 발사 방향 다각화
                let angleOffset = 0;
                if (bulletsToFire > 1) {
                    // 부채꼴 형태로 퍼지게 발사
                    const spreadFactor = Math.min(0.3, bulletsToFire * 0.02);  // 최대 0.3 라디안 (약 17도)
                    angleOffset = spreadFactor * ((i / (bulletsToFire - 1)) * 2 - 1);
                }
                
                // 총알 위치는 무작위 아군 위치에서 시작
                const shooterIndex = Math.floor(Math.random() * allies.length);
                bullet.position.copy(allies[shooterIndex].position);
                bullet.position.z -= 1; // 약간 앞에서 발사
                
                // 총알 방향 설정
                bullet.userData.direction = new THREE.Vector3(angleOffset, 0, -1).normalize();
                bullet.userData.speed = 1.5;
                
                scene.add(bullet);
                bullets.push(bullet);
                
                // 총알 발사 이펙트 (강한 빛)
                const bulletLight = new THREE.PointLight(0xffff00, 5, 8);
                bulletLight.position.copy(bullet.position);
                scene.add(bulletLight);
                
                // 추가 발광 효과 (더 넓은 범위)
                const bulletGlow = new THREE.PointLight(0xffff00, 2, 15);
                bulletGlow.position.copy(bullet.position);
                scene.add(bulletGlow);
                
                // 0.1초 후 이펙트 제거
                setTimeout(() => {
                    scene.remove(bulletLight);
                }, 100);
            }
        }
        
        // 사칙연산 패널 생성 함수
        function createMathPanels() {
            // 기존 패널 제거
            panels.forEach(panel => scene.remove(panel));
            panels = [];
            
            // 랜덤 연산자 선택
            const operator = operators[Math.floor(Math.random() * operators.length)];
            
            // 피연산자 선택 (난이도에 따라 증가)
            const operand = Math.floor(Math.random() * Math.min(5, difficulty)) + 1;
            
            // 현재 아군 수와 연산 결과 계산
            const currentAllies = allies.length;
            const result = operator.fn(currentAllies, operand);
            
            // 연산 표시 업데이트
            activeEquation = `${currentAllies} ${operator.symbol} ${operand} = ${result}`;
            document.getElementById('currentEquation').textContent = activeEquation;
            
            // 도로 세 레인에 패널 생성
            for (let i = 0; i < 3; i++) {
                createMathPanel(lanes[i], -60 - Math.random() * 10, operand, operator);
            }
            
            function createMathPanel(x, z, operand, operator) {
                // 패널 그룹
                const panel = new THREE.Group();
                
                // 패널 플랫폼
                const panelGeometry = new THREE.BoxGeometry(3, 0.3, 3);
                
                // 연산자에 맞는 색상 적용 (강한 네온 효과)
                const panelMaterial = new THREE.MeshStandardMaterial({ 
                    color: operator.color,
                    emissive: operator.glow,
                    emissiveIntensity: 0.8,
                    transparent: true,
                    opacity: 0.9
                });
                
                const panelMesh = new THREE.Mesh(panelGeometry, panelMaterial);
                panelMesh.castShadow = true;
                panelMesh.receiveShadow = true;
                panel.add(panelMesh);
                
                // 패널에 숫자 표시를 위한 텍스트 (Three.js에서는 실제 텍스트 렌더링이 어려워 대체 표현)
                const operatorSymbol = operator.symbol;
                const operatorTextGeometry = new THREE.BoxGeometry(1, 0.1, 1);
                const operatorTextMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFFFFFF,
                    emissive: 0xFFFFFF,
                    emissiveIntensity: 0.5
                });
                
                const operatorText = new THREE.Mesh(operatorTextGeometry, operatorTextMaterial);
                operatorText.position.y = 0.2;
                panel.add(operatorText);
                
                // 숫자 표시 (간소화된 형태)
                const numberGeometry = new THREE.BoxGeometry(0.5, 0.1, 0.5);
                const numberMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
                const numberMesh = new THREE.Mesh(numberGeometry, numberMaterial);
                numberMesh.position.set(0, 0.2, 0.5);
                panel.add(numberMesh);
                
                // 패널 위치 설정
                panel.position.set(x, 0, z);
                
                // 패널에 연산 데이터 추가
                panel.userData = {
                    operator: operatorSymbol,
                    operand: operand,
                    result: result
                };
                
                // 패널 강한 발광 효과
                const panelLight = new THREE.PointLight(operator.color, 2, 8);
                panelLight.position.set(0, 0.5, 0);
                panel.add(panelLight);
                
                // 추가 외곽 발광 효과
                const outerGlow = new THREE.PointLight(operator.color, 1, 15);
                outerGlow.position.set(0, 1, 0);
                panel.add(outerGlow);
                
                // 패널 주변 네온 효과를 위한 추가 메시
                const glowGeometry = new THREE.BoxGeometry(3.2, 0.1, 3.2);
                const glowMaterial = new THREE.MeshBasicMaterial({ 
                    color: operator.color,
                    transparent: true,
                    opacity: 0.5
                });
                const glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
                glowMesh.position.y = -0.2;
                panel.add(glowMesh);
                
                scene.add(panel);
                panels.push(panel);
            }
        }
        
        // 게임 업데이트 함수
        function updateGame() {
            const currentTime = Date.now();
            
            // 도로 스크롤
            scrollRoad();
            
            // 3초마다 패널 생성
            if (currentTime - lastPanelTime > 3000) {
                createMathPanels();
                lastPanelTime = currentTime;
            }
            
            // 난이도에 따라 적 웨이브 생성 주기 조절
            const enemyWaveInterval = Math.max(2000, 5000 - (difficulty * 300));
            if (currentTime - lastEnemyWaveTime > enemyWaveInterval) {
                createEnemyWave();
                lastEnemyWaveTime = currentTime;
            }
            
            // 자동 총알 발사
            fireBullets();
            
            // 패널 이동 (도로와 함께 이동)
            panels.forEach(panel => {
                panel.position.z += roadSpeed;
                
                // 화면 끝에 도달한 패널은 제거
                if (panel.position.z > 10) {
                    scene.remove(panel);
                    panels.splice(panels.indexOf(panel), 1);
                    
                    // 모든 패널이 사라졌을 때 현재 연산 초기화
                    if (panels.length === 0) {
                        document.getElementById('currentEquation').textContent = "없음";
                    }
                }
            });
            
            // 적 이동 (도로와 함께 이동, 약간 더 빠르게)
            enemies.forEach(enemy => {
                enemy.position.z += roadSpeed * 1.2;
                
                // 화면 끝에 도달한 적은 제거
                if (enemy.position.z > 10) {
                    scene.remove(enemy);
                    enemies.splice(enemies.indexOf(enemy), 1);
                }
                
                // 적 애니메이션 (약간 상하로 움직임)
                enemy.position.y = 0.5 + Math.sin(currentTime / 300 + enemy.position.z) * 0.1;
                
                // 추가: 적 회전 애니메이션
                enemy.rotation.y += 0.02;
            });
            
            // 아군 애니메이션 (약간 위아래로 움직임)
            allies.forEach((ally, index) => {
                // 메인 캐릭터 (0번 인덱스)만 특별한 애니메이션 적용
                if (index === 0) {
                    ally.position.y = 0.5 + Math.sin(currentTime / 500) * 0.05;
                    
                    // 달리기 애니메이션 효과 (앞뒤로 약간 기울임)
                    ally.rotation.x = Math.sin(currentTime / 200) * 0.1;
                } else {
                    // 다른 아군들은 약간 다른 주기로 움직여 자연스러움 증가
                    ally.position.y = 0.5 + Math.sin((currentTime / 500) + index * 0.5) * 0.05;
                }
            });
            
            // 총알 이동
            bullets.forEach(bullet => {
                const direction = bullet.userData.direction;
                bullet.position.x += direction.x * bullet.userData.speed;
                bullet.position.z += direction.z * bullet.userData.speed;
                
                // 총알 회전 효과 추가
                bullet.rotation.x += 0.2;
                bullet.rotation.y += 0.2;
                
                // 화면 밖으로 나간 총알 제거
                if (bullet.position.z < -100) {
                    scene.remove(bullet);
                    bullets.splice(bullets.indexOf(bullet), 1);
                }
            });
            
            // 충돌 체크
            checkCollisions();
            
            // 난이도 증가
            difficulty = 1 + ((60 - gameTime) / 5);
            
            // 도로 속도 증가 (난이도에 따라)
            roadSpeed = 0.5 + (difficulty * 0.05);
        }
        
        // 충돌 체크 함수 - 시각적 효과 추가
        function checkCollisions() {
            // 총알과 적의 충돌
            bullets.forEach(bullet => {
                enemies.forEach(enemy => {
                    const distance = bullet.position.distanceTo(enemy.position);
                    if (distance < 1) {
                        // 충돌 시 폭발 효과
                        createExplosion(enemy.position.clone());
                        
                        // 충돌 발생
                        scene.remove(bullet);
                        scene.remove(enemy);
                        bullets.splice(bullets.indexOf(bullet), 1);
                        enemies.splice(enemies.indexOf(enemy), 1);
                        
                        // 점수 추가
                        score += 10;
                        document.getElementById('score').textContent = score;
                    }
                });
            });
            
            // 플레이어(메인 아군)와 패널의 충돌
            if (allies.length > 0) {
                const player = allies[0];
                
                panels.forEach(panel => {
                    const distance = Math.sqrt(
                        Math.pow(player.position.x - panel.position.x, 2) +
                        Math.pow(player.position.z - panel.position.z, 2)
                    );
                    
                    if (distance < 2) {
                        // 패널과 충돌 - 사칙연산 수행
                        if (panel.userData.result !== undefined) {
                            // 패널 획득 효과
                            createPanelEffect(player.position.clone());
                            
                            createAllies(panel.userData.result);
                            
                            // 보너스 점수
                            score += 50;
                            document.getElementById('score').textContent = score;
                            
                            // 모든 패널 제거
                            panels.forEach(p => scene.remove(p));
                            panels = [];
                            
                            // 연산 초기화
                            document.getElementById('currentEquation').textContent = "없음";
                        }
                    }
                });
                
                // 플레이어와 적의 충돌
                enemies.forEach(enemy => {
                    const distance = player.position.distanceTo(enemy.position);
                    if (distance < 1.2) {
                        // 충돌 시 데미지 효과
                        createDamageEffect(player.position.clone());
                        
                        // 충돌 발생 - 아군 감소
                        if (allies.length > 1) {
                            createAllies(allies.length - 1);
                            
                            // 해당 적 제거
                            scene.remove(enemy);
                            enemies.splice(enemies.indexOf(enemy), 1);
                        } else {
                            // 마지막 아군이 적과 충돌하면 게임 오버
                            endGame();
                        }
                    }
                });
            }
        }
        
        // 폭발 효과 생성 함수
        function createExplosion(position) {
            // 폭발 파티클 그룹
            const explosionGroup = new THREE.Group();
            explosionGroup.position.copy(position);
            
            // 폭발 빛
            const explosionLight = new THREE.PointLight(0xff5500, 3, 8);
            explosionLight.position.set(0, 0, 0);
            explosionGroup.add(explosionLight);
            
            // 파티클 생성
            const particleCount = 10;
            const particles = [];
            
            for (let i = 0; i < particleCount; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const particleMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xff5500, 
                    transparent: true, 
                    opacity: 1
                });
                
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                
                // 랜덤 방향으로 튀어나감
                const angle1 = Math.random() * Math.PI * 2;
                const angle2 = Math.random() * Math.PI * 2;
                
                const speed = 0.1 + Math.random() * 0.2;
                particle.userData.velocity = new THREE.Vector3(
                    Math.sin(angle1) * Math.cos(angle2) * speed,
                    Math.sin(angle1) * Math.sin(angle2) * speed,
                    Math.cos(angle1) * speed
                );
                
                explosionGroup.add(particle);
                particles.push(particle);
            }
            
            scene.add(explosionGroup);
            
            // 0.5초 동안 폭발 애니메이션
            let elapsed = 0;
            const duration = 500; // 밀리초
            const interval = setInterval(() => {
                elapsed += 16;
                
                // 파티클 이동 및 페이드 아웃
                particles.forEach(particle => {
                    particle.position.add(particle.userData.velocity);
                    particle.material.opacity = 1 - (elapsed / duration);
                    particle.scale.multiplyScalar(0.98);
                });
                
                // 빛 감소
                explosionLight.intensity = 3 * (1 - elapsed / duration);
                
                if (elapsed >= duration) {
                    clearInterval(interval);
                    scene.remove(explosionGroup);
                }
            }, 16);
        }
        
        // 패널 획득 효과
        function createPanelEffect(position) {
            // 빛 생성
            const light = new THREE.PointLight(0x00ffff, 3, 10);
            light.position.copy(position);
            scene.add(light);
            
            // 0.5초 동안 빛 효과
            let elapsed = 0;
            const duration = 500; // 밀리초
            const interval = setInterval(() => {
                elapsed += 16;
                
                // 빛 강도 조절
                light.intensity = 3 * (1 - elapsed / duration);
                
                if (elapsed >= duration) {
                    clearInterval(interval);
                    scene.remove(light);
                }
            }, 16);
        }
        
        // 데미지 효과
        function createDamageEffect(position) {
            // 빨간 빛 생성
            const light = new THREE.PointLight(0xff0000, 3, 10);
            light.position.copy(position);
            scene.add(light);
            
            // 화면 빨갛게 깜빡임 (CSS 효과)
            const overlay = document.createElement('div');
            overlay.style.position = 'absolute';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.width = '100%';
            overlay.style.height = '100%';
            overlay.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
            overlay.style.pointerEvents = 'none';
            overlay.style.transition = 'opacity 0.5s';
            document.body.appendChild(overlay);
            
            // 0.5초 동안 효과
            setTimeout(() => {
                overlay.style.opacity = '0';
                setTimeout(() => {
                    document.body.removeChild(overlay);
                }, 500);
            }, 100);
            
            // 빛 효과 제거
            setTimeout(() => {
                scene.remove(light);
            }, 500);
        }
        
        // 게임 타이머 함수
        function startGameTimer() {
            const timerInterval = setInterval(() => {
                if (!gameActive) {
                    clearInterval(timerInterval);
                    return;
                }
                
                gameTime--;
                document.getElementById('timer').textContent = gameTime;
                
                if (gameTime <= 0) {
                    clearInterval(timerInterval);
                    endGame();
                }
            }, 1000);
        }
        
        // 게임 종료 함수
        function endGame() {
            gameActive = false;
            document.getElementById('gameOver').style.display = 'block';
            document.getElementById('finalScore').textContent = score;
            
            // 게임 오버 효과
            const gameOverLight = new THREE.AmbientLight(0xff0000, 0.3);
            scene.add(gameOverLight);
            
            // 모든 아군 회전 애니메이션
            const rotateAllies = () => {
                allies.forEach(ally => {
                    ally.rotation.y += 0.05;
                });
                
                if (gameActive) {
                    return;
                }
                
                requestAnimationFrame(rotateAllies);
            };
            
            rotateAllies();
        }
        
        // 게임 재시작 함수
        function restartGame() {
            // 기존 오브젝트 정리
            allies.forEach(ally => scene.remove(ally));
            enemies.forEach(enemy => scene.remove(enemy));
            bullets.forEach(bullet => scene.remove(bullet));
            panels.forEach(panel => scene.remove(panel));
            
            // 씬의 모든 빛 제거 (게임 오버 효과 제거)
            scene.children.forEach(child => {
                if (child instanceof THREE.Light && !(child instanceof THREE.DirectionalLight) && !(child instanceof THREE.AmbientLight && child.intensity === 0.6)) {
                    scene.remove(child);
                }
            });
            
            allies = [];
            enemies = [];
            bullets = [];
            panels = [];
            
            // 변수 초기화
            gameTime = 60;
            score = 0;
            difficulty = 1;
            gameActive = true;
            lastPanelTime = 0;
            lastEnemyWaveTime = 0;
            playerLane = 1; // 중앙 레인으로 초기화
            isMoving = false;
            roadSpeed = 0.5;
            gameDistance = 0;
            
            // UI 초기화
            document.getElementById('timer').textContent = gameTime;
            document.getElementById('score').textContent = score;
            document.getElementById('currentEquation').textContent = "없음";
            document.getElementById('gameOver').style.display = 'none';
            
            // 기본 조명 재설정
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(0, 20, 10);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // 첫 아군 생성
            createAllies(1);
            
            // 타이머 재시작
            startGameTimer();
        }
        
        // 애니메이션 루프
        function animate() {
            requestAnimationFrame(animate);
            
            if (gameActive) {
                updateGame();
            }
            
            renderer.render(scene, camera);
        }
        
        // 화면 크기 조정 이벤트
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // 게임 시작
        init();
    </script>
</body>
</html>
</antArtifact><antArtifact identifier="enhanced-game" type="application/vnd.ant.code" language="html" title="Enhanced Math Runner 3D Game">
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>러너 3D 슈팅 게임</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: Arial, sans-serif; 
            touch-action: none;
            background-color: #000;
        }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: #00ffff; /* 네온 청록색 */
            padding: 5px;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff, 0 0 30px #00ffff;
            z-index: 10;
            letter-spacing: 1px;
        }
        #equationInfo {
            position: absolute;
            top: 50px;
            width: 100%;
            text-align: center;
            color: #ff00ff; /* 네온 핑크 */
            padding: 5px;
            font-size: 22px;
            font-weight: bold;
            text-shadow: 0 0 10px #ff00ff, 0 0 20px #ff00ff;
            z-index: 10;
            letter-spacing: 1px;
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff0055;
            background-color: rgba(20, 20, 40, 0.9);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            display: none;
            z-index: 20;
            box-shadow: 0 0 20px #ff0055, 0 0 40px #ff0055;
            border: 2px solid #ff0055;
        }
        #gameOver h2 {
            font-size: 40px;
            text-shadow: 0 0 10px #ff0055, 0 0 20px #ff0055;
            margin-bottom: 20px;
        }
        #gameOver p {
            font-size: 24px;
            margin-bottom: 30px;
            color: #ffffff;
            text-shadow: 0 0 5px #ffffff;
        }
        #restartBtn {
            padding: 15px 40px;
            background-color: #ff0055;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 22px;
            margin-top: 20px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            box-shadow: 0 0 10px #ff0055, 0 0 20px #ff0055;
            transition: all 0.3s ease;
        }
        #restartBtn:hover {
            background-color: #ff3377;
            transform: scale(1.05);
            box-shadow: 0 0 15px #ff0055, 0 0 30px #ff0055;
        }
        #controls {
            position: absolute;
            bottom: 40px;
            width: 100%;
            display: flex;
            justify-content: center;
            z-index: 10;
        }
        .controlBtn {
            width: 100px;
            height: 100px;
            background-color: rgba(0, 200, 255, 0.2);
            border: 3px solid rgba(0, 200, 255, 0.8);
            border-radius: 50px;
            margin: 0 30px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #00FFFF;
            font-weight: bold;
            font-size: 30px;
            user-select: none;
            box-shadow: 0 0 15px #00FFFF;
            text-shadow: 0 0 10px #00FFFF;
        }
    </style>
</head>
<body>
    <div id="info">아군: <span id="allyCount">1</span> | 시간: <span id="timer">60</span>초 | 점수: <span id="score">0</span></div>
    <div id="equationInfo">현재 패널: <span id="currentEquation">없음</span></div>
    <div id="gameOver">
        <h2>게임 종료!</h2>
        <p>최종 점수: <span id="finalScore">0</span></p>
        <button id="restartBtn">다시 시작</button>
    </div>
    <div id="controls">
        <div id="leftBtn" class="controlBtn">←</div>
        <div id="rightBtn" class="controlBtn">→</div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // 게임 변수
        let scene, camera, renderer, allies = [], enemies = [], bullets = [], panels = [];
        let gameTime = 60; // 1분
        let score = 0;
        let difficulty = 1;
        let gameActive = true;
        let lastPanelTime = 0;
        let lastEnemyWaveTime = 0;
        let lastFireTime = 0;
        let playerLane = 1; // 0: 왼쪽, 1: 중앙, 2: 오른쪽
        let isMoving = false;
        let roadSpeed = 0.5;
        let roadSegments = [];
        let gameDistance = 0;
        let activeEquation = "";
        
        // 레인 위치 정의
        const lanes = [-5, 0, 5];
        
        // 수학 연산자 (각각 강한 네온 색상으로 변경)
        const operators = [
            { symbol: "+", fn: (a, b) => a + b, color: 0x00FFFF, glow: 0x00FFFF }, // 네온 청록색
            { symbol: "-", fn: (a, b) => Math.max(1, a - b), color: 0xFF1493, glow: 0xFF1493 }, // 네온 핑크
            { symbol: "×", fn: (a, b) => a * b, color: 0x39FF14, glow: 0x39FF14 }, // 네온 그린
            { symbol: "÷", fn: (a, b) => Math.round(a / b) || 1, color: 0xFFD700, glow: 0xFFD700 } // 네온 골드
        ];
        
        // 게임 초기화
        function init() {
            // 씬 설정
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e); // 어두운 남색 배경
            
            // 안개 추가 (원근감) - 더 짙게 설정
            scene.fog = new THREE.Fog(0x1a1a2e, 30, 80);
            
            // 카메라 설정
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 8, 12); // 카메라 높이와 거리 조정
            camera.lookAt(0, 0, -20);
            
            // 렌더러 설정
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; // 그림자 활성화
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);
            
            // 조명 설정
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(0, 20, 10);
            directionalLight.castShadow = true; // 그림자 생성
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -20;
            directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20;
            directionalLight.shadow.camera.bottom = -20;
            scene.add(directionalLight);
            
            // 도로 생성
            createRoad();
            
            // 첫 아군 생성
            createAllies(1);
            
            // 이벤트 리스너
            window.addEventListener('resize', onWindowResize);
            document.getElementById('restartBtn').addEventListener('click', restartGame);
            
            // 모바일 컨트롤 초기화
            initControls();
            
            // 게임 타이머 시작
            startGameTimer();
            
            // 게임 루프 시작
            animate();
        }
        
        // 도로 생성 함수
        function createRoad() {
            // 도로 텍스처 (하늘색 그라데이션 패턴으로 변경)
            const roadWidth = 15;
            const roadLength = 1000;
            const segmentLength = 20;
            const segments = roadLength / segmentLength;
            
            // 도로 기본 재질 (네온 효과가 있는 어두운 색상)
            const roadMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x0f3460,
                roughness: 0.5,
                metalness: 0.7,
                emissive: 0x0f3460,
                emissiveIntensity: 0.2
            });
            
            // 도로 경계선 재질 (밝은 네온 색상)
            const lineMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xE94560, 
                emissive: 0xE94560,
                emissiveIntensity: 0.7
            });
            
            // 도로 가장자리 재질 (네온 푸른색)
            const sideMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x16213E,
                emissive: 0x0F52BA,
                emissiveIntensity: 0.3
            });
            
            // 도로 그라데이션을 위한 재질 배열 (네온 효과가 있는 패턴)
            const patternMaterials = [
                new THREE.MeshStandardMaterial({ 
                    color: 0x0f3460, 
                    emissive: 0x0f3460,
                    emissiveIntensity: 0.2
                }),
                new THREE.MeshStandardMaterial({ 
                    color: 0x16213E, 
                    emissive: 0x16213E,
                    emissiveIntensity: 0.2
                })
            ];
            
            // 여러 세그먼트로 도로 생성
            for (let i = 0; i < segments; i++) {
                // 도로 세그먼트 (패턴 적용)
                const roadGeometry = new THREE.PlaneGeometry(roadWidth, segmentLength);
                const road = new THREE.Mesh(roadGeometry, patternMaterials[i % 2]); // 번갈아가며 패턴 적용
                road.rotation.x = -Math.PI / 2;
                road.position.z = -i * segmentLength - segmentLength / 2;
                road.position.y = -0.1;
                road.receiveShadow = true; // 그림자 받기
                scene.add(road);
                roadSegments.push(road);
                
                // 도로 레인 구분선
                for (let j = -1; j <= 1; j += 2) {
                    const lineGeometry = new THREE.PlaneGeometry(0.3, segmentLength);
                    const line = new THREE.Mesh(lineGeometry, lineMaterial);
                    line.rotation.x = -Math.PI / 2;
                    line.position.set(j * roadWidth/6, -0.05, -i * segmentLength - segmentLength / 2);
                    line.receiveShadow = true;
                    scene.add(line);
                    roadSegments.push(line);
                }
                
                // 도로 가장자리
                for (let j = -1; j <= 1; j += 2) {
                    const sideGeometry = new THREE.BoxGeometry(2, 1, segmentLength);
                    const side = new THREE.Mesh(sideGeometry, sideMaterial);
                    side.position.set(j * (roadWidth/2 + 1), 0.4, -i * segmentLength - segmentLength / 2);
                    side.castShadow = true;
                    side.receiveShadow = true;
                    scene.add(side);
                    roadSegments.push(side);
                    
                    // 가드레일 기둥 추가
                    if (i % 2 === 0) {
                        const postGeometry = new THREE.BoxGeometry(0.5, 2, 0.5);
                        const postMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
                        const post = new THREE.Mesh(postGeometry, postMaterial);
                        post.position.set(j * (roadWidth/2 + 1), 1.5, -i * segmentLength - segmentLength / 2);
                        post.castShadow = true;
                        post.receiveShadow = true;
                        scene.add(post);
                        roadSegments.push(post);
                    }
                }
            }
        }
        
        // 도로 스크롤 함수
        function scrollRoad() {
            const resetPos = -1000; // 도로 총 길이
            
            roadSegments.forEach(segment => {
                segment.position.z += roadSpeed;
                
                // 도로 세그먼트가 카메라 뒤로 지나가면 다시 앞으로 재배치
                if (segment.position.z > 20) {
                    segment.position.z = resetPos + (segment.position.z - 20);
                }
            });
            
            // 거리 증가
            gameDistance += roadSpeed;
        }
        
        // 컨트롤 초기화
        function initControls() {
            const leftBtn = document.getElementById('leftBtn');
            const rightBtn = document.getElementById('rightBtn');
            
            // 터치 이벤트
            leftBtn.addEventListener('touchstart', moveLeft);
            rightBtn.addEventListener('touchstart', moveRight);
            
            // 마우스 이벤트 (데스크톱용)
            leftBtn.addEventListener('mousedown', moveLeft);
            rightBtn.addEventListener('mousedown', moveRight);
            
            // 키보드 이벤트
            window.addEventListener('keydown', function(e) {
                if (!gameActive || isMoving) return;
                
                if (e.key === 'ArrowLeft') {
                    moveLeft();
                } else if (e.key === 'ArrowRight') {
                    moveRight();
                }
            });
            
            function moveLeft() {
                if (!gameActive || isMoving || playerLane === 0) return;
                
                isMoving = true;
                playerLane--;
                moveAlliesTo(lanes[playerLane]);
            }
            
            function moveRight() {
                if (!gameActive || isMoving || playerLane === 2) return;
                
                isMoving = true;
                playerLane++;
                moveAlliesTo(lanes[playerLane]);
            }
        }
        
        // 아군 이동 함수
        function moveAlliesTo(targetX) {
            // 0.3초에 걸쳐 부드럽게 이동
            const frames = 15; // 60fps 기준 0.25초
            let currentFrame = 0;
            
            // 메인 아군 현재 위치
            const startX = allies[0].position.x;
            const moveAmount = (targetX - startX) / frames;
            
            const moveInterval = setInterval(() => {
                if (currentFrame >= frames) {
                    clearInterval(moveInterval);
                    isMoving = false;
                    return;
                }
                
                // 모든 아군 이동
                allies.forEach((ally, index) => {
                    if (index === 0) {
                        // 메인 아군
                        ally.position.x += moveAmount;
                    } else {
                        // 나머지 아군들은 메인 아군을 따라감
                        updateAllyFormation();
                    }
                });
                
                currentFrame++;
            }, 1000/60); // 60fps
        }
        
        // 아군 진형 업데이트
        function updateAllyFormation() {
            if (allies.length <= 1) return;
            
            const mainAlly = allies[0];
            const allyCount = allies.length;
            
            // 진영 크기 계산 - 아군이 많을수록 더 넓게 퍼짐
            const formationWidth = Math.min(3, 0.5 + (allyCount * 0.1));
            const formationDepth = Math.min(4, 1 + (allyCount * 0.15));
            
            for (let i = 1; i < allyCount; i++) {
                // 균등하게 분포된 위치 계산
                let row = Math.floor((i-1) / 3);
                let col = (i-1) % 3;
                
                // 중앙 정렬을 위한 오프셋
                let colOffset = col - 1; // -1, 0, 1
                let rowOffset = -row; // 항상 플레이어 뒤에 배치
                
                allies[i].position.x = mainAlly.position.x + (colOffset * formationWidth);
                allies[i].position.z = mainAlly.position.z + (rowOffset * formationDepth);
            }
        }
        
        // 아군 생성 함수 - 캐릭터 디자인 개선
        function createAllies(count) {
            // 기존 아군 제거
            allies.forEach(ally => scene.remove(ally));
            allies = [];
            
            // 최댓값 제한 (너무 많으면 게임이 쉬워짐)
            count = Math.min(count, 30);
            
            // 새 아군 생성 - 귀여운 오렌지색 캐릭터로 변경
            for (let i = 0; i < count; i++) {
                // 캐릭터 그룹
                const character = new THREE.Group();
                
                // 몸체 (구)
                const bodyGeometry = new THREE.SphereGeometry(0.5, 16, 16);
                const bodyMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFF9900, // 오렌지색
                    emissive: 0xAA5500,
                    emissiveIntensity: 0.2,
                    roughness: 0.7
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.castShadow = true;
                body.receiveShadow = true;
                character.add(body);
                
                // 캐릭터에 눈 추가
                const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
                
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(0.2, 0.2, 0.4);
                character.add(leftEye);
                
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(-0.2, 0.2, 0.4);
                character.add(rightEye);
                
                // 눈동자
                const pupilGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                const pupilMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
                
                const leftPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                leftPupil.position.set(0.2, 0.2, 0.45);
                character.add(leftPupil);
                
                const rightPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                rightPupil.position.set(-0.2, 0.2, 0.45);
                character.add(rightPupil);
                
                // 팔과 다리 추가 (메인 캐릭터만)
                if (i === 0) {
                    // 팔
                    const armGeometry = new THREE.SphereGeometry(0.15, 8, 8);
                    
                    const leftArm = new THREE.Mesh(armGeometry, bodyMaterial);
                    leftArm.position.set(0.6, 0, 0);
                    leftArm.castShadow = true;
                    character.add(leftArm);
                    
                    const rightArm = new THREE.Mesh(armGeometry, bodyMaterial);
                    rightArm.position.set(-0.6, 0, 0);
                    rightArm.castShadow = true;
                    character.add(rightArm);
                    
                    // 다리
                    const legGeometry = new THREE.CylinderGeometry(0.15, 0.1, 0.5, 8);
                    
                    const leftLeg = new THREE.Mesh(legGeometry, bodyMaterial);
                    leftLeg.position.set(0.2, -0.5, 0);
                    leftLeg.castShadow = true;
                    character.add(leftLeg);
                    
                    const rightLeg = new THREE.Mesh(legGeometry, bodyMaterial);
                    rightLeg.position.set(-0.2, -0.5, 0);
                    rightLeg.castShadow = true;
                    character.add(rightLeg);
                }
                
                if (i === 0) {
                    // 메인 아군 (플레이어)
                    character.position.set(lanes[playerLane], 0.5, 0);
                } else {
                    // 추가 아군들은 초기 위치만 설정 (updateAllyFormation에서 정확히 배치됨)
                    character.position.set(lanes[playerLane], 0.5, -i);
                    // 작게 만들기
                    character.scale.set(0.8, 0.8, 0.8);
                }
                
                scene.add(character);
                allies.push(character);
            }
            
            // 진형 업데이트
            updateAllyFormation();
            
            // UI 업데이트
            document.getElementById('allyCount').textContent = allies.length;
        }
        
        // 적 생성 함수 - 웨이브 형태로 생성
        function createEnemyWave() {
            const waveType = Math.floor(Math.random() * 4);
            
            switch (waveType) {
                case 0: // 일렬 웨이브
                    const randomLane = Math.floor(Math.random() * 3);
                    for (let i = 0; i < 5 + Math.floor(difficulty); i++) {
                        createEnemy(randomLane, -80 - (i * 4));
                    }
                    break;
                    
                case 1: // V 형태 웨이브
                    for (let i = 0; i < 7; i++) {
                        const laneOffset = (i <= 3) ? i : 6 - i; // 0,1,2,3,2,1,0
                        createEnemy(laneOffset, -80 - (i * 3));
                    }
                    break;
                    
                case 2: // 모든 레인 웨이브
                    for (let i = 0; i < 3; i++) {
                        for (let j = 0; j < 3; j++) {
                            createEnemy(j, -80 - (i * 5));
                        }
                    }
                    break;
                    
                case 3: // 랜덤 웨이브
                    const enemyCount = 5 + Math.floor(difficulty * 2);
                    for (let i = 0; i < enemyCount; i++) {
                        const randLane = Math.floor(Math.random() * 3);
                        const randDist = -80 - (Math.random() * 20);
                        createEnemy(randLane, randDist);
                    }
                    break;
            }
            
            function createEnemy(lane, zPos) {
                // 적 그룹
                const enemy = new THREE.Group();
                
                // 적 몸체 (더 큰 크기와 강한 네온 빨간색)
                const enemyGeometry = new THREE.SphereGeometry(0.6, 16, 16);
                const enemyMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xff0000,
                    emissive: 0xff0000,
                    emissiveIntensity: 0.8,
                    roughness: 0.3,
                    metalness: 0.7
                });
                const body = new THREE.Mesh(enemyGeometry, enemyMaterial);
                body.castShadow = true;
                body.receiveShadow = true;
                enemy.add(body);
                
                // 적 눈 (흰색)
                const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
                
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(0.2, 0.2, 0.4);
                enemy.add(leftEye);
                
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(-0.2, 0.2, 0.4);
                enemy.add(rightEye);
                
                // 적 눈동자 (검은색)
                const pupilGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                const pupilMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
                
                const leftPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                leftPupil.position.set(0.2, 0.2, 0.45);
                enemy.add(leftPupil);
                
                const rightPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                rightPupil.position.set(-0.2, 0.2, 0.45);
                enemy.add(rightPupil);
                
                enemy.position.set(lanes[lane], 0.5, zPos);
                scene.add(enemy);
                enemies.push(enemy);
            }
        }
        
        // 총알 발사 함수
        function fireBullets() {
            const currentTime = Date.now();
            
            // 자동 발사 간격 (아군 수에 따라 감소)
            const fireInterval = Math.max(100, 500 - (allies.length * 10));
            
            if (currentTime - lastFireTime < fireInterval) return;
            
            lastFireTime = currentTime;
            
            // 아군 수에 비례해서 총알 발사 (아군당 0.5발의 총알)
            const bulletsToFire = Math.max(1, Math.ceil(allies.length * 0.5));
            
            for (let i = 0; i < bulletsToFire; i++) {
                const bulletGeometry = new THREE.SphereGeometry(0.3, 8, 8);
                const bulletMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFFFF00, 
                    emissive: 0xFFFF00,
                    emissiveIntensity: 1.0,
                    metalness: 1.0,
                    roughness: 0.0
                });
                const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
                
                // 총알 발사 방향 다각화
                let angleOffset = 0;
                if (bulletsToFire > 1) {
                    // 부채꼴 형태로 퍼지게 발사
                    const spreadFactor = Math.min(0.3, bulletsToFire * 0.02);  // 최대 0.3 라디안 (약 17도)
                    angleOffset = spreadFactor * ((i / (bulletsToFire - 1)) * 2 - 1);
                }
                
                // 총알 위치는 무작위 아군 위치에서 시작
                const shooterIndex = Math.floor(Math.random() * allies.length);
                bullet.position.copy(allies[shooterIndex].position);
                bullet.position.z -= 1; // 약간 앞에서 발사
                
                // 총알 방향 설정
                bullet.userData.direction = new THREE.Vector3(angleOffset, 0, -1).normalize();
                bullet.userData.speed = 1.5;
                
                scene.add(bullet);
                bullets.push(bullet);
                
                // 총알 발사 이펙트 (강한 빛)
                const bulletLight = new THREE.PointLight(0xffff00, 5, 8);
                bulletLight.position.copy(bullet.position);
                scene.add(bulletLight);
                
                // 추가 발광 효과 (더 넓은 범위)
                const bulletGlow = new THREE.PointLight(0xffff00, 2, 15);
                bulletGlow.position.copy(bullet.position);
                scene.add(bulletGlow);
                
                // 0.1초 후 이펙트 제거
                setTimeout(() => {
                    scene.remove(bulletLight);
                }, 100);
            }
        }
        
        // 사칙연산 패널 생성 함수
        function createMathPanels() {
            // 기존 패널 제거
            panels.forEach(panel => scene.remove(panel));
            panels = [];
            
            // 랜덤 연산자 선택
            const operator = operators[Math.floor(Math.random() * operators.length)];
            
            // 피연산자 선택 (난이도에 따라 증가)
            const operand = Math.floor(Math.random() * Math.min(5, difficulty)) + 1;
            
            // 현재 아군 수와 연산 결과 계산
            const currentAllies = allies.length;
            const result = operator.fn(currentAllies, operand);
            
            // 연산 표시 업데이트
            activeEquation = `${currentAllies} ${operator.symbol} ${operand} = ${result}`;
            document.getElementById('currentEquation').textContent = activeEquation;
            
            // 도로 세 레인에 패널 생성
            for (let i = 0; i < 3; i++) {
                createMathPanel(lanes[i], -60 - Math.random() * 10, operand, operator);
            }
            
            function createMathPanel(x, z, operand, operator) {
                // 패널 그룹
                const panel = new THREE.Group();
                
                // 패널 플랫폼
                const panelGeometry = new THREE.BoxGeometry(3, 0.3, 3);
                
                // 연산자에 맞는 색상 적용 (강한 네온 효과)
                const panelMaterial = new THREE.MeshStandardMaterial({ 
                    color: operator.color,
                    emissive: operator.glow,
                    emissiveIntensity: 0.8,
                    transparent: true,
                    opacity: 0.9
                });
                
                const panelMesh = new THREE.Mesh(panelGeometry, panelMaterial);
                panelMesh.castShadow = true;
                panelMesh.receiveShadow = true;
                panel.add(panelMesh);
                
                // 패널에 숫자 표시를 위한 텍스트 (Three.js에서는 실제 텍스트 렌더링이 어려워 대체 표현)
                const operatorSymbol = operator.symbol;
                const operatorTextGeometry = new THREE.BoxGeometry(1, 0.1, 1);
                const operatorTextMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFFFFFF,
                    emissive: 0xFFFFFF,
                    emissiveIntensity: 0.5
                });
                
                const operatorText = new THREE.Mesh(operatorTextGeometry, operatorTextMaterial);
                operatorText.position.y = 0.2;
                panel.add(operatorText);
                
                // 숫자 표시 (간소화된 형태)
                const numberGeometry = new THREE.BoxGeometry(0.5, 0.1, 0.5);
                const numberMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
                const numberMesh = new THREE.Mesh(numberGeometry, numberMaterial);
                numberMesh.position.set(0, 0.2, 0.5);
                panel.add(numberMesh);
                
                // 패널 위치 설정
                panel.position.set(x, 0, z);
                
                // 패널에 연산 데이터 추가
                panel.userData = {
                    operator: operatorSymbol,
                    operand: operand,
                    result: result
                };
                
                // 패널 강한 발광 효과
                const panelLight = new THREE.PointLight(operator.color, 2, 8);
                panelLight.position.set(0, 0.5, 0);
                panel.add(panelLight);
                
                // 추가 외곽 발광 효과
                const outerGlow = new THREE.PointLight(operator.color, 1, 15);
                outerGlow.position.set(0, 1, 0);
                panel.add(outerGlow);
                
                // 패널 주변 네온 효과를 위한 추가 메시
                const glowGeometry = new THREE.BoxGeometry(3.2, 0.1, 3.2);
                const glowMaterial = new THREE.MeshBasicMaterial({ 
                    color: operator.color,
                    transparent: true,
                    opacity: 0.5
                });
                const glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
                glowMesh.position.y = -0.2;
                panel.add(glowMesh);
                
                scene.add(panel);
                panels.push(panel);
            }
        }
        
        // 게임 업데이트 함수
        function updateGame() {
            const currentTime = Date.now();
            
            // 도로 스크롤
            scrollRoad();
            
            // 3초마다 패널 생성
            if (currentTime - lastPanelTime > 3000) {
                createMathPanels();
                lastPanelTime = currentTime;
            }
            
            // 난이도에 따라 적 웨이브 생성 주기 조절
            const enemyWaveInterval = Math.max(2000, 5000 - (difficulty * 300));
            if (currentTime - lastEnemyWaveTime > enemyWaveInterval) {
                createEnemyWave();
                lastEnemyWaveTime = currentTime;
            }
            
            // 자동 총알 발사
            fireBullets();
            
            // 패널 이동 (도로와 함께 이동)
            panels.forEach(panel => {
                panel.position.z += roadSpeed;
                
                // 화면 끝에 도달한 패널은 제거
                if (panel.position.z > 10) {
                    scene.remove(panel);
                    panels.splice(panels.indexOf(panel), 1);
                    
                    // 모든 패널이 사라졌을 때 현재 연산 초기화
                    if (panels.length === 0) {
                        document.getElementById('currentEquation').textContent = "없음";
                    }
                }
            });
            
            // 적 이동 (도로와 함께 이동, 약간 더 빠르게)
            enemies.forEach(enemy => {
                enemy.position.z += roadSpeed * 1.2;
                
                // 화면 끝에 도달한 적은 제거
                if (enemy.position.z > 10) {
                    scene.remove(enemy);
                    enemies.splice(enemies.indexOf(enemy), 1);
                }
                
                // 적 애니메이션 (약간 상하로 움직임)
                enemy.position.y = 0.5 + Math.sin(currentTime / 300 + enemy.position.z) * 0.1;
                
                // 추가: 적 회전 애니메이션
                enemy.rotation.y += 0.02;
            });
            
            // 아군 애니메이션 (약간 위아래로 움직임)
            allies.forEach((ally, index) => {
                // 메인 캐릭터 (0번 인덱스)만 특별한 애니메이션 적용
                if (index === 0) {
                    ally.position.y = 0.5 + Math.sin(currentTime / 500) * 0.05;
                    
                    // 달리기 애니메이션 효과 (앞뒤로 약간 기울임)
                    ally.rotation.x = Math.sin(currentTime / 200) * 0.1;
                } else {
                    // 다른 아군들은 약간 다른 주기로 움직여 자연스러움 증가
                    ally.position.y = 0.5 + Math.sin((currentTime / 500) + index * 0.5) * 0.05;
                }
            });
            
            // 총알 이동
            bullets.forEach(bullet => {
                const direction = bullet.userData.direction;
                bullet.position.x += direction.x * bullet.userData.speed;
                bullet.position.z += direction.z * bullet.userData.speed;
                
                // 총알 회전 효과 추가
                bullet.rotation.x += 0.2;
                bullet.rotation.y += 0.2;
                
                // 화면 밖으로 나간 총알 제거
                if (bullet.position.z < -100) {
                    scene.remove(bullet);
                    bullets.splice(bullets.indexOf(bullet), 1);
                }
            });
            
            // 충돌 체크
            checkCollisions();
            
            // 난이도 증가
            difficulty = 1 + ((60 - gameTime) / 5);
            
            // 도로 속도 증가 (난이도에 따라)
            roadSpeed = 0.5 + (difficulty * 0.05);
        }
        
        // 충돌 체크 함수 - 시각적 효과 추가
        function checkCollisions() {
            // 총알과 적의 충돌
            bullets.forEach(bullet => {
                enemies.forEach(enemy => {
                    const distance = bullet.position.distanceTo(enemy.position);
                    if (distance < 1) {
                        // 충돌 시 폭발 효과
                        createExplosion(enemy.position.clone());
                        
                        // 충돌 발생
                        scene.remove(bullet);
                        scene.remove(enemy);
                        bullets.splice(bullets.indexOf(bullet), 1);
                        enemies.splice(enemies.indexOf(enemy), 1);
                        
                        // 점수 추가
                        score += 10;
                        document.getElementById('score').textContent = score;
                    }
                });
            });
            
            // 플레이어(메인 아군)와 패널의 충돌
            if (allies.length > 0) {
                const player = allies[0];
                
                panels.forEach(panel => {
                    const distance = Math.sqrt(
                        Math.pow(player.position.x - panel.position.x, 2) +
                        Math.pow(player.position.z - panel.position.z, 2)
                    );
                    
                    if (distance < 2) {
                        // 패널과 충돌 - 사칙연산 수행
                        if (panel.userData.result !== undefined) {
                            // 패널 획득 효과
                            createPanelEffect(player.position.clone());
                            
                            createAllies(panel.userData.result);
                            
                            // 보너스 점수
                            score += 50;
                            document.getElementById('score').textContent = score;
                            
                            // 모든 패널 제거
                            panels.forEach(p => scene.remove(p));
                            panels = [];
                            
                            // 연산 초기화
                            document.getElementById('currentEquation').textContent = "없음";
                        }
                    }
                });
                
                // 플레이어와 적의 충돌
                enemies.forEach(enemy => {
                    const distance = player.position.distanceTo(enemy.position);
                    if (distance < 1.2) {
                        // 충돌 시 데미지 효과
                        createDamageEffect(player.position.clone());
                        
                        // 충돌 발생 - 아군 감소
                        if (allies.length > 1) {
                            createAllies(allies.length - 1);
                            
                            // 해당 적 제거
                            scene.remove(enemy);
                            enemies.splice(enemies.indexOf(enemy), 1);
                        } else {
                            // 마지막 아군이 적과 충돌하면 게임 오버
                            endGame();
                        }
                    }
                });
            }
        }
        
        // 폭발 효과 생성 함수
        function createExplosion(position) {
            // 폭발 파티클 그룹
            const explosionGroup = new THREE.Group();
            explosionGroup.position.copy(position);
            
            // 폭발 빛
            const explosionLight = new THREE.PointLight(0xff5500, 3, 8);
            explosionLight.position.set(0, 0, 0);
            explosionGroup.add(explosionLight);
            
            // 파티클 생성
            const particleCount = 10;
            const particles = [];
            
            for (let i = 0; i < particleCount; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const particleMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xff5500, 
                    transparent: true, 
                    opacity: 1
                });
                
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                
                // 랜덤 방향으로 튀어나감
                const angle1 = Math.random() * Math.PI * 2;
                const angle2 = Math.random() * Math.PI * 2;
                
                const speed = 0.1 + Math.random() * 0.2;
                particle.userData.velocity = new THREE.Vector3(
                    Math.sin(angle1) * Math.cos(angle2) * speed,
                    Math.sin(angle1) * Math.sin(angle2) * speed,
                    Math.cos(angle1) * speed
                );
                
                explosionGroup.add(particle);
                particles.push(particle);
            }
            
            scene.add(explosionGroup);
            
            // 0.5초 동안 폭발 애니메이션
            let elapsed = 0;
            const duration = 500; // 밀리초
            const interval = setInterval(() => {
                elapsed += 16;
                
                // 파티클 이동 및 페이드 아웃
                particles.forEach(particle => {
                    particle.position.add(particle.userData.velocity);
                    particle.material.opacity = 1 - (elapsed / duration);
                    particle.scale.multiplyScalar(0.98);
                });
                
                // 빛 감소
                explosionLight.intensity = 3 * (1 - elapsed / duration);
                
                if (elapsed >= duration) {
                    clearInterval(interval);
                    scene.remove(explosionGroup);
                }
            }, 16);
        }
        
        // 패널 획득 효과
        function createPanelEffect(position) {
            // 빛 생성
            const light = new THREE.PointLight(0x00ffff, 3, 10);
            light.position.copy(position);
            scene.add(light);
            
            // 0.5초 동안 빛 효과
            let elapsed = 0;
            const duration = 500; // 밀리초
            const interval = setInterval(() => {
                elapsed += 16;
                
                // 빛 강도 조절
                light.intensity = 3 * (1 - elapsed / duration);
                
                if (elapsed >= duration) {
                    clearInterval(interval);
                    scene.remove(light);
                }
            }, 16);
        }
        
        // 데미지 효과
        function createDamageEffect(position) {
            // 빨간 빛 생성
            const light = new THREE.PointLight(0xff0000, 3, 10);
            light.position.copy(position);
            scene.add(light);
            
            // 화면 빨갛게 깜빡임 (CSS 효과)
            const overlay = document.createElement('div');
            overlay.style.position = 'absolute';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.width = '100%';
            overlay.style.height = '100%';
            overlay.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
            overlay.style.pointerEvents = 'none';
            overlay.style.transition = 'opacity 0.5s';
            document.body.appendChild(overlay);
            
            // 0.5초 동안 효과
            setTimeout(() => {
                overlay.style.opacity = '0';
                setTimeout(() => {
                    document.body.removeChild(overlay);
                }, 500);
            }, 100);
            
            // 빛 효과 제거
            setTimeout(() => {
                scene.remove(light);
            }, 500);
        }
        
        // 게임 타이머 함수
        function startGameTimer() {
            const timerInterval = setInterval(() => {
                if (!gameActive) {
                    clearInterval(timerInterval);
                    return;
                }
                
                gameTime--;
                document.getElementById('timer').textContent = gameTime;
                
                if (gameTime <= 0) {
                    clearInterval(timerInterval);
                    endGame();
                }
            }, 1000);
        }
        
        // 게임 종료 함수
        function endGame() {
            gameActive = false;
            document.getElementById('gameOver').style.display = 'block';
            document.getElementById('finalScore').textContent = score;
            
            // 게임 오버 효과
            const gameOverLight = new THREE.AmbientLight(0xff0000, 0.3);
            scene.add(gameOverLight);
            
            // 모든 아군 회전 애니메이션
            const rotateAllies = () => {
                allies.forEach(ally => {
                    ally.rotation.y += 0.05;
                });
                
                if (gameActive) {
                    return;
                }
                
                requestAnimationFrame(rotateAllies);
            };
            
            rotateAllies();
        }
        
        // 게임 재시작 함수
        function restartGame() {
            // 기존 오브젝트 정리
            allies.forEach(ally => scene.remove(ally));
            enemies.forEach(enemy => scene.remove(enemy));
            bullets.forEach(bullet => scene.remove(bullet));
            panels.forEach(panel => scene.remove(panel));
            
            // 씬의 모든 빛 제거 (게임 오버 효과 제거)
            scene.children.forEach(child => {
                if (child instanceof THREE.Light && !(child instanceof THREE.DirectionalLight) && !(child instanceof THREE.AmbientLight && child.intensity === 0.6)) {
                    scene.remove(child);
                }
            });
            
            allies = [];
            enemies = [];
            bullets = [];
            panels = [];
            
            // 변수 초기화
            gameTime = 60;
            score = 0;
            difficulty = 1;
            gameActive = true;
            lastPanelTime = 0;
            lastEnemyWaveTime = 0;
            playerLane = 1; // 중앙 레인으로 초기화
            isMoving = false;
            roadSpeed = 0.5;
            gameDistance = 0;
            
            // UI 초기화
            document.getElementById('timer').textContent = gameTime;
            document.getElementById('score').textContent = score;
            document.getElementById('currentEquation').textContent = "없음";
            document.getElementById('gameOver').style.display = 'none';
            
            // 기본 조명 재설정
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(0, 20, 10);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // 첫 아군 생성
            createAllies(1);
            
            // 타이머 재시작
            startGameTimer();
        }
        
        // 애니메이션 루프
        function animate() {
            requestAnimationFrame(animate);
            
            if (gameActive) {
                updateGame();
            }
            
            renderer.render(scene, camera);
        }
        
        // 화면 크기 조정 이벤트
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // 게임 시작
        init();
    </script>
</body>
</html>
</antArtifact><antArtifact identifier="enhanced-game" type="application/vnd.ant.code" language="html" title="Enhanced Math Runner 3D Game">
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>러너 3D 슈팅 게임</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: Arial, sans-serif; 
            touch-action: none;
            background-color: #000;
        }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: #00ffff; /* 네온 청록색 */
            padding: 5px;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff, 0 0 30px #00ffff;
            z-index: 10;
            letter-spacing: 1px;
        }
        #equationInfo {
            position: absolute;
            top: 50px;
            width: 100%;
            text-align: center;
            color: #ff00ff; /* 네온 핑크 */
            padding: 5px;
            font-size: 22px;
            font-weight: bold;
            text-shadow: 0 0 10px #ff00ff, 0 0 20px #ff00ff;
            z-index: 10;
            letter-spacing: 1px;
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff0055;
            background-color: rgba(20, 20, 40, 0.9);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            display: none;
            z-index: 20;
            box-shadow: 0 0 20px #ff0055, 0 0 40px #ff0055;
            border: 2px solid #ff0055;
        }
        #gameOver h2 {
            font-size: 40px;
            text-shadow: 0 0 10px #ff0055, 0 0 20px #ff0055;
            margin-bottom: 20px;
        }
        #gameOver p {
            font-size: 24px;
            margin-bottom: 30px;
            color: #ffffff;
            text-shadow: 0 0 5px #ffffff;
        }
        #restartBtn {
            padding: 15px 40px;
            background-color: #ff0055;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 22px;
            margin-top: 20px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            box-shadow: 0 0 10px #ff0055, 0 0 20px #ff0055;
            transition: all 0.3s ease;
        }
        #restartBtn:hover {
            background-color: #ff3377;
            transform: scale(1.05);
            box-shadow: 0 0 15px #ff0055, 0 0 30px #ff0055;
        }
        #controls {
            position: absolute;
            bottom: 40px;
            width: 100%;
            display: flex;
            justify-content: center;
            z-index: 10;
        }
        .controlBtn {
            width: 100px;
            height: 100px;
            background-color: rgba(0, 200, 255, 0.2);
            border: 3px solid rgba(0, 200, 255, 0.8);
            border-radius: 50px;
            margin: 0 30px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #00FFFF;
            font-weight: bold;
            font-size: 30px;
            user-select: none;
            box-shadow: 0 0 15px #00FFFF;
            text-shadow: 0 0 10px #00FFFF;
        }
    </style>
</head>
<body>
    <div id="info">아군: <span id="allyCount">1</span> | 시간: <span id="timer">60</span>초 | 점수: <span id="score">0</span></div>
    <div id="equationInfo">현재 패널: <span id="currentEquation">없음</span></div>
    <div id="gameOver">
        <h2>게임 종료!</h2>
        <p>최종 점수: <span id="finalScore">0</span></p>
        <button id="restartBtn">다시 시작</button>
    </div>
    <div id="controls">
        <div id="leftBtn" class="controlBtn">←</div>
        <div id="rightBtn" class="controlBtn">→</div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // 게임 변수
        let scene, camera, renderer, allies = [], enemies = [], bullets = [], panels = [];
        let gameTime = 60; // 1분
        let score = 0;
        let difficulty = 1;
        let gameActive = true;
        let lastPanelTime = 0;
        let lastEnemyWaveTime = 0;
        let lastFireTime = 0;
        let playerLane = 1; // 0: 왼쪽, 1: 중앙, 2: 오른쪽
        let isMoving = false;
        let roadSpeed = 0.5;
        let roadSegments = [];
        let gameDistance = 0;
        let activeEquation = "";
        
        // 레인 위치 정의
        const lanes = [-5, 0, 5];
        
        // 수학 연산자 (각각 강한 네온 색상으로 변경)
        const operators = [
            { symbol: "+", fn: (a, b) => a + b, color: 0x00FFFF, glow: 0x00FFFF }, // 네온 청록색
            { symbol: "-", fn: (a, b) => Math.max(1, a - b), color: 0xFF1493, glow: 0xFF1493 }, // 네온 핑크
            { symbol: "×", fn: (a, b) => a * b, color: 0x39FF14, glow: 0x39FF14 }, // 네온 그린
            { symbol: "÷", fn: (a, b) => Math.round(a / b) || 1, color: 0xFFD700, glow: 0xFFD700 } // 네온 골드
        ];
        
        // 게임 초기화
        function init() {
            // 씬 설정
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e); // 어두운 남색 배경
            
            // 안개 추가 (원근감) - 더 짙게 설정
            scene.fog = new THREE.Fog(0x1a1a2e, 30, 80);
            
            // 카메라 설정
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 8, 12); // 카메라 높이와 거리 조정
            camera.lookAt(0, 0, -20);
            
            // 렌더러 설정
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; // 그림자 활성화
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);
            
            // 조명 설정
            const ambientLight = new THREE.AmbientLight(0x0000ff, 0.2); // 어두운 파란색 배경 조명
            scene.add(ambientLight);
            
            // 메인 조명 (더 강한 빛)
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
            directionalLight.position.set(0, 20, 10);
            directionalLight.castShadow = true; // 그림자 생성
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -20;
            directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20;
            directionalLight.shadow.camera.bottom = -20;
            scene.add(directionalLight);
            
            // 도로 강조를 위한 추가 조명
            const roadLight1 = new THREE.PointLight(0x00ffff, 1, 30); // 청록색 조명
            roadLight1.position.set(0, 10, -30);
            scene.add(roadLight1);
            
            const roadLight2 = new THREE.PointLight(0xff00ff, 1, 30); // 자홍색 조명
            roadLight2.position.set(0, 10, -60);
            scene.add(roadLight2);
            
            // 플레이어 주변에 항상 따라다니는 조명
            const playerLight = new THREE.PointLight(0xffffff, 1, 15);
            playerLight.position.set(0, 5, 5);
            scene.add(playerLight);
            
            // playerLight를 플레이어와 함께 이동시키기 위해 저장
            window.playerLight = playerLight;
            
            // 도로 생성
            createRoad();
            
            // 첫 아군 생성
            createAllies(1);
            
            // 이벤트 리스너
            window.addEventListener('resize', onWindowResize);
            document.getElementById('restartBtn').addEventListener('click', restartGame);
            
            // 모바일 컨트롤 초기화
            initControls();
            
            // 게임 타이머 시작
            startGameTimer();
            
            // 게임 루프 시작
            animate();
        }
        
        // 도로 생성 함수
        function createRoad() {
            // 도로 텍스처 (하늘색 그라데이션 패턴으로 변경)
            const roadWidth = 15;
            const roadLength = 1000;
            const segmentLength = 20;
            const segments = roadLength / segmentLength;
            
            // 도로 기본 재질 (네온 효과가 있는 어두운 색상)
            const roadMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x0f3460,
                roughness: 0.5,
                metalness: 0.7,
                emissive: 0x0f3460,
                emissiveIntensity: 0.2
            });
            
            // 도로 경계선 재질 (밝은 네온 색상)
            const lineMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xE94560, 
                emissive: 0xE94560,
                emissiveIntensity: 0.7
            });
            
            // 도로 가장자리 재질 (네온 푸른색)
            const sideMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x16213E,
                emissive: 0x0F52BA,
                emissiveIntensity: 0.3
            });
            
            // 도로 그라데이션을 위한 재질 배열 (네온 효과가 있는 패턴)
            const patternMaterials = [
                new THREE.MeshStandardMaterial({ 
                    color: 0x0f3460, 
                    emissive: 0x0f3460,
                    emissiveIntensity: 0.2
                }),
                new THREE.MeshStandardMaterial({ 
                    color: 0x16213E, 
                    emissive: 0x16213E,
                    emissiveIntensity: 0.2
                })
            ];
            
            // 여러 세그먼트로 도로 생성
            for (let i = 0; i < segments; i++) {
                // 도로 세그먼트 (패턴 적용)
                const roadGeometry = new THREE.PlaneGeometry(roadWidth, segmentLength);
                const road = new THREE.Mesh(roadGeometry, patternMaterials[i % 2]); // 번갈아가며 패턴 적용
                road.rotation.x = -Math.PI / 2;
                road.position.z = -i * segmentLength - segmentLength / 2;
                road.position.y = -0.1;
                road.receiveShadow = true; // 그림자 받기
                scene.add(road);
                roadSegments.push(road);
                
                // 도로 레인 구분선
                for (let j = -1; j <= 1; j += 2) {
                    const lineGeometry = new THREE.PlaneGeometry(0.3, segmentLength);
                    const line = new THREE.Mesh(lineGeometry, lineMaterial);
                    line.rotation.x = -Math.PI / 2;
                    line.position.set(j * roadWidth/6, -0.05, -i * segmentLength - segmentLength / 2);
                    line.receiveShadow = true;
                    scene.add(line);
                    roadSegments.push(line);
                }
                
                // 도로 가장자리
                for (let j = -1; j <= 1; j += 2) {
                    const sideGeometry = new THREE.BoxGeometry(2, 1, segmentLength);
                    const side = new THREE.Mesh(sideGeometry, sideMaterial);
                    side.position.set(j * (roadWidth/2 + 1), 0.4, -i * segmentLength - segmentLength / 2);
                    side.castShadow = true;
                    side.receiveShadow = true;
                    scene.add(side);
                    roadSegments.push(side);
                    
                    // 가드레일 기둥 추가
                    if (i % 2 === 0) {
                        const postGeometry = new THREE.BoxGeometry(0.5, 2, 0.5);
                        const postMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
                        const post = new THREE.Mesh(postGeometry, postMaterial);
                        post.position.set(j * (roadWidth/2 + 1), 1.5, -i * segmentLength - segmentLength / 2);
                        post.castShadow = true;
                        post.receiveShadow = true;
                        scene.add(post);
                        roadSegments.push(post);
                    }
                }
            }
        }
        
        // 도로 스크롤 함수
        function scrollRoad() {
            const resetPos = -1000; // 도로 총 길이
            
            roadSegments.forEach(segment => {
                segment.position.z += roadSpeed;
                
                // 도로 세그먼트가 카메라 뒤로 지나가면 다시 앞으로 재배치
                if (segment.position.z > 20) {
                    segment.position.z = resetPos + (segment.position.z - 20);
                }
            });
            
            // 거리 증가
            gameDistance += roadSpeed;
        }
        
        // 컨트롤 초기화
        function initControls() {
            const leftBtn = document.getElementById('leftBtn');
            const rightBtn = document.getElementById('rightBtn');
            
            // 터치 이벤트
            leftBtn.addEventListener('touchstart', moveLeft);
            rightBtn.addEventListener('touchstart', moveRight);
            
            // 마우스 이벤트 (데스크톱용)
            leftBtn.addEventListener('mousedown', moveLeft);
            rightBtn.addEventListener('mousedown', moveRight);
            
            // 키보드 이벤트
            window.addEventListener('keydown', function(e) {
                if (!gameActive || isMoving) return;
                
                if (e.key === 'ArrowLeft') {
                    moveLeft();
                } else if (e.key === 'ArrowRight') {
                    moveRight();
                }
            });
            
            function moveLeft() {
                if (!gameActive || isMoving || playerLane === 0) return;
                
                isMoving = true;
                playerLane--;
                moveAlliesTo(lanes[playerLane]);
            }
            
            function moveRight() {
                if (!gameActive || isMoving || playerLane === 2) return;
                
                isMoving = true;
                playerLane++;
                moveAlliesTo(lanes[playerLane]);
            }
        }
        
        // 아군 이동 함수
        function moveAlliesTo(targetX) {
            // 0.3초에 걸쳐 부드럽게 이동
            const frames = 15; // 60fps 기준 0.25초
            let currentFrame = 0;
            
            // 메인 아군 현재 위치
            const startX = allies[0].position.x;
            const moveAmount = (targetX - startX) / frames;
            
            const moveInterval = setInterval(() => {
                if (currentFrame >= frames) {
                    clearInterval(moveInterval);
                    isMoving = false;
                    return;
                }
                
                // 모든 아군 이동
                allies.forEach((ally, index) => {
                    if (index === 0) {
                        // 메인 아군
                        ally.position.x += moveAmount;
                    } else {
                        // 나머지 아군들은 메인 아군을 따라감
                        updateAllyFormation();
                    }
                });
                
                currentFrame++;
            }, 1000/60); // 60fps
        }
        
        // 아군 진형 업데이트
        function updateAllyFormation() {
            if (allies.length <= 1) return;
            
            const mainAlly = allies[0];
            const allyCount = allies.length;
            
            // 진영 크기 계산 - 아군이 많을수록 더 넓게 퍼짐
            const formationWidth = Math.min(3, 0.5 + (allyCount * 0.1));
            const formationDepth = Math.min(4, 1 + (allyCount * 0.15));
            
            for (let i = 1; i < allyCount; i++) {
                // 균등하게 분포된 위치 계산
                let row = Math.floor((i-1) / 3);
                let col = (i-1) % 3;
                
                // 중앙 정렬을 위한 오프셋
                let colOffset = col - 1; // -1, 0, 1
                let rowOffset = -row; // 항상 플레이어 뒤에 배치
                
                allies[i].position.x = mainAlly.position.x + (colOffset * formationWidth);
                allies[i].position.z = mainAlly.position.z + (rowOffset * formationDepth);
            }
        }
        
        // 아군 생성 함수 - 캐릭터 디자인 개선
        function createAllies(count) {
            // 기존 아군 제거
            allies.forEach(ally => scene.remove(ally));
            allies = [];
            
            // 최댓값 제한 (너무 많으면 게임이 쉬워짐)
            count = Math.min(count, 30);
            
            // 새 아군 생성 - 귀여운 오렌지색 캐릭터로 변경
            for (let i = 0; i < count; i++) {
                // 캐릭터 그룹
                const character = new THREE.Group();
                
                // 몸체 (구)
                const bodyGeometry = new THREE.SphereGeometry(0.5, 16, 16);
                const bodyMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFF9900, // 오렌지색
                    emissive: 0xAA5500,
                    emissiveIntensity: 0.2,
                    roughness: 0.7
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.castShadow = true;
                body.receiveShadow = true;
                character.add(body);
                
                // 캐릭터에 눈 추가
                const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
                
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(0.2, 0.2, 0.4);
                character.add(leftEye);
                
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(-0.2, 0.2, 0.4);
                character.add(rightEye);
                
                // 눈동자
                const pupilGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                const pupilMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
                
                const leftPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                leftPupil.position.set(0.2, 0.2, 0.45);
                character.add(leftPupil);
                
                const rightPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                rightPupil.position.set(-0.2, 0.2, 0.45);
                character.add(rightPupil);
                
                // 팔과 다리 추가 (메인 캐릭터만)
                if (i === 0) {
                    // 팔
                    const armGeometry = new THREE.SphereGeometry(0.15, 8, 8);
                    
                    const leftArm = new THREE.Mesh(armGeometry, bodyMaterial);
                    leftArm.position.set(0.6, 0, 0);
                    leftArm.castShadow = true;
                    character.add(leftArm);
                    
                    const rightArm = new THREE.Mesh(armGeometry, bodyMaterial);
                    rightArm.position.set(-0.6, 0, 0);
                    rightArm.castShadow = true;
                    character.add(rightArm);
                    
                    // 다리
                    const legGeometry = new THREE.CylinderGeometry(0.15, 0.1, 0.5, 8);
                    
                    const leftLeg = new THREE.Mesh(legGeometry, bodyMaterial);
                    leftLeg.position.set(0.2, -0.5, 0);
                    leftLeg.castShadow = true;
                    character.add(leftLeg);
                    
                    const rightLeg = new THREE.Mesh(legGeometry, bodyMaterial);
                    rightLeg.position.set(-0.2, -0.5, 0);
                    rightLeg.castShadow = true;
                    character.add(rightLeg);
                }
                
                if (i === 0) {
                    // 메인 아군 (플레이어)
                    character.position.set(lanes[playerLane], 0.5, 0);
                } else {
                    // 추가 아군들은 초기 위치만 설정 (updateAllyFormation에서 정확히 배치됨)
                    character.position.set(lanes[playerLane], 0.5, -i);
                    // 작게 만들기
                    character.scale.set(0.8, 0.8, 0.8);
                }
                
                scene.add(character);
                allies.push(character);
            }
            
            // 진형 업데이트
            updateAllyFormation();
            
            // UI 업데이트
            document.getElementById('allyCount').textContent = allies.length;
        }
        
        // 적 생성 함수 - 웨이브 형태로 생성
        function createEnemyWave() {
            const waveType = Math.floor(Math.random() * 4);
            
            switch (waveType) {
                case 0: // 일렬 웨이브
                    const randomLane = Math.floor(Math.random() * 3);
                    for (let i = 0; i < 5 + Math.floor(difficulty); i++) {
                        createEnemy(randomLane, -80 - (i * 4));
                    }
                    break;
                    
                case 1: // V 형태 웨이브
                    for (let i = 0; i < 7; i++) {
                        const laneOffset = (i <= 3) ? i : 6 - i; // 0,1,2,3,2,1,0
                        createEnemy(laneOffset, -80 - (i * 3));
                    }
                    break;
                    
                case 2: // 모든 레인 웨이브
                    for (let i = 0; i < 3; i++) {
                        for (let j = 0; j < 3; j++) {
                            createEnemy(j, -80 - (i * 5));
                        }
                    }
                    break;
                    
                case 3: // 랜덤 웨이브
                    const enemyCount = 5 + Math.floor(difficulty * 2);
                    for (let i = 0; i < enemyCount; i++) {
                        const randLane = Math.floor(Math.random() * 3);
                        const randDist = -80 - (Math.random() * 20);
                        createEnemy(randLane, randDist);
                    }
                    break;
            }
            
            function createEnemy(lane, zPos) {
                // 적 그룹
                const enemy = new THREE.Group();
                
                // 적 몸체 (더 큰 크기와 강한 네온 빨간색)
                const enemyGeometry = new THREE.SphereGeometry(0.6, 16, 16);
                const enemyMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xff0000,
                    emissive: 0xff0000,
                    emissiveIntensity: 0.8,
                    roughness: 0.3,
                    metalness: 0.7
                });
                const body = new THREE.Mesh(enemyGeometry, enemyMaterial);
                body.castShadow = true;
                body.receiveShadow = true;
                enemy.add(body);
                
                // 적 눈 (흰색)
                const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
                
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(0.2, 0.2, 0.4);
                enemy.add(leftEye);
                
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(-0.2, 0.2, 0.4);
                enemy.add(rightEye);
                
                // 적 눈동자 (검은색)
                const pupilGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                const pupilMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
                
                const leftPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                leftPupil.position.set(0.2, 0.2, 0.45);
                enemy.add(leftPupil);
                
                const rightPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                rightPupil.position.set(-0.2, 0.2, 0.45);
                enemy.add(rightPupil);
                
                enemy.position.set(lanes[lane], 0.5, zPos);
                scene.add(enemy);
                enemies.push(enemy);
            }
        }
        
        // 총알 발사 함수
        function fireBullets() {
            const currentTime = Date.now();
            
            // 자동 발사 간격 (아군 수에 따라 감소)
            const fireInterval = Math.max(100, 500 - (allies.length * 10));
            
            if (currentTime - lastFireTime < fireInterval) return;
            
            lastFireTime = currentTime;
            
            // 아군 수에 비례해서 총알 발사 (아군당 0.5발의 총알)
            const bulletsToFire = Math.max(1, Math.ceil(allies.length * 0.5));
            
            for (let i = 0; i < bulletsToFire; i++) {
                const bulletGeometry = new THREE.SphereGeometry(0.3, 8, 8);
                const bulletMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFFFF00, 
                    emissive: 0xFFFF00,
                    emissiveIntensity: 1.0,
                    metalness: 1.0,
                    roughness: 0.0
                });
                const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
                
                // 총알 발사 방향 다각화
                let angleOffset = 0;
                if (bulletsToFire > 1) {
                    // 부채꼴 형태로 퍼지게 발사
                    const spreadFactor = Math.min(0.3, bulletsToFire * 0.02);  // 최대 0.3 라디안 (약 17도)
                    angleOffset = spreadFactor * ((i / (bulletsToFire - 1)) * 2 - 1);
                }
                
                // 총알 위치는 무작위 아군 위치에서 시작
                const shooterIndex = Math.floor(Math.random() * allies.length);
                bullet.position.copy(allies[shooterIndex].position);
                bullet.position.z -= 1; // 약간 앞에서 발사
                
                // 총알 방향 설정
                bullet.userData.direction = new THREE.Vector3(angleOffset, 0, -1).normalize();
                bullet.userData.speed = 1.5;
                
                scene.add(bullet);
                bullets.push(bullet);
                
                // 총알 발사 이펙트 (강한 빛)
                const bulletLight = new THREE.PointLight(0xffff00, 5, 8);
                bulletLight.position.copy(bullet.position);
                scene.add(bulletLight);
                
                // 추가 발광 효과 (더 넓은 범위)
                const bulletGlow = new THREE.PointLight(0xffff00, 2, 15);
                bulletGlow.position.copy(bullet.position);
                scene.add(bulletGlow);
                
                // 0.1초 후 이펙트 제거
                setTimeout(() => {
                    scene.remove(bulletLight);
                }, 100);
            }
        }
        
        // 사칙연산 패널 생성 함수
        function createMathPanels() {
            // 기존 패널 제거
            panels.forEach(panel => scene.remove(panel));
            panels = [];
            
            // 랜덤 연산자 선택
            const operator = operators[Math.floor(Math.random() * operators.length)];
            
            // 피연산자 선택 (난이도에 따라 증가)
            const operand = Math.floor(Math.random() * Math.min(5, difficulty)) + 1;
            
            // 현재 아군 수와 연산 결과 계산
            const currentAllies = allies.length;
            const result = operator.fn(currentAllies, operand);
            
            // 연산 표시 업데이트
            activeEquation = `${currentAllies} ${operator.symbol} ${operand} = ${result}`;
            document.getElementById('currentEquation').textContent = activeEquation;
            
            // 도로 세 레인에 패널 생성
            for (let i = 0; i < 3; i++) {
                createMathPanel(lanes[i], -60 - Math.random() * 10, operand, operator);
            }
            
            function createMathPanel(x, z, operand, operator) {
                // 패널 그룹
                const panel = new THREE.Group();
                
                // 패널 플랫폼
                const panelGeometry = new THREE.BoxGeometry(3, 0.3, 3);
                
                // 연산자에 맞는 색상 적용 (강한 네온 효과)
                const panelMaterial = new THREE.MeshStandardMaterial({ 
                    color: operator.color,
                    emissive: operator.glow,
                    emissiveIntensity: 0.8,
                    transparent: true,
                    opacity: 0.9
                });
                
                const panelMesh = new THREE.Mesh(panelGeometry, panelMaterial);
                panelMesh.castShadow = true;
                panelMesh.receiveShadow = true;
                panel.add(panelMesh);
                
                // 패널에 숫자 표시를 위한 텍스트 (Three.js에서는 실제 텍스트 렌더링이 어려워 대체 표현)
                const operatorSymbol = operator.symbol;
                const operatorTextGeometry = new THREE.BoxGeometry(1, 0.1, 1);
                const operatorTextMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFFFFFF,
                    emissive: 0xFFFFFF,
                    emissiveIntensity: 0.5
                });
                
                const operatorText = new THREE.Mesh(operatorTextGeometry, operatorTextMaterial);
                operatorText.position.y = 0.2;
                panel.add(operatorText);
                
                // 숫자 표시 (간소화된 형태)
                const numberGeometry = new THREE.BoxGeometry(0.5, 0.1, 0.5);
                const numberMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
                const numberMesh = new THREE.Mesh(numberGeometry, numberMaterial);
                numberMesh.position.set(0, 0.2, 0.5);
                panel.add(numberMesh);
                
                // 패널 위치 설정
                panel.position.set(x, 0, z);
                
                // 패널에 연산 데이터 추가
                panel.userData = {
                    operator: operatorSymbol,
                    operand: operand,
                    result: result
                };
                
                // 패널 강한 발광 효과
                const panelLight = new THREE.PointLight(operator.color, 2, 8);
                panelLight.position.set(0, 0.5, 0);
                panel.add(panelLight);
                
                // 추가 외곽 발광 효과
                const outerGlow = new THREE.PointLight(operator.color, 1, 15);
                outerGlow.position.set(0, 1, 0);
                panel.add(outerGlow);
                
                // 패널 주변 네온 효과를 위한 추가 메시
                const glowGeometry = new THREE.BoxGeometry(3.2, 0.1, 3.2);
                const glowMaterial = new THREE.MeshBasicMaterial({ 
                    color: operator.color,
                    transparent: true,
                    opacity: 0.5
                });
                const glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
                glowMesh.position.y = -0.2;
                panel.add(glowMesh);
                
                scene.add(panel);
                panels.push(panel);
            }
        }
        
        // 게임 업데이트 함수
        function updateGame() {
            const currentTime = Date.now();
            
            // 도로 스크롤
            scrollRoad();
            
            // 3초마다 패널 생성
            if (currentTime - lastPanelTime > 3000) {
                createMathPanels();
                lastPanelTime = currentTime;
            }
            
            // 난이도에 따라 적 웨이브 생성 주기 조절
            const enemyWaveInterval = Math.max(2000, 5000 - (difficulty * 300));
            if (currentTime - lastEnemyWaveTime > enemyWaveInterval) {
                createEnemyWave();
                lastEnemyWaveTime = currentTime;
            }
            
            // 자동 총알 발사
            fireBullets();
            
            // 패널 이동 (도로와 함께 이동)
            panels.forEach(panel => {
                panel.position.z += roadSpeed;
                
                // 화면 끝에 도달한 패널은 제거
                if (panel.position.z > 10) {
                    scene.remove(panel);
                    panels.splice(panels.indexOf(panel), 1);
                    
                    // 모든 패널이 사라졌을 때 현재 연산 초기화
                    if (panels.length === 0) {
                        document.getElementById('currentEquation').textContent = "없음";
                    }
                }
            });
            
            // 적 이동 (도로와 함께 이동, 약간 더 빠르게)
            enemies.forEach(enemy => {
                enemy.position.z += roadSpeed * 1.2;
                
                // 화면 끝에 도달한 적은 제거
                if (enemy.position.z > 10) {
                    scene.remove(enemy);
                    enemies.splice(enemies.indexOf(enemy), 1);
                }
                
                // 적 애니메이션 (약간 상하로 움직임)
                enemy.position.y = 0.5 + Math.sin(currentTime / 300 + enemy.position.z) * 0.1;
                
                // 추가: 적 회전 애니메이션
                enemy.rotation.y += 0.02;
            });
            
            // 아군 애니메이션 (약간 위아래로 움직임)
            allies.forEach((ally, index) => {
                // 메인 캐릭터 (0번 인덱스)만 특별한 애니메이션 적용
                if (index === 0) {
                    ally.position.y = 0.5 + Math.sin(currentTime / 500) * 0.05;
                    
                    // 달리기 애니메이션 효과 (앞뒤로 약간 기울임)
                    ally.rotation.x = Math.sin(currentTime / 200) * 0.1;
                } else {
                    // 다른 아군들은 약간 다른 주기로 움직여 자연스러움 증가
                    ally.position.y = 0.5 + Math.sin((currentTime / 500) + index * 0.5) * 0.05;
                }
            });
            
            // 총알 이동
            bullets.forEach(bullet => {
                const direction = bullet.userData.direction;
                bullet.position.x += direction.x * bullet.userData.speed;
                bullet.position.z += direction.z * bullet.userData.speed;
                
                // 총알 회전 효과 추가
                bullet.rotation.x += 0.2;
                bullet.rotation.y += 0.2;
                
                // 화면 밖으로 나간 총알 제거
                if (bullet.position.z < -100) {
                    scene.remove(bullet);
                    bullets.splice(bullets.indexOf(bullet), 1);
                }
            });
            
            // 충돌 체크
            checkCollisions();
            
            // 난이도 증가
            difficulty = 1 + ((60 - gameTime) / 5);
            
            // 도로 속도 증가 (난이도에 따라)
            roadSpeed = 0.5 + (difficulty * 0.05);
        }
        
        // 충돌 체크 함수 - 시각적 효과 추가
        function checkCollisions() {
            // 총알과 적의 충돌
            bullets.forEach(bullet => {
                enemies.forEach(enemy => {
                    const distance = bullet.position.distanceTo(enemy.position);
                    if (distance < 1) {
                        // 충돌 시 폭발 효과
                        createExplosion(enemy.position.clone());
                        
                        // 충돌 발생
                        scene.remove(bullet);
                        scene.remove(enemy);
                        bullets.splice(bullets.indexOf(bullet), 1);
                        enemies.splice(enemies.indexOf(enemy), 1);
                        
                        // 점수 추가
                        score += 10;
                        document.getElementById('score').textContent = score;
                    }
                });
            });
            
            // 플레이어(메인 아군)와 패널의 충돌
            if (allies.length > 0) {
                const player = allies[0];
                
                panels.forEach(panel => {
                    const distance = Math.sqrt(
                        Math.pow(player.position.x - panel.position.x, 2) +
                        Math.pow(player.position.z - panel.position.z, 2)
                    );
                    
                    if (distance < 2) {
                        // 패널과 충돌 - 사칙연산 수행
                        if (panel.userData.result !== undefined) {
                            // 패널 획득 효과
                            createPanelEffect(player.position.clone());
                            
                            createAllies(panel.userData.result);
                            
                            // 보너스 점수
                            score += 50;
                            document.getElementById('score').textContent = score;
                            
                            // 모든 패널 제거
                            panels.forEach(p => scene.remove(p));
                            panels = [];
                            
                            // 연산 초기화
                            document.getElementById('currentEquation').textContent = "없음";
                        }
                    }
                });
                
                // 플레이어와 적의 충돌
                enemies.forEach(enemy => {
                    const distance = player.position.distanceTo(enemy.position);
                    if (distance < 1.2) {
                        // 충돌 시 데미지 효과
                        createDamageEffect(player.position.clone());
                        
                        // 충돌 발생 - 아군 감소
                        if (allies.length > 1) {
                            createAllies(allies.length - 1);
                            
                            // 해당 적 제거
                            scene.remove(enemy);
                            enemies.splice(enemies.indexOf(enemy), 1);
                        } else {
                            // 마지막 아군이 적과 충돌하면 게임 오버
                            endGame();
                        }
                    }
                });
            }
        }
        
        // 폭발 효과 생성 함수
        function createExplosion(position) {
            // 폭발 파티클 그룹
            const explosionGroup = new THREE.Group();
            explosionGroup.position.copy(position);
            
            // 폭발 빛
            const explosionLight = new THREE.PointLight(0xff5500, 3, 8);
            explosionLight.position.set(0, 0, 0);
            explosionGroup.add(explosionLight);
            
            // 파티클 생성
            const particleCount = 10;
            const particles = [];
            
            for (let i = 0; i < particleCount; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const particleMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xff5500, 
                    transparent: true, 
                    opacity: 1
                });
                
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                
                // 랜덤 방향으로 튀어나감
                const angle1 = Math.random() * Math.PI * 2;
                const angle2 = Math.random() * Math.PI * 2;
                
                const speed = 0.1 + Math.random() * 0.2;
                particle.userData.velocity = new THREE.Vector3(
                    Math.sin(angle1) * Math.cos(angle2) * speed,
                    Math.sin(angle1) * Math.sin(angle2) * speed,
                    Math.cos(angle1) * speed
                );
                
                explosionGroup.add(particle);
                particles.push(particle);
            }
            
            scene.add(explosionGroup);
            
            // 0.5초 동안 폭발 애니메이션
            let elapsed = 0;
            const duration = 500; // 밀리초
            const interval = setInterval(() => {
                elapsed += 16;
                
                // 파티클 이동 및 페이드 아웃
                particles.forEach(particle => {
                    particle.position.add(particle.userData.velocity);
                    particle.material.opacity = 1 - (elapsed / duration);
                    particle.scale.multiplyScalar(0.98);
                });
                
                // 빛 감소
                explosionLight.intensity = 3 * (1 - elapsed / duration);
                
                if (elapsed >= duration) {
                    clearInterval(interval);
                    scene.remove(explosionGroup);
                }
            }, 16);
        }
        
        // 패널 획득 효과
        function createPanelEffect(position) {
            // 빛 생성
            const light = new THREE.PointLight(0x00ffff, 3, 10);
            light.position.copy(position);
            scene.add(light);
            
            // 0.5초 동안 빛 효과
            let elapsed = 0;
            const duration = 500; // 밀리초
            const interval = setInterval(() => {
                elapsed += 16;
                
                // 빛 강도 조절
                light.intensity = 3 * (1 - elapsed / duration);
                
                if (elapsed >= duration) {
                    clearInterval(interval);
                    scene.remove(light);
                }
            }, 16);
        }
        
        // 데미지 효과
        function createDamageEffect(position) {
            // 빨간 빛 생성
            const light = new THREE.PointLight(0xff0000, 3, 10);
            light.position.copy(position);
            scene.add(light);
            
            // 화면 빨갛게 깜빡임 (CSS 효과)
            const overlay = document.createElement('div');
            overlay.style.position = 'absolute';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.width = '100%';
            overlay.style.height = '100%';
            overlay.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
            overlay.style.pointerEvents = 'none';
            overlay.style.transition = 'opacity 0.5s';
            document.body.appendChild(overlay);
            
            // 0.5초 동안 효과
            setTimeout(() => {
                overlay.style.opacity = '0';
                setTimeout(() => {
                    document.body.removeChild(overlay);
                }, 500);
            }, 100);
            
            // 빛 효과 제거
            setTimeout(() => {
                scene.remove(light);
            }, 500);
        }
        
        // 게임 타이머 함수
        function startGameTimer() {
            const timerInterval = setInterval(() => {
                if (!gameActive) {
                    clearInterval(timerInterval);
                    return;
                }
                
                gameTime--;
                document.getElementById('timer').textContent = gameTime;
                
                if (gameTime <= 0) {
                    clearInterval(timerInterval);
                    endGame();
                }
            }, 1000);
        }
        
        // 게임 종료 함수
        function endGame() {
            gameActive = false;
            document.getElementById('gameOver').style.display = 'block';
            document.getElementById('finalScore').textContent = score;
            
            // 게임 오버 효과
            const gameOverLight = new THREE.AmbientLight(0xff0000, 0.3);
            scene.add(gameOverLight);
            
            // 모든 아군 회전 애니메이션
            const rotateAllies = () => {
                allies.forEach(ally => {
                    ally.rotation.y += 0.05;
                });
                
                if (gameActive) {
                    return;
                }
                
                requestAnimationFrame(rotateAllies);
            };
            
            rotateAllies();
        }
        
        // 게임 재시작 함수
        function restartGame() {
            // 기존 오브젝트 정리
            allies.forEach(ally => scene.remove(ally));
            enemies.forEach(enemy => scene.remove(enemy));
            bullets.forEach(bullet => scene.remove(bullet));
            panels.forEach(panel => scene.remove(panel));
            
            // 씬의 모든 빛 제거 (게임 오버 효과 제거)
            scene.children.forEach(child => {
                if (child instanceof THREE.Light && !(child instanceof THREE.DirectionalLight) && !(child instanceof THREE.AmbientLight && child.intensity === 0.6)) {
                    scene.remove(child);
                }
            });
            
            allies = [];
            enemies = [];
            bullets = [];
            panels = [];
            
            // 변수 초기화
            gameTime = 60;
            score = 0;
            difficulty = 1;
            gameActive = true;
            lastPanelTime = 0;
            lastEnemyWaveTime = 0;
            playerLane = 1; // 중앙 레인으로 초기화
            isMoving = false;
            roadSpeed = 0.5;
            gameDistance = 0;
            
            // UI 초기화
            document.getElementById('timer').textContent = gameTime;
            document.getElementById('score').textContent = score;
            document.getElementById('currentEquation').textContent = "없음";
            document.getElementById('gameOver').style.display = 'none';
            
            // 기본 조명 재설정
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(0, 20, 10);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // 첫 아군 생성
            createAllies(1);
            
            // 타이머 재시작
            startGameTimer();
        }
        
        // 애니메이션 루프
        function animate() {
            requestAnimationFrame(animate);
            
            if (gameActive) {
                updateGame();
            }
            
            renderer.render(scene, camera);
        }
        
        // 화면 크기 조정 이벤트
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // 게임 시작
        init();
    </script>
</body>
</html>
</antArtifact><antArtifact identifier="enhanced-game" type="application/vnd.ant.code" language="html" title="Enhanced Math Runner 3D Game">
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>러너 3D 슈팅 게임</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: Arial, sans-serif; 
            touch-action: none;
            background-color: #000;
        }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: #00ffff; /* 네온 청록색 */
            padding: 5px;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff, 0 0 30px #00ffff;
            z-index: 10;
            letter-spacing: 1px;
        }
        #equationInfo {
            position: absolute;
            top: 50px;
            width: 100%;
            text-align: center;
            color: #ff00ff; /* 네온 핑크 */
            padding: 5px;
            font-size: 22px;
            font-weight: bold;
            text-shadow: 0 0 10px #ff00ff, 0 0 20px #ff00ff;
            z-index: 10;
            letter-spacing: 1px;
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff0055;
            background-color: rgba(20, 20, 40, 0.9);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            display: none;
            z-index: 20;
            box-shadow: 0 0 20px #ff0055, 0 0 40px #ff0055;
            border: 2px solid #ff0055;
        }
        #gameOver h2 {
            font-size: 40px;
            text-shadow: 0 0 10px #ff0055, 0 0 20px #ff0055;
            margin-bottom: 20px;
        }
        #gameOver p {
            font-size: 24px;
            margin-bottom: 30px;
            color: #ffffff;
            text-shadow: 0 0 5px #ffffff;
        }
        #restartBtn {
            padding: 15px 40px;
            background-color: #ff0055;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 22px;
            margin-top: 20px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            box-shadow: 0 0 10px #ff0055, 0 0 20px #ff0055;
            transition: all 0.3s ease;
        }
        #restartBtn:hover {
            background-color: #ff3377;
            transform: scale(1.05);
            box-shadow: 0 0 15px #ff0055, 0 0 30px #ff0055;
        }
        #controls {
            position: absolute;
            bottom: 40px;
            width: 100%;
            display: flex;
            justify-content: center;
            z-index: 10;
        }
        .controlBtn {
            width: 100px;
            height: 100px;
            background-color: rgba(0, 200, 255, 0.2);
            border: 3px solid rgba(0, 200, 255, 0.8);
            border-radius: 50px;
            margin: 0 30px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #00FFFF;
            font-weight: bold;
            font-size: 30px;
            user-select: none;
            box-shadow: 0 0 15px #00FFFF;
            text-shadow: 0 0 10px #00FFFF;
        }
    </style>
</head>
<body>
    <div id="info">아군: <span id="allyCount">1</span> | 시간: <span id="timer">60</span>초 | 점수: <span id="score">0</span></div>
    <div id="equationInfo">현재 패널: <span id="currentEquation">없음</span></div>
    <div id="gameOver">
        <h2>게임 종료!</h2>
        <p>최종 점수: <span id="finalScore">0</span></p>
        <button id="restartBtn">다시 시작</button>
    </div>
    <div id="controls">
        <div id="leftBtn" class="controlBtn">←</div>
        <div id="rightBtn" class="controlBtn">→</div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // 게임 변수
        let scene, camera, renderer, allies = [], enemies = [], bullets = [], panels = [];
        let gameTime = 60; // 1분
        let score = 0;
        let difficulty = 1;
        let gameActive = true;
        let lastPanelTime = 0;
        let lastEnemyWaveTime = 0;
        let lastFireTime = 0;
        let playerLane = 1; // 0: 왼쪽, 1: 중앙, 2: 오른쪽
        let isMoving = false;
        let roadSpeed = 0.5;
        let roadSegments = [];
        let gameDistance = 0;
        let activeEquation = "";
        
        // 레인 위치 정의
        const lanes = [-5, 0, 5];
        
        // 수학 연산자 (각각 강한 네온 색상으로 변경)
        const operators = [
            { symbol: "+", fn: (a, b) => a + b, color: 0x00FFFF, glow: 0x00FFFF }, // 네온 청록색
            { symbol: "-", fn: (a, b) => Math.max(1, a - b), color: 0xFF1493, glow: 0xFF1493 }, // 네온 핑크
            { symbol: "×", fn: (a, b) => a * b, color: 0x39FF14, glow: 0x39FF14 }, // 네온 그린
            { symbol: "÷", fn: (a, b) => Math.round(a / b) || 1, color: 0xFFD700, glow: 0xFFD700 } // 네온 골드
        ];
        
        // 게임 초기화
        function init() {
            // 씬 설정
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e); // 어두운 남색 배경
            
            // 안개 추가 (원근감) - 더 짙게 설정
            scene.fog = new THREE.Fog(0x1a1a2e, 30, 80);
            
            // 카메라 설정
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 8, 12); // 카메라 높이와 거리 조정
            camera.lookAt(0, 0, -20);
            
            // 렌더러 설정
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; // 그림자 활성화
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);
            
            // 조명 설정
            const ambientLight = new THREE.AmbientLight(0x0000ff, 0.2); // 어두운 파란색 배경 조명
            scene.add(ambientLight);
            
            // 메인 조명 (더 강한 빛)
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
            directionalLight.position.set(0, 20, 10);
            directionalLight.castShadow = true; // 그림자 생성
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -20;
            directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20;
            directionalLight.shadow.camera.bottom = -20;
            scene.add(directionalLight);
            
            // 도로 강조를 위한 추가 조명
            const roadLight1 = new THREE.PointLight(0x00ffff, 1, 30); // 청록색 조명
            roadLight1.position.set(0, 10, -30);
            scene.add(roadLight1);
            
            const roadLight2 = new THREE.PointLight(0xff00ff, 1, 30); // 자홍색 조명
            roadLight2.position.set(0, 10, -60);
            scene.add(roadLight2);
            
            // 플레이어 주변에 항상 따라다니는 조명
            const playerLight = new THREE.PointLight(0xffffff, 1, 15);
            playerLight.position.set(0, 5, 5);
            scene.add(playerLight);
            
            // playerLight를 플레이어와 함께 이동시키기 위해 저장
            window.playerLight = playerLight;
            
            // 도로 생성
            createRoad();
            
            // 첫 아군 생성
            createAllies(1);
            
            // 이벤트 리스너
            window.addEventListener('resize', onWindowResize);
            document.getElementById('restartBtn').addEventListener('click', restartGame);
            
            // 모바일 컨트롤 초기화
            initControls();
            
            // 게임 타이머 시작
            startGameTimer();
            
            // 게임 루프 시작
            animate();
        }
        
        // 도로 생성 함수
        function createRoad() {
            // 도로 텍스처 (하늘색 그라데이션 패턴으로 변경)
            const roadWidth = 15;
            const roadLength = 1000;
            const segmentLength = 20;
            const segments = roadLength / segmentLength;
            
            // 도로 기본 재질 (네온 효과가 있는 어두운 색상)
            const roadMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x0f3460,
                roughness: 0.5,
                metalness: 0.7,
                emissive: 0x0f3460,
                emissiveIntensity: 0.2
            });
            
            // 도로 경계선 재질 (밝은 네온 색상)
            const lineMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xE94560, 
                emissive: 0xE94560,
                emissiveIntensity: 0.7
            });
            
            // 도로 가장자리 재질 (네온 푸른색)
            const sideMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x16213E,
                emissive: 0x0F52BA,
                emissiveIntensity: 0.3
            });
            
            // 도로 그라데이션을 위한 재질 배열 (네온 효과가 있는 패턴)
            const patternMaterials = [
                new THREE.MeshStandardMaterial({ 
                    color: 0x0f3460, 
                    emissive: 0x0f3460,
                    emissiveIntensity: 0.2
                }),
                new THREE.MeshStandardMaterial({ 
                    color: 0x16213E, 
                    emissive: 0x16213E,
                    emissiveIntensity: 0.2
                })
            ];
            
            // 여러 세그먼트로 도로 생성
            for (let i = 0; i < segments; i++) {
                // 도로 세그먼트 (패턴 적용)
                const roadGeometry = new THREE.PlaneGeometry(roadWidth, segmentLength);
                const road = new THREE.Mesh(roadGeometry, patternMaterials[i % 2]); // 번갈아가며 패턴 적용
                road.rotation.x = -Math.PI / 2;
                road.position.z = -i * segmentLength - segmentLength / 2;
                road.position.y = -0.1;
                road.receiveShadow = true; // 그림자 받기
                scene.add(road);
                roadSegments.push(road);
                
                // 도로 레인 구분선
                for (let j = -1; j <= 1; j += 2) {
                    const lineGeometry = new THREE.PlaneGeometry(0.3, segmentLength);
                    const line = new THREE.Mesh(lineGeometry, lineMaterial);
                    line.rotation.x = -Math.PI / 2;
                    line.position.set(j * roadWidth/6, -0.05, -i * segmentLength - segmentLength / 2);
                    line.receiveShadow = true;
                    scene.add(line);
                    roadSegments.push(line);
                }
                
                // 도로 가장자리
                for (let j = -1; j <= 1; j += 2) {
                    const sideGeometry = new THREE.BoxGeometry(2, 1, segmentLength);
                    const side = new THREE.Mesh(sideGeometry, sideMaterial);
                    side.position.set(j * (roadWidth/2 + 1), 0.4, -i * segmentLength - segmentLength / 2);
                    side.castShadow = true;
                    side.receiveShadow = true;
                    scene.add(side);
                    roadSegments.push(side);
                    
                    // 가드레일 기둥 추가
                    if (i % 2 === 0) {
                        const postGeometry = new THREE.BoxGeometry(0.5, 2, 0.5);
                        const postMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
                        const post = new THREE.Mesh(postGeometry, postMaterial);
                        post.position.set(j * (roadWidth/2 + 1), 1.5, -i * segmentLength - segmentLength / 2);
                        post.castShadow = true;
                        post.receiveShadow = true;
                        scene.add(post);
                        roadSegments.push(post);
                    }
                }
            }
        }
        
        // 도로 스크롤 함수
        function scrollRoad() {
            const resetPos = -1000; // 도로 총 길이
            
            roadSegments.forEach(segment => {
                segment.position.z += roadSpeed;
                
                // 도로 세그먼트가 카메라 뒤로 지나가면 다시 앞으로 재배치
                if (segment.position.z > 20) {
                    segment.position.z = resetPos + (segment.position.z - 20);
                }
            });
            
            // 거리 증가
            gameDistance += roadSpeed;
        }
        
        // 컨트롤 초기화
        function initControls() {
            const leftBtn = document.getElementById('leftBtn');
            const rightBtn = document.getElementById('rightBtn');
            
            // 터치 이벤트
            leftBtn.addEventListener('touchstart', moveLeft);
            rightBtn.addEventListener('touchstart', moveRight);
            
            // 마우스 이벤트 (데스크톱용)
            leftBtn.addEventListener('mousedown', moveLeft);
            rightBtn.addEventListener('mousedown', moveRight);
            
            // 키보드 이벤트
            window.addEventListener('keydown', function(e) {
                if (!gameActive || isMoving) return;
                
                if (e.key === 'ArrowLeft') {
                    moveLeft();
                } else if (e.key === 'ArrowRight') {
                    moveRight();
                }
            });
            
            function moveLeft() {
                if (!gameActive || isMoving || playerLane === 0) return;
                
                isMoving = true;
                playerLane--;
                moveAlliesTo(lanes[playerLane]);
            }
            
            function moveRight() {
                if (!gameActive || isMoving || playerLane === 2) return;
                
                isMoving = true;
                playerLane++;
                moveAlliesTo(lanes[playerLane]);
            }
        }
        
        // 아군 이동 함수
        function moveAlliesTo(targetX) {
            // 0.3초에 걸쳐 부드럽게 이동
            const frames = 15; // 60fps 기준 0.25초
            let currentFrame = 0;
            
            // 메인 아군 현재 위치
            const startX = allies[0].position.x;
            const moveAmount = (targetX - startX) / frames;
            
            const moveInterval = setInterval(() => {
                if (currentFrame >= frames) {
                    clearInterval(moveInterval);
                    isMoving = false;
                    return;
                }
                
                // 모든 아군 이동
                allies.forEach((ally, index) => {
                    if (index === 0) {
                        // 메인 아군
                        ally.position.x += moveAmount;
                    } else {
                        // 나머지 아군들은 메인 아군을 따라감
                        updateAllyFormation();
                    }
                });
                
                currentFrame++;
            }, 1000/60); // 60fps
        }
        
        // 아군 진형 업데이트
        function updateAllyFormation() {
            if (allies.length <= 1) return;
            
            const mainAlly = allies[0];
            const allyCount = allies.length;
            
            // 진영 크기 계산 - 아군이 많을수록 더 넓게 퍼짐
            const formationWidth = Math.min(3, 0.5 + (allyCount * 0.1));
            const formationDepth = Math.min(4, 1 + (allyCount * 0.15));
            
            for (let i = 1; i < allyCount; i++) {
                // 균등하게 분포된 위치 계산
                let row = Math.floor((i-1) / 3);
                let col = (i-1) % 3;
                
                // 중앙 정렬을 위한 오프셋
                let colOffset = col - 1; // -1, 0, 1
                let rowOffset = -row; // 항상 플레이어 뒤에 배치
                
                allies[i].position.x = mainAlly.position.x + (colOffset * formationWidth);
                allies[i].position.z = mainAlly.position.z + (rowOffset * formationDepth);
            }
        }
        
        // 아군 생성 함수 - 캐릭터 디자인 개선
        function createAllies(count) {
            // 기존 아군 제거
            allies.forEach(ally => scene.remove(ally));
            allies = [];
            
            // 최댓값 제한 (너무 많으면 게임이 쉬워짐)
            count = Math.min(count, 30);
            
            // 새 아군 생성 - 귀여운 오렌지색 캐릭터로 변경
            for (let i = 0; i < count; i++) {
                // 캐릭터 그룹
                const character = new THREE.Group();
                
                // 몸체 (구)
                const bodyGeometry = new THREE.SphereGeometry(0.5, 16, 16);
                const bodyMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFF9900, // 오렌지색
                    emissive: 0xAA5500,
                    emissiveIntensity: 0.2,
                    roughness: 0.7
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.castShadow = true;
                body.receiveShadow = true;
                character.add(body);
                
                // 캐릭터에 눈 추가
                const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
                
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(0.2, 0.2, 0.4);
                character.add(leftEye);
                
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(-0.2, 0.2, 0.4);
                character.add(rightEye);
                
                // 눈동자
                const pupilGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                const pupilMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
                
                const leftPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                leftPupil.position.set(0.2, 0.2, 0.45);
                character.add(leftPupil);
                
                const rightPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                rightPupil.position.set(-0.2, 0.2, 0.45);
                character.add(rightPupil);
                
                // 팔과 다리 추가 (메인 캐릭터만)
                if (i === 0) {
                    // 팔
                    const armGeometry = new THREE.SphereGeometry(0.15, 8, 8);
                    
                    const leftArm = new THREE.Mesh(armGeometry, bodyMaterial);
                    leftArm.position.set(0.6, 0, 0);
                    leftArm.castShadow = true;
                    character.add(leftArm);
                    
                    const rightArm = new THREE.Mesh(armGeometry, bodyMaterial);
                    rightArm.position.set(-0.6, 0, 0);
                    rightArm.castShadow = true;
                    character.add(rightArm);
                    
                    // 다리
                    const legGeometry = new THREE.CylinderGeometry(0.15, 0.1, 0.5, 8);
                    
                    const leftLeg = new THREE.Mesh(legGeometry, bodyMaterial);
                    leftLeg.position.set(0.2, -0.5, 0);
                    leftLeg.castShadow = true;
                    character.add(leftLeg);
                    
                    const rightLeg = new THREE.Mesh(legGeometry, bodyMaterial);
                    rightLeg.position.set(-0.2, -0.5, 0);
                    rightLeg.castShadow = true;
                    character.add(rightLeg);
                }
                
                if (i === 0) {
                    // 메인 아군 (플레이어)
                    character.position.set(lanes[playerLane], 0.5, 0);
                } else {
                    // 추가 아군들은 초기 위치만 설정 (updateAllyFormation에서 정확히 배치됨)
                    character.position.set(lanes[playerLane], 0.5, -i);
                    // 작게 만들기
                    character.scale.set(0.8, 0.8, 0.8);
                }
                
                scene.add(character);
                allies.push(character);
            }
            
            // 진형 업데이트
            updateAllyFormation();
            
            // UI 업데이트
            document.getElementById('allyCount').textContent = allies.length;
        }
        
        // 적 생성 함수 - 웨이브 형태로 생성
        function createEnemyWave() {
            const waveType = Math.floor(Math.random() * 4);
            
            switch (waveType) {
                case 0: // 일렬 웨이브
                    const randomLane = Math.floor(Math.random() * 3);
                    for (let i = 0; i < 5 + Math.floor(difficulty); i++) {
                        createEnemy(randomLane, -80 - (i * 4));
                    }
                    break;
                    
                case 1: // V 형태 웨이브
                    for (let i = 0; i < 7; i++) {
                        const laneOffset = (i <= 3) ? i : 6 - i; // 0,1,2,3,2,1,0
                        createEnemy(laneOffset, -80 - (i * 3));
                    }
                    break;
                    
                case 2: // 모든 레인 웨이브
                    for (let i = 0; i < 3; i++) {
                        for (let j = 0; j < 3; j++) {
                            createEnemy(j, -80 - (i * 5));
                        }
                    }
                    break;
                    
                case 3: // 랜덤 웨이브
                    const enemyCount = 5 + Math.floor(difficulty * 2);
                    for (let i = 0; i < enemyCount; i++) {
                        const randLane = Math.floor(Math.random() * 3);
                        const randDist = -80 - (Math.random() * 20);
                        createEnemy(randLane, randDist);
                    }
                    break;
            }
            
            function createEnemy(lane, zPos) {
                // 적 그룹
                const enemy = new THREE.Group();
                
                // 적 몸체 (더 큰 크기와 강한 네온 빨간색)
                const enemyGeometry = new THREE.SphereGeometry(0.6, 16, 16);
                const enemyMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xff0000,
                    emissive: 0xff0000,
                    emissiveIntensity: 0.8,
                    roughness: 0.3,
                    metalness: 0.7
                });
                const body = new THREE.Mesh(enemyGeometry, enemyMaterial);
                body.castShadow = true;
                body.receiveShadow = true;
                enemy.add(body);
                
                // 적 눈 (흰색)
                const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
                
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(0.2, 0.2, 0.4);
                enemy.add(leftEye);
                
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(-0.2, 0.2, 0.4);
                enemy.add(rightEye);
                
                // 적 눈동자 (검은색)
                const pupilGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                const pupilMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
                
                const leftPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                leftPupil.position.set(0.2, 0.2, 0.45);
                enemy.add(leftPupil);
                
                const rightPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                rightPupil.position.set(-0.2, 0.2, 0.45);
                enemy.add(rightPupil);
                
                enemy.position.set(lanes[lane], 0.5, zPos);
                scene.add(enemy);
                enemies.push(enemy);
            }
        }
        
        // 총알 발사 함수
        function fireBullets() {
            const currentTime = Date.now();
            
            // 자동 발사 간격 (아군 수에 따라 감소)
            const fireInterval = Math.max(100, 500 - (allies.length * 10));
            
            if (currentTime - lastFireTime < fireInterval) return;
            
            lastFireTime = currentTime;
            
            // 아군 수에 비례해서 총알 발사 (아군당 0.5발의 총알)
            const bulletsToFire = Math.max(1, Math.ceil(allies.length * 0.5));
            
            for (let i = 0; i < bulletsToFire; i++) {
                const bulletGeometry = new THREE.SphereGeometry(0.3, 8, 8);
                const bulletMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFFFF00, 
                    emissive: 0xFFFF00,
                    emissiveIntensity: 1.0,
                    metalness: 1.0,
                    roughness: 0.0
                });
                const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
                
                // 총알 발사 방향 다각화
                let angleOffset = 0;
                if (bulletsToFire > 1) {
                    // 부채꼴 형태로 퍼지게 발사
                    const spreadFactor = Math.min(0.3, bulletsToFire * 0.02);  // 최대 0.3 라디안 (약 17도)
                    angleOffset = spreadFactor * ((i / (bulletsToFire - 1)) * 2 - 1);
                }
                
                // 총알 위치는 무작위 아군 위치에서 시작
                const shooterIndex = Math.floor(Math.random() * allies.length);
                bullet.position.copy(allies[shooterIndex].position);
                bullet.position.z -= 1; // 약간 앞에서 발사
                
                // 총알 방향 설정
                bullet.userData.direction = new THREE.Vector3(angleOffset, 0, -1).normalize();
                bullet.userData.speed = 1.5;
                
                scene.add(bullet);
                bullets.push(bullet);
                
                // 총알 발사 이펙트 (강한 빛)
                const bulletLight = new THREE.PointLight(0xffff00, 5, 8);
                bulletLight.position.copy(bullet.position);
                scene.add(bulletLight);
                
                // 추가 발광 효과 (더 넓은 범위)
                const bulletGlow = new THREE.PointLight(0xffff00, 2, 15);
                bulletGlow.position.copy(bullet.position);
                scene.add(bulletGlow);
                
                // 0.1초 후 이펙트 제거
                setTimeout(() => {
                    scene.remove(bulletLight);
                }, 100);
            }
        }
        
        // 사칙연산 패널 생성 함수
        function createMathPanels() {
            // 기존 패널 제거
            panels.forEach(panel => scene.remove(panel));
            panels = [];
            
            // 랜덤 연산자 선택
            const operator = operators[Math.floor(Math.random() * operators.length)];
            
            // 피연산자 선택 (난이도에 따라 증가)
            const operand = Math.floor(Math.random() * Math.min(5, difficulty)) + 1;
            
            // 현재 아군 수와 연산 결과 계산
            const currentAllies = allies.length;
            const result = operator.fn(currentAllies, operand);
            
            // 연산 표시 업데이트
            activeEquation = `${currentAllies} ${operator.symbol} ${operand} = ${result}`;
            document.getElementById('currentEquation').textContent = activeEquation;
            
            // 도로 세 레인에 패널 생성
            for (let i = 0; i < 3; i++) {
                createMathPanel(lanes[i], -60 - Math.random() * 10, operand, operator);
            }
            
            function createMathPanel(x, z, operand, operator) {
                // 패널 그룹
                const panel = new THREE.Group();
                
                // 패널 플랫폼
                const panelGeometry = new THREE.BoxGeometry(3, 0.3, 3);
                
                // 연산자에 맞는 색상 적용 (강한 네온 효과)
                const panelMaterial = new THREE.MeshStandardMaterial({ 
                    color: operator.color,
                    emissive: operator.glow,
                    emissiveIntensity: 0.8,
                    transparent: true,
                    opacity: 0.9
                });
                
                const panelMesh = new THREE.Mesh(panelGeometry, panelMaterial);
                panelMesh.castShadow = true;
                panelMesh.receiveShadow = true;
                panel.add(panelMesh);
                
                // 패널에 숫자 표시를 위한 텍스트 (Three.js에서는 실제 텍스트 렌더링이 어려워 대체 표현)
                const operatorSymbol = operator.symbol;
                const operatorTextGeometry = new THREE.BoxGeometry(1, 0.1, 1);
                const operatorTextMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFFFFFF,
                    emissive: 0xFFFFFF,
                    emissiveIntensity: 0.5
                });
                
                const operatorText = new THREE.Mesh(operatorTextGeometry, operatorTextMaterial);
                operatorText.position.y = 0.2;
                panel.add(operatorText);
                
                // 숫자 표시 (간소화된 형태)
                const numberGeometry = new THREE.BoxGeometry(0.5, 0.1, 0.5);
                const numberMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
                const numberMesh = new THREE.Mesh(numberGeometry, numberMaterial);
                numberMesh.position.set(0, 0.2, 0.5);
                panel.add(numberMesh);
                
                // 패널 위치 설정
                panel.position.set(x, 0, z);
                
                // 패널에 연산 데이터 추가
                panel.userData = {
                    operator: operatorSymbol,
                    operand: operand,
                    result: result
                };
                
                // 패널 강한 발광 효과
                const panelLight = new THREE.PointLight(operator.color, 2, 8);
                panelLight.position.set(0, 0.5, 0);
                panel.add(panelLight);
                
                // 추가 외곽 발광 효과
                const outerGlow = new THREE.PointLight(operator.color, 1, 15);
                outerGlow.position.set(0, 1, 0);
                panel.add(outerGlow);
                
                // 패널 주변 네온 효과를 위한 추가 메시
                const glowGeometry = new THREE.BoxGeometry(3.2, 0.1, 3.2);
                const glowMaterial = new THREE.MeshBasicMaterial({ 
                    color: operator.color,
                    transparent: true,
                    opacity: 0.5
                });
                const glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
                glowMesh.position.y = -0.2;
                panel.add(glowMesh);
                
                scene.add(panel);
                panels.push(panel);
            }
        }
        
        // 게임 업데이트 함수
        function updateGame() {
            const currentTime = Date.now();
            
            // 도로 스크롤
            scrollRoad();
            
            // 3초마다 패널 생성
            if (currentTime - lastPanelTime > 3000) {
                createMathPanels();
                lastPanelTime = currentTime;
            }
            
            // 난이도에 따라 적 웨이브 생성 주기 조절
            const enemyWaveInterval = Math.max(2000, 5000 - (difficulty * 300));
            if (currentTime - lastEnemyWaveTime > enemyWaveInterval) {
                createEnemyWave();
                lastEnemyWaveTime = currentTime;
            }
            
            // 자동 총알 발사
            fireBullets();
            
            // 패널 이동 (도로와 함께 이동)
            panels.forEach(panel => {
                panel.position.z += roadSpeed;
                
                // 화면 끝에 도달한 패널은 제거
                if (panel.position.z > 10) {
                    scene.remove(panel);
                    panels.splice(panels.indexOf(panel), 1);
                    
                    // 모든 패널이 사라졌을 때 현재 연산 초기화
                    if (panels.length === 0) {
                        document.getElementById('currentEquation').textContent = "없음";
                    }
                }
            });
            
            // 적 이동 (도로와 함께 이동, 약간 더 빠르게)
            enemies.forEach(enemy => {
                enemy.position.z += roadSpeed * 1.2;
                
                // 화면 끝에 도달한 적은 제거
                if (enemy.position.z > 10) {
                    scene.remove(enemy);
                    enemies.splice(enemies.indexOf(enemy), 1);
                }
                
                // 적 애니메이션 (약간 상하로 움직임)
                enemy.position.y = 0.5 + Math.sin(currentTime / 300 + enemy.position.z) * 0.1;
                
                // 추가: 적 회전 애니메이션
                enemy.rotation.y += 0.02;
            });
            
            // 아군 애니메이션 (더 뚜렷한 움직임)
            allies.forEach((ally, index) => {
                // 메인 캐릭터 (0번 인덱스)만 특별한 애니메이션 적용
                if (index === 0) {
                    ally.position.y = 0.5 + Math.sin(currentTime / 400) * 0.1;
                    
                    // 달리기 애니메이션 효과 (더 명확한 움직임)
                    ally.rotation.x = Math.sin(currentTime / 200) * 0.15;
                    
                    // 플레이어 조명 위치 업데이트
                    if (window.playerLight) {
                        window.playerLight.position.copy(ally.position);
                        window.playerLight.position.y += 3;
                        window.playerLight.position.z += 2;
                    }
                } else {
                    // 다른 아군들은 약간 다른 주기로 움직여 자연스러움 증가
                    ally.position.y = 0.5 + Math.sin((currentTime / 400) + index * 0.5) * 0.1;
                    ally.rotation.y += 0.01; // 약간 회전하여 더 생동감 있게
                }
            });
            
            // 총알 이동
            bullets.forEach(bullet => {
                const direction = bullet.userData.direction;
                bullet.position.x += direction.x * bullet.userData.speed;
                bullet.position.z += direction.z * bullet.userData.speed;
                
                // 총알 회전 효과 추가
                bullet.rotation.x += 0.2;
                bullet.rotation.y += 0.2;
                
                // 화면 밖으로 나간 총알 제거
                if (bullet.position.z < -100) {
                    scene.remove(bullet);
                    bullets.splice(bullets.indexOf(bullet), 1);
                }
            });
            
            // 충돌 체크
            checkCollisions();
            
            // 난이도 증가
            difficulty = 1 + ((60 - gameTime) / 5);
            
            // 도로 속도 증가 (난이도에 따라)
            roadSpeed = 0.5 + (difficulty * 0.05);
        }
        
        // 충돌 체크 함수 - 시각적 효과 추가
        function checkCollisions() {
            // 총알과 적의 충돌
            bullets.forEach(bullet => {
                enemies.forEach(enemy => {
                    const distance = bullet.position.distanceTo(enemy.position);
                    if (distance < 1) {
                        // 충돌 시 폭발 효과
                        createExplosion(enemy.position.clone());
                        
                        // 충돌 발생
                        scene.remove(bullet);
                        scene.remove(enemy);
                        bullets.splice(bullets.indexOf(bullet), 1);
                        enemies.splice(enemies.indexOf(enemy), 1);
                        
                        // 점수 추가
                        score += 10;
                        document.getElementById('score').textContent = score;
                    }
                });
            });
            
            // 플레이어(메인 아군)와 패널의 충돌
            if (allies.length > 0) {
                const player = allies[0];
                
                panels.forEach(panel => {
                    const distance = Math.sqrt(
                        Math.pow(player.position.x - panel.position.x, 2) +
                        Math.pow(player.position.z - panel.position.z, 2)
                    );
                    
                    if (distance < 2) {
                        // 패널과 충돌 - 사칙연산 수행
                        if (panel.userData.result !== undefined) {
                            // 패널 획득 효과
                            createPanelEffect(player.position.clone());
                            
                            createAllies(panel.userData.result);
                            
                            // 보너스 점수
                            score += 50;
                            document.getElementById('score').textContent = score;
                            
                            // 모든 패널 제거
                            panels.forEach(p => scene.remove(p));
                            panels = [];
                            
                            // 연산 초기화
                            document.getElementById('currentEquation').textContent = "없음";
                        }
                    }
                });
                
                // 플레이어와 적의 충돌
                enemies.forEach(enemy => {
                    const distance = player.position.distanceTo(enemy.position);
                    if (distance < 1.2) {
                        // 충돌 시 데미지 효과
                        createDamageEffect(player.position.clone());
                        
                        // 충돌 발생 - 아군 감소
                        if (allies.length > 1) {
                            createAllies(allies.length - 1);
                            
                            // 해당 적 제거
                            scene.remove(enemy);
                            enemies.splice(enemies.indexOf(enemy), 1);
                        } else {
                            // 마지막 아군이 적과 충돌하면 게임 오버
                            endGame();
                        }
                    }
                });
            }
        }
        
        // 폭발 효과 생성 함수
        function createExplosion(position) {
            // 폭발 파티클 그룹
            const explosionGroup = new THREE.Group();
            explosionGroup.position.copy(position);
            
            // 폭발 빛
            const explosionLight = new THREE.PointLight(0xff5500, 3, 8);
            explosionLight.position.set(0, 0, 0);
            explosionGroup.add(explosionLight);
            
            // 파티클 생성
            const particleCount = 10;
            const particles = [];
            
            for (let i = 0; i < particleCount; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const particleMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xff5500, 
                    transparent: true, 
                    opacity: 1
                });
                
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                
                // 랜덤 방향으로 튀어나감
                const angle1 = Math.random() * Math.PI * 2;
                const angle2 = Math.random() * Math.PI * 2;
                
                const speed = 0.1 + Math.random() * 0.2;
                particle.userData.velocity = new THREE.Vector3(
                    Math.sin(angle1) * Math.cos(angle2) * speed,
                    Math.sin(angle1) * Math.sin(angle2) * speed,
                    Math.cos(angle1) * speed
                );
                
                explosionGroup.add(particle);
                particles.push(particle);
            }
            
            scene.add(explosionGroup);
            
            // 0.5초 동안 폭발 애니메이션
            let elapsed = 0;
            const duration = 500; // 밀리초
            const interval = setInterval(() => {
                elapsed += 16;
                
                // 파티클 이동 및 페이드 아웃
                particles.forEach(particle => {
                    particle.position.add(particle.userData.velocity);
                    particle.material.opacity = 1 - (elapsed / duration);
                    particle.scale.multiplyScalar(0.98);
                });
                
                // 빛 감소
                explosionLight.intensity = 3 * (1 - elapsed / duration);
                
                if (elapsed >= duration) {
                    clearInterval(interval);
                    scene.remove(explosionGroup);
                }
            }, 16);
        }
        
        // 패널 획득 효과
        function createPanelEffect(position) {
            // 빛 생성
            const light = new THREE.PointLight(0x00ffff, 3, 10);
            light.position.copy(position);
            scene.add(light);
            
            // 0.5초 동안 빛 효과
            let elapsed = 0;
            const duration = 500; // 밀리초
            const interval = setInterval(() => {
                elapsed += 16;
                
                // 빛 강도 조절
                light.intensity = 3 * (1 - elapsed / duration);
                
                if (elapsed >= duration) {
                    clearInterval(interval);
                    scene.remove(light);
                }
            }, 16);
        }
        
        // 데미지 효과
        function createDamageEffect(position) {
            // 빨간 빛 생성
            const light = new THREE.PointLight(0xff0000, 3, 10);
            light.position.copy(position);
            scene.add(light);
            
            // 화면 빨갛게 깜빡임 (CSS 효과)
            const overlay = document.createElement('div');
            overlay.style.position = 'absolute';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.width = '100%';
            overlay.style.height = '100%';
            overlay.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
            overlay.style.pointerEvents = 'none';
            overlay.style.transition = 'opacity 0.5s';
            document.body.appendChild(overlay);
            
            // 0.5초 동안 효과
            setTimeout(() => {
                overlay.style.opacity = '0';
                setTimeout(() => {
                    document.body.removeChild(overlay);
                }, 500);
            }, 100);
            
            // 빛 효과 제거
            setTimeout(() => {
                scene.remove(light);
            }, 500);
        }
        
        // 게임 타이머 함수
        function startGameTimer() {
            const timerInterval = setInterval(() => {
                if (!gameActive) {
                    clearInterval(timerInterval);
                    return;
                }
                
                gameTime--;
                document.getElementById('timer').textContent = gameTime;
                
                if (gameTime <= 0) {
                    clearInterval(timerInterval);
                    endGame();
                }
            }, 1000);
        }
        
        // 게임 종료 함수
        function endGame() {
            gameActive = false;
            document.getElementById('gameOver').style.display = 'block';
            document.getElementById('finalScore').textContent = score;
            
            // 게임 오버 효과
            const gameOverLight = new THREE.AmbientLight(0xff0000, 0.3);
            scene.add(gameOverLight);
            
            // 모든 아군 회전 애니메이션
            const rotateAllies = () => {
                allies.forEach(ally => {
                    ally.rotation.y += 0.05;
                });
                
                if (gameActive) {
                    return;
                }
                
                requestAnimationFrame(rotateAllies);
            };
            
            rotateAllies();
        }
        
        // 게임 재시작 함수
        function restartGame() {
            // 기존 오브젝트 정리
            allies.forEach(ally => scene.remove(ally));
            enemies.forEach(enemy => scene.remove(enemy));
            bullets.forEach(bullet => scene.remove(bullet));
            panels.forEach(panel => scene.remove(panel));
            
            // 씬의 모든 빛 제거 (게임 오버 효과 제거)
            scene.children.forEach(child => {
                if (child instanceof THREE.Light && !(child instanceof THREE.DirectionalLight) && !(child instanceof THREE.AmbientLight && child.intensity === 0.6)) {
                    scene.remove(child);
                }
            });
            
            allies = [];
            enemies = [];
            bullets = [];
            panels = [];
            
            // 변수 초기화
            gameTime = 60;
            score = 0;
            difficulty = 1;
            gameActive = true;
            lastPanelTime = 0;
            lastEnemyWaveTime = 0;
            playerLane = 1; // 중앙 레인으로 초기화
            isMoving = false;
            roadSpeed = 0.5;
            gameDistance = 0;
            
            // UI 초기화
            document.getElementById('timer').textContent = gameTime;
            document.getElementById('score').textContent = score;
            document.getElementById('currentEquation').textContent = "없음";
            document.getElementById('gameOver').style.display = 'none';
            
            // 기본 조명 재설정
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(0, 20, 10);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // 첫 아군 생성
            createAllies(1);
            
            // 타이머 재시작
            startGameTimer();
        }
        
        // 애니메이션 루프
        function animate() {
            requestAnimationFrame(animate);
            
            if (gameActive) {
                updateGame();
            }
            
            renderer.render(scene, camera);
        }
        
        // 화면 크기 조정 이벤트
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // 게임 시작
        init();
    </script>
</body>
</html>
